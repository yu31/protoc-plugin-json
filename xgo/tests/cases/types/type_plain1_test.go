package types

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbtypes"
	"github.com/yu31/protoc-plugin-json/xgo/tests/utils"
)

type CopyPlain1 pbtypes.TypePlain1

var seedPlain1 = &pbtypes.TypePlain1{
	FString1:    "s1",
	FString2:    "s2",
	FInt32:      10,
	FInt64:      11,
	FUint32:     12,
	FUint64:     13,
	FSint32:     14,
	FSint64:     15,
	FSfixed32:   16,
	FSfixed64:   17,
	FFixed32:    18,
	FFixed64:    19,
	FFloat:      11.11,
	FDouble:     12.12,
	FBool1:      true,
	FBytes1:     []byte("bytes1"),
	FEnum1:      2,
	FEnum2:      3,
	FEnum3:      5,
	FEnum4:      6,
	FEnum5:      7,
	FEnum6:      9,
	FDuration1:  &durationpb.Duration{Seconds: 100, Nanos: 101},
	FDuration2:  &durationpb.Duration{Seconds: 0, Nanos: 0},
	FTimestamp1: &timestamppb.Timestamp{Seconds: 200, Nanos: 201},
	FTimestamp2: &timestamppb.Timestamp{Seconds: 0, Nanos: 0},
	FAny1:       utils.MustNewAny(&pbexternal.Message1{FString1: "any11", FString2: "any12", FString3: "any13"}),
	FAny2:       utils.MustNewAny(&pbtypes.MessagePlain1{FString1: "any21", FString2: "any22", FString3: "any23"}),
	FMessage1:   &pbtypes.MessagePlain1{FString1: "1101", FString2: "1102", FString3: "1103"},
	FMessage2:   &pbtypes.MessagePlain1_Embed1{FString1: "1201", FString2: "1202", FString3: "1203"},
	FMessage3:   &pbtypes.MessagePlain1_Embed1_Embed2{FString1: "1301", FString2: "1302", FString3: "1303"},
	FMessage4:   &pbexternal.Message1{FString1: "1401", FString2: "1402", FString3: "1403"},
	FMessage5:   &pbexternal.Message1_Embed1{FString1: "1501", FString2: "1502", FString3: "1503"},
	FMessage6:   &pbexternal.Message1_Embed1_Embed2{FString1: "1601", FString2: "1602", FString3: "1603"},
	FMessage7:   &pbtypes.MessageCommon1{FString1: "1701", FString2: "1702", FString3: "1703"},
	FMessage8:   &pbtypes.MessageCommon1_Embed1{FString1: "1801", FString2: "1802", FString3: "1803"},
	FMessage9:   &pbtypes.MessageCommon1_Embed1_Embed2{FString1: "1901", FString2: "1902", FString3: "1903"},
}

func Test_TypePlain1_Assert_Type(t *testing.T) {
	data := &pbtypes.TypePlain1{}
	_, ok1 := interface{}(data).(json.Marshaler)
	require.True(t, ok1)
	_, ok2 := interface{}(data).(json.Unmarshaler)
	require.True(t, ok2)
}

func Test_TypePlain1_Assert_Copy(t *testing.T) {
	dataCopy := &CopyPlain1{}
	_, ok1 := interface{}(dataCopy).(json.Marshaler)
	require.False(t, ok1)
	_, ok2 := interface{}(dataCopy).(json.Unmarshaler)
	require.False(t, ok2)
}

// Test cases for marshal/unmarshal
func Test_TypePlain1_General(t *testing.T) {
	var (
		err error
		b1  []byte
	)
	t.Run("marshal", func(t *testing.T) {
		b1, err = seedPlain1.MarshalJSON()
		require.Nil(t, err)
	})
	t.Run("unmarshal", func(t *testing.T) {
		dataNew := &pbtypes.TypePlain1{}
		require.NotEqual(t, seedPlain1, dataNew)
		err = dataNew.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, seedPlain1, dataNew)
	})
}

// Test compatible with standard JSON with follow cases:
//   1. The json content that get by MarshalJSON that code generated by plugin can be used to standard json.Unmarshal.
//   2. The json content that get by standard json.Marshal can be used to UnmarshalJSON that code generated by plugin.
func Test_TypePlain1_Compatible(t *testing.T) {
	var (
		err error
		b1  []byte
		b2  []byte
		b3  []byte
	)
	_ = b3

	// Get json content by MarshalJSON.
	b1, err = seedPlain1.MarshalJSON()
	require.Nil(t, err)

	dataCopy := &CopyPlain1{}
	// Test the json content is correctly.
	// and same as copy the value to dataCopy.
	err = json.Unmarshal(b1, dataCopy)
	require.Nil(t, err)

	// Get json context by json.Marshal
	b2, err = json.Marshal(dataCopy)
	require.Nil(t, err)

	// Compare the json content.
	require.Equal(t, b1, b2)

	// Test the UnmarshalJSON
	dataNew := &pbtypes.TypePlain1{}
	err = dataNew.UnmarshalJSON(b2)
	require.Nil(t, err)
	require.Equal(t, seedPlain1, dataNew)

	// proto
	b3, err = utils.PMarshal.Marshal(seedPlain1)
	require.Nil(t, err)

	fmt.Println("================================================================================================")
	fmt.Println(string(b1))
	fmt.Println("================================================================================================")
	fmt.Println(string(b2))
	fmt.Println("================================================================================================")
	fmt.Println(string(b3))
	fmt.Println("================================================================================================")
}

// Test cases the field is empty.
func Test_TypePlain1_Empty(t *testing.T) {
	dataEmtpy := &pbtypes.TypePlain1{}
	dataCopy := &CopyPlain1{}

	var (
		err error
		b1  []byte
		b2  []byte
	)

	t.Run("marshal", func(t *testing.T) {
		b1, err = dataEmtpy.MarshalJSON()
		require.Nil(t, err)
		b2, err = json.Marshal(dataCopy)
		require.Nil(t, err)
	})
	t.Run("unmarshal-plugin", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &pbtypes.TypePlain1{}
		err = data1.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data1)

		// use content that get by json.Marshal
		data2 := &pbtypes.TypePlain1{}
		err = data2.UnmarshalJSON(b2)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data2)
	})
	t.Run("unmarshal-standard", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &CopyPlain1{}
		err = json.Unmarshal(b1, data1)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data1)

		// use content that get by json.Marshal
		data2 := &CopyPlain1{}
		err = json.Unmarshal(b2, data2)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data2)
	})
}

func Test_TypePlain1_NULL(t *testing.T) {
	data1 := &pbtypes.TypePlain1{}
	data2 := &CopyPlain1{}

	var err error
	err = data1.UnmarshalJSON([]byte("null"))
	require.Nil(t, err)

	err = json.Unmarshal([]byte("null"), data2)
	require.Nil(t, err)
}
