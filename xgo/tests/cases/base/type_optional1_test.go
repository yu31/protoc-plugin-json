package base

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbbase"

	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	"github.com/yu31/protoc-plugin-json/xgo/tests/utils"
)

type CopyOptional1 pbbase.TypeOptional1

var seedOptional1 = &pbbase.TypeOptional1{
	FString1:    utils.PointerString("s1"),
	FString2:    utils.PointerString("s2"),
	FInt32:      utils.PointerInt32(10),
	FInt64:      utils.PointerInt64(11),
	FUint32:     utils.PointerUint32(12),
	FUint64:     utils.PointerUint64(13),
	FSint32:     utils.PointerInt32(14),
	FSint64:     utils.PointerInt64(15),
	FSfixed32:   utils.PointerInt32(16),
	FSfixed64:   utils.PointerInt64(17),
	FFixed32:    utils.PointerUint32(18),
	FFixed64:    utils.PointerUint64(19),
	FFloat:      utils.PointerFloat32(11.11),
	FDouble:     utils.PointerFloat64(12.12),
	FBool1:      utils.PointerBool(true),
	FBytes1:     []byte("bytes1"),
	FEnum1:      pbbase.TypeOptional1_EnumNum1(2).Enum(),
	FEnum2:      pbexternal.EnumNum1(3).Enum(),
	FEnum3:      pbexternal.Embed_EnumNum1(5).Enum(),
	FEnum4:      pbexternal.Embed_Message_EnumNum1(6).Enum(),
	FEnum5:      pbbase.EnumNum1(7).Enum(),
	FEnum6:      pbbase.MessageCommon1_EnumNum1(9).Enum(),
	FDuration1:  &durationpb.Duration{Seconds: 100, Nanos: 101},
	FDuration2:  &durationpb.Duration{Seconds: 0, Nanos: 0},
	FTimestamp1: &timestamppb.Timestamp{Seconds: 200, Nanos: 201},
	FTimestamp2: &timestamppb.Timestamp{Seconds: 0, Nanos: 0},
	FAny1:       utils.MustNewAny(&pbexternal.Message1{FString1: "any11", FString2: "any12", FString3: "any13"}),
	FAny2:       utils.MustNewAny(&pbbase.MessageOptional1{FString1: "any21", FString2: "any22", FString3: "any23"}),
	FMessage1:   &pbbase.MessageOptional1{FString1: "1101", FString2: "1102", FString3: "1103"},
	FMessage2:   &pbbase.MessageOptional1_Embed1{FString1: "1201", FString2: "1202", FString3: "1203"},
	FMessage3:   &pbbase.MessageOptional1_Embed1_Embed2{FString1: "1301", FString2: "1302", FString3: "1303"},
	FMessage4:   &pbexternal.Message1{FString1: "1401", FString2: "1402", FString3: "1403"},
	FMessage5:   &pbexternal.Message1_Embed1{FString1: "1501", FString2: "1502", FString3: "1503"},
	FMessage6:   &pbexternal.Message1_Embed1_Embed2{FString1: "1601", FString2: "1602", FString3: "1603"},
	FMessage7:   &pbbase.MessageCommon1{FString1: "1701", FString2: "1702", FString3: "1703"},
	FMessage8:   &pbbase.MessageCommon1_Embed1{FString1: "1801", FString2: "1802", FString3: "1803"},
	FMessage9:   &pbbase.MessageCommon1_Embed1_Embed2{FString1: "1901", FString2: "1902", FString3: "1903"},
}

func Test_TypeOptional1_Assert_Type(t *testing.T) {
	data := &pbbase.TypeOptional1{}
	_, ok1 := interface{}(data).(json.Marshaler)
	require.True(t, ok1)
	_, ok2 := interface{}(data).(json.Unmarshaler)
	require.True(t, ok2)
}

func Test_TypeOptional1_Assert_Copy(t *testing.T) {
	dataCopy := &CopyOptional1{}
	_, ok1 := interface{}(dataCopy).(json.Marshaler)
	require.False(t, ok1)
	_, ok2 := interface{}(dataCopy).(json.Unmarshaler)
	require.False(t, ok2)
}

// Test cases for marshal/unmarshal
func Test_TypeOptional1_Basic(t *testing.T) {
	var (
		err error
		b1  []byte
	)
	t.Run("Marshal", func(t *testing.T) {
		b1, err = seedOptional1.MarshalJSON()
		require.Nil(t, err)
	})
	t.Run("Unmarshal", func(t *testing.T) {
		dataNew := &pbbase.TypeOptional1{}
		require.NotEqual(t, seedOptional1, dataNew)
		err = dataNew.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, seedOptional1, dataNew)
	})
}

// Test compatible with standard JSON with follow cases:
//   1. The json content that get by MarshalJSON that code generated by plugin can be used to standard json.Unmarshal.
//   2. The json content that get by standard json.Marshal can be used to UnmarshalJSON that code generated by plugin.
func Test_TypeOptional1_Compatible(t *testing.T) {
	var (
		err error
		b1  []byte
		b2  []byte
		b3  []byte
	)
	_ = b3

	// Get json content by MarshalJSON.
	b1, err = seedOptional1.MarshalJSON()
	require.Nil(t, err)

	dataCopy := &CopyOptional1{}
	// Test the json content is correctly.
	// and same as copy the value to dataCopy.
	err = json.Unmarshal(b1, dataCopy)
	require.Nil(t, err)

	// Get json context by json.Marshal
	b2, err = json.Marshal(dataCopy)
	require.Nil(t, err)

	// Compare the json content.
	require.Equal(t, b1, b2)

	// Test the UnmarshalJSON
	dataNew := &pbbase.TypeOptional1{}
	err = dataNew.UnmarshalJSON(b2)
	require.Nil(t, err)
	require.Equal(t, seedOptional1, dataNew)

	// proto
	b3, err = utils.PMarshal.Marshal(seedOptional1)
	require.Nil(t, err)

}

// Test cases the field is empty.
func Test_TypeOptional1_Empty(t *testing.T) {
	dataEmtpy := &pbbase.TypeOptional1{}
	dataCopy := &CopyOptional1{}

	var (
		err error
		b1  []byte
		b2  []byte
	)

	t.Run("Marshal", func(t *testing.T) {
		b1, err = dataEmtpy.MarshalJSON()
		require.Nil(t, err)
		b2, err = json.Marshal(dataCopy)
		require.Nil(t, err)
	})

	t.Run("UnmarshalPlugin", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &pbbase.TypeOptional1{}
		err = data1.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data1)

		// use content that get by json.Marshal
		data2 := &pbbase.TypeOptional1{}
		err = data2.UnmarshalJSON(b2)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data2)
	})
	t.Run("UnmarshalStandard", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &CopyOptional1{}
		err = json.Unmarshal(b1, data1)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data1)

		// use content that get by json.Marshal
		data2 := &CopyOptional1{}
		err = json.Unmarshal(b2, data2)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data2)
	})
}

func Test_TypeOptional1_NULL(t *testing.T) {
	data1 := &pbbase.TypeOptional1{}
	data2 := &CopyOptional1{}

	var err error
	err = data1.UnmarshalJSON([]byte("null"))
	require.Nil(t, err)

	err = json.Unmarshal([]byte("null"), data2)
	require.Nil(t, err)
}
