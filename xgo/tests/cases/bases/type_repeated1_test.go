package bases

import (
	"encoding/json"
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"

	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbbases"

	"github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	"github.com/yu31/protoc-plugin-json/xgo/tests/utils"
)

type CopyRepeated1 pbbases.TypeRepeated1

var seedRepeated1 = &pbbases.TypeRepeated1{
	FString1:  []string{"r11", "r12", "r13"},
	FString2:  []string{"", "", ""},
	FInt32:    []int32{101, 102, 103},
	FInt64:    []int64{111, 112, 113},
	FUint32:   []uint32{121, 122, 123},
	FUint64:   []uint64{131, 132, 133},
	FSint32:   []int32{141, 142, 143},
	FSint64:   []int64{151, 152, 153},
	FSfixed32: []int32{161, 162, 163},
	FSfixed64: []int64{171, 172, 173},
	FFixed32:  []uint32{181, 182, 183},
	FFixed64:  []uint64{191, 192, 193},
	FFloat:    []float32{11.11, 11.12, 11.13},
	FDouble:   []float64{22.21, 22.22, 22.23},
	FBool1:    []bool{true, false, true},
	FBytes1:   [][]byte{[]byte("bytes1"), []byte("bytes2"), []byte("bytes3")},
	FEnum1:    []pbbases.EnumRepeated1{2, 3, 5},
	FEnum2:    []pbexternal.Enum1{6, 7, 9},
	FEnum3:    []pbexternal.Embed_Enum1{2, 3, 5},
	FEnum4:    []pbexternal.Embed_Message_Enum1{6, 7, 9},
	FEnum5:    []pbbases.EnumCommon1{2, 3, 5},
	FEnum6:    []pbbases.MessageCommon1_Enum1{6, 7, 9},
	FDuration1: []*durationpb.Duration{
		{Seconds: 101, Nanos: 102},
		{Seconds: 103, Nanos: 104},
		{Seconds: 105, Nanos: 106},
	},
	FDuration2: []*durationpb.Duration{
		{Seconds: 301, Nanos: 302},
	},
	FTimestamp1: []*timestamppb.Timestamp{
		{Seconds: 201, Nanos: 202},
		{Seconds: 203, Nanos: 204},
		{Seconds: 205, Nanos: 206},
	},
	FTimestamp2: []*timestamppb.Timestamp{
		{Seconds: 401, Nanos: 402},
	},
	FAny1: []*anypb.Any{
		utils.MustNewAny(&pbexternal.Message1{FString1: "any11", FString2: "any12", FString3: "any13"}),
		utils.MustNewAny(&pbbases.MessageRepeated1{FString1: "any21", FString2: "any22", FString3: "any23"}),
	},
	FAny2: []*anypb.Any{
		utils.MustNewAny(&pbbases.MessageCommon1{FString1: "any11", FString2: "any12", FString3: "any13"}),
	},
	FMessage1: []*pbbases.MessageRepeated1{
		{FString1: "1101", FString2: "1102", FString3: "1103"},
		{FString1: "1111", FString2: "1112", FString3: "1113"},
	},
	FMessage2: []*pbbases.MessageRepeated1_Embed1{
		{FString1: "1201", FString2: "1202", FString3: "1203"},
		{FString1: "1211", FString2: "1212", FString3: "1213"},
	},
	FMessage3: []*pbbases.MessageRepeated1_Embed1_Embed2{
		{FString1: "1301", FString2: "1302", FString3: "1303"},
		{FString1: "1311", FString2: "1312", FString3: "1313"},
	},
	FMessage4: []*pbexternal.Message1{
		{FString1: "1401", FString2: "1402", FString3: "1403"},
		{FString1: "1411", FString2: "1412", FString3: "1413"},
	},
	FMessage5: []*pbexternal.Message1_Embed1{
		{FString1: "1501", FString2: "1502", FString3: "1503"},
		{FString1: "1511", FString2: "1512", FString3: "1513"},
	},
	FMessage6: []*pbexternal.Message1_Embed1_Embed2{
		{FString1: "1601", FString2: "1602", FString3: "1603"},
		{FString1: "1611", FString2: "1612", FString3: "1613"},
	},
	FMessage7: []*pbbases.MessageCommon1{
		{FString1: "1701", FString2: "1702", FString3: "1703"},
		{FString1: "1711", FString2: "1712", FString3: "1713"},
	},
	FMessage8: []*pbbases.MessageCommon1_Embed1{
		{FString1: "1801", FString2: "1802", FString3: "1803"},
		{FString1: "1811", FString2: "1812", FString3: "1813"},
	},
	FMessage9: []*pbbases.MessageCommon1_Embed1_Embed2{
		{FString1: "1901", FString2: "1902", FString3: "1903"},
		{FString1: "1911", FString2: "1912", FString3: "1913"},
	},
}

func Test_TypeRepeated1_Assert_Type(t *testing.T) {
	data := &pbbases.TypeRepeated1{}
	_, ok1 := interface{}(data).(json.Marshaler)
	require.True(t, ok1)
	_, ok2 := interface{}(data).(json.Unmarshaler)
	require.True(t, ok2)
}

func Test_TypeRepeated1_Assert_Copy(t *testing.T) {
	dataCopy := &CopyRepeated1{}
	_, ok1 := interface{}(dataCopy).(json.Marshaler)
	require.False(t, ok1)
	_, ok2 := interface{}(dataCopy).(json.Unmarshaler)
	require.False(t, ok2)
}

func Test_TypeRepeated1_General1(t *testing.T) {
	var (
		err error
		b1  []byte
	)
	t.Run("marshal", func(t *testing.T) {
		b1, err = seedRepeated1.MarshalJSON()
		require.Nil(t, err)
	})
	t.Run("unmarshal", func(t *testing.T) {
		dataNew := &pbbases.TypeRepeated1{}
		require.NotEqual(t, seedRepeated1, dataNew)
		err = dataNew.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, seedRepeated1, dataNew)
	})
}

// Test compatible with standard JSON with follow cases:
//   1. The json content that get by MarshalJSON that code generated by plugin can be used to standard json.Unmarshal.
//   2. The json content that get by standard json.Marshal can be used to UnmarshalJSON that code generated by plugin.
func Test_TypeRepeated1_Compatible(t *testing.T) {
	var (
		err error
		b1  []byte
		b2  []byte
		b3  []byte
	)
	_ = b3

	// Get json content by MarshalJSON.
	b1, err = seedRepeated1.MarshalJSON()
	require.Nil(t, err)

	dataCopy := &CopyRepeated1{}
	// Test the json content is correctly.
	// and same as copy the value to dataCopy.
	err = json.Unmarshal(b1, dataCopy)
	require.Nil(t, err)

	// Get json context by json.Marshal
	b2, err = json.Marshal(dataCopy)
	require.Nil(t, err)

	// Compare the json content.
	require.Equal(t, b1, b2)

	// Test the UnmarshalJSON
	dataNew := &pbbases.TypeRepeated1{}
	err = dataNew.UnmarshalJSON(b2)
	require.Nil(t, err)
	require.Equal(t, seedRepeated1, dataNew)

	// proto
	b3, err = utils.PMarshal.Marshal(seedRepeated1)
	require.Nil(t, err)

	fmt.Println("=========================================== PLUGIN =============================================")
	fmt.Println(string(b1))
	fmt.Println("=========================================== STANDARD ===========================================")
	fmt.Println(string(b2))
	fmt.Println("=========================================== PROTO ==============================================")
	fmt.Println(string(b3))
	fmt.Println("================================================================================================")
}

// Test cases the field is empty.
func Test_TypeRepeated1_Empty(t *testing.T) {
	dataEmtpy := &pbbases.TypeRepeated1{}
	dataCopy := &CopyRepeated1{}

	var (
		err error
		b1  []byte
		b2  []byte
	)

	t.Run("marshal", func(t *testing.T) {
		b1, err = dataEmtpy.MarshalJSON()
		require.Nil(t, err)
		b2, err = json.Marshal(dataCopy)
		require.Nil(t, err)
	})
	t.Run("unmarshal-plugin", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &pbbases.TypeRepeated1{}
		err = data1.UnmarshalJSON(b1)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data1)

		// use content that get by json.Marshal
		data2 := &pbbases.TypeRepeated1{}
		err = data2.UnmarshalJSON(b2)
		require.Nil(t, err)
		require.Equal(t, dataEmtpy, data2)
	})
	t.Run("unmarshal-standard", func(t *testing.T) {
		// use content that get by MarshalJSON
		data1 := &CopyRepeated1{}
		err = json.Unmarshal(b1, data1)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data1)

		// use content that get by json.Marshal
		data2 := &CopyRepeated1{}
		err = json.Unmarshal(b2, data2)
		require.Nil(t, err)
		require.Equal(t, dataCopy, data2)
	})
}

func Test_TypeRepeated1_NULL(t *testing.T) {
	data1 := &pbbases.TypeRepeated1{}
	data2 := &CopyRepeated1{}

	var err error
	err = data1.UnmarshalJSON([]byte("null"))
	require.Nil(t, err)

	err = json.Unmarshal([]byte("null"), data2)
	require.Nil(t, err)
}
