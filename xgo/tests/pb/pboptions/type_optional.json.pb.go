// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/options/type_optional.proto

package pboptions

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message TypeOptional1 in file tests/proto/cases/options/type_optional.proto
func (x *TypeOptional1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(424)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	if x.FInt32 != nil {
		encoder.AppendObjectKey("t_int32")
		encoder.AppendPointerInt32(x.FInt32, false)
	}
	if x.FInt64 != nil {
		encoder.AppendObjectKey("t_int64")
		encoder.AppendPointerInt64(x.FInt64, false)
	}
	if x.FUint32 != nil {
		encoder.AppendObjectKey("t_uint32")
		encoder.AppendPointerUint32(x.FUint32, false)
	}
	if x.FUint64 != nil {
		encoder.AppendObjectKey("t_uint64")
		encoder.AppendPointerUint64(x.FUint64, false)
	}
	if x.FSint32 != nil {
		encoder.AppendObjectKey("t_sint32")
		encoder.AppendPointerInt32(x.FSint32, false)
	}
	if x.FSint64 != nil {
		encoder.AppendObjectKey("t_sint64")
		encoder.AppendPointerInt64(x.FSint64, false)
	}
	if x.FSfixed32 != nil {
		encoder.AppendObjectKey("t_sfixed32")
		encoder.AppendPointerInt32(x.FSfixed32, false)
	}
	if x.FSfixed64 != nil {
		encoder.AppendObjectKey("t_sfixed64")
		encoder.AppendPointerInt64(x.FSfixed64, false)
	}
	if x.FFixed32 != nil {
		encoder.AppendObjectKey("t_fixed32")
		encoder.AppendPointerUint32(x.FFixed32, false)
	}
	if x.FFixed64 != nil {
		encoder.AppendObjectKey("t_fixed64")
		encoder.AppendPointerUint64(x.FFixed64, false)
	}
	if x.FFloat != nil {
		encoder.AppendObjectKey("t_float")
		encoder.AppendPointerFloat32(x.FFloat, false)
	}
	if x.FDouble != nil {
		encoder.AppendObjectKey("t_double")
		encoder.AppendPointerFloat64(x.FDouble, false)
	}
	if x.FBool1 != nil {
		encoder.AppendObjectKey("t_bool1")
		encoder.AppendPointerBool(x.FBool1, false)
	}
	if x.FString1 != nil {
		encoder.AppendObjectKey("t_string1")
		encoder.AppendPointerString(x.FString1)
	}
	if len(x.FBytes1) != 0 {
		encoder.AppendObjectKey("t_bytes1")
		encoder.AppendLiteralBytes(x.FBytes1)
	}
	if x.FEnum1 != nil {
		encoder.AppendObjectKey("t_enum1")
		if x.FEnum1 != nil {
			encoder.AppendLiteralInt32(int32(x.FEnum1.Number()), false)
		} else {
			encoder.AppendLiteralNULL()
		}
	}
	if x.FMessage1 != nil {
		encoder.AppendObjectKey("t_message1")
		if err = encoder.AppendLiteralInterface(x.FMessage1); err != nil {
			return nil, err
		}
	}
	if x.FAny1 != nil {
		encoder.AppendObjectKey("t_any1")
		if err = encoder.AppendLiteralInterface(x.FAny1); err != nil {
			return nil, err
		}
	}
	if x.FDuration1 != nil {
		encoder.AppendObjectKey("t_duration1")
		if err = encoder.AppendLiteralInterface(x.FDuration1); err != nil {
			return nil, err
		}
	}
	if x.FTimestamp1 != nil {
		encoder.AppendObjectKey("t_timestamp1")
		if err = encoder.AppendLiteralInterface(x.FTimestamp1); err != nil {
			return nil, err
		}
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOptional1 in file tests/proto/cases/options/type_optional.proto
func (x *TypeOptional1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pboptions.(*TypeOptional1) is nil")
	}
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "t_int32":
			var vv *int32
			if vv, err = decoder.ReadPointerInt32(jsonKey, false); err != nil {
				return err
			}
			x.FInt32 = vv
		case "t_int64":
			var vv *int64
			if vv, err = decoder.ReadPointerInt64(jsonKey, false); err != nil {
				return err
			}
			x.FInt64 = vv
		case "t_uint32":
			var vv *uint32
			if vv, err = decoder.ReadPointerUint32(jsonKey, false); err != nil {
				return err
			}
			x.FUint32 = vv
		case "t_uint64":
			var vv *uint64
			if vv, err = decoder.ReadPointerUint64(jsonKey, false); err != nil {
				return err
			}
			x.FUint64 = vv
		case "t_sint32":
			var vv *int32
			if vv, err = decoder.ReadPointerInt32(jsonKey, false); err != nil {
				return err
			}
			x.FSint32 = vv
		case "t_sint64":
			var vv *int64
			if vv, err = decoder.ReadPointerInt64(jsonKey, false); err != nil {
				return err
			}
			x.FSint64 = vv
		case "t_sfixed32":
			var vv *int32
			if vv, err = decoder.ReadPointerInt32(jsonKey, false); err != nil {
				return err
			}
			x.FSfixed32 = vv
		case "t_sfixed64":
			var vv *int64
			if vv, err = decoder.ReadPointerInt64(jsonKey, false); err != nil {
				return err
			}
			x.FSfixed64 = vv
		case "t_fixed32":
			var vv *uint32
			if vv, err = decoder.ReadPointerUint32(jsonKey, false); err != nil {
				return err
			}
			x.FFixed32 = vv
		case "t_fixed64":
			var vv *uint64
			if vv, err = decoder.ReadPointerUint64(jsonKey, false); err != nil {
				return err
			}
			x.FFixed64 = vv
		case "t_float":
			var vv *float32
			if vv, err = decoder.ReadPointerFloat32(jsonKey, false); err != nil {
				return err
			}
			x.FFloat = vv
		case "t_double":
			var vv *float64
			if vv, err = decoder.ReadPointerFloat64(jsonKey, false); err != nil {
				return err
			}
			x.FDouble = vv
		case "t_bool1":
			var vv *bool
			if vv, err = decoder.ReadPointerBool(jsonKey, false); err != nil {
				return err
			}
			x.FBool1 = vv
		case "t_string1":
			var vv *string
			if vv, err = decoder.ReadPointerString(jsonKey); err != nil {
				return err
			}
			x.FString1 = vv
		case "t_bytes1":
			var vv []byte
			if vv, err = decoder.ReadLiteralBytes(jsonKey); err != nil {
				return err
			}
			x.FBytes1 = vv
		case "t_enum1":
			var vv *pbexternal.Enum1
			var v1 *int32
			if v1, err = decoder.ReadPointerEnumNumber(jsonKey, false); err != nil {
				return err
			}
			if v1 != nil {
				v2 := pbexternal.Enum1(*v1)
				vv = &v2
			}
			x.FEnum1 = vv
		case "t_message1":
			var vv *pbexternal.Message1
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.FMessage1 != nil {
					vv = x.FMessage1
				} else {
					vv = new(pbexternal.Message1)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.FMessage1 = vv
		case "t_any1":
			var vv *anypb.Any
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.FAny1 != nil {
					vv = x.FAny1
				} else {
					vv = new(anypb.Any)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.FAny1 = vv
		case "t_duration1":
			var vv *durationpb.Duration
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.FDuration1 != nil {
					vv = x.FDuration1
				} else {
					vv = new(durationpb.Duration)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.FDuration1 = vv
		case "t_timestamp1":
			var vv *timestamppb.Timestamp
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.FTimestamp1 != nil {
					vv = x.FTimestamp1
				} else {
					vv = new(timestamppb.Timestamp)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.FTimestamp1 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
