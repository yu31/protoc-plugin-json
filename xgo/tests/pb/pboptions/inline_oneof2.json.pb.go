// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/options/inline_oneof2.proto

package pboptions

import (
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message InlineOneOf2Message3 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message3) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(72)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendValStr(enc, "t_string3", x.FString1, false)
	switch o1_2 := x.OneType01.(type) {
	case *InlineOneOf2Message3_FDouble:
		jsonencoder.AppendValF64(enc, "t_double", o1_2.FDouble, false, false)
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message InlineOneOf2Message3 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message3) UnmarshalJSON(b []byte) error {
	if x == nil {
		return jsondecoder.ErrStructIsNIL("xgo/tests/pb/pboptions", "InlineOneOf2Message3")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_2 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "t_string3":
			if x.FString1, err = jsondecoder.ReadValStr(dec); err != nil {
				return err
			}
		case "t_double":
			if isLoad_o1_2 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_2 = true
			o1_2, ok := x.OneType01.(*InlineOneOf2Message3_FDouble)
			if !ok {
				o1_2 = new(InlineOneOf2Message3_FDouble)
				x.OneType01 = o1_2
			}
			if o1_2.FDouble, err = jsondecoder.ReadValF64(dec, false); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message InlineOneOf2Message2 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(128)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendValStr(enc, "t_string2", x.FString1, false)
	switch o1_2 := x.OneType01.(type) {
	case *InlineOneOf2Message2_FMessage1:
		if err := jsonencoder.AppendValMessage(enc, "t_message2", o1_2.FMessage1, false); err != nil {
			return nil, err
		}
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message InlineOneOf2Message2 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return jsondecoder.ErrStructIsNIL("xgo/tests/pb/pboptions", "InlineOneOf2Message2")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_2 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "t_string2":
			if x.FString1, err = jsondecoder.ReadValStr(dec); err != nil {
				return err
			}
		case "t_message2":
			if isLoad_o1_2 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_2 = true
			o1_2, ok := x.OneType01.(*InlineOneOf2Message2_FMessage1)
			if !ok {
				o1_2 = new(InlineOneOf2Message2_FMessage1)
				x.OneType01 = o1_2
			}
			if o1_2.FMessage1, err = jsondecoder.ReadValMessage(dec, o1_2.FMessage1); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message InlineOneOf2Message1 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(128)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendValStr(enc, "t_string1", x.FString1, false)
	switch o1_2 := x.OneType01.(type) {
	case *InlineOneOf2Message1_FMessage1:
		if err := jsonencoder.AppendValMessage(enc, "t_message1", o1_2.FMessage1, false); err != nil {
			return nil, err
		}
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message InlineOneOf2Message1 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2Message1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return jsondecoder.ErrStructIsNIL("xgo/tests/pb/pboptions", "InlineOneOf2Message1")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_2 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "t_string1":
			if x.FString1, err = jsondecoder.ReadValStr(dec); err != nil {
				return err
			}
		case "t_message1":
			if isLoad_o1_2 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_2 = true
			o1_2, ok := x.OneType01.(*InlineOneOf2Message1_FMessage1)
			if !ok {
				o1_2 = new(InlineOneOf2Message1_FMessage1)
				x.OneType01 = o1_2
			}
			if o1_2.FMessage1, err = jsondecoder.ReadValMessage(dec, o1_2.FMessage1); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message InlineOneOf2 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(128)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendValStr(enc, "t_string0", x.FString1, false)
	switch o1_2 := x.OneType01.(type) {
	case *InlineOneOf2_FMessage1:
		if err := jsonencoder.AppendValMessage(enc, "t_message0", o1_2.FMessage1, false); err != nil {
			return nil, err
		}
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message InlineOneOf2 in file tests/proto/cases/options/inline_oneof2.proto
func (x *InlineOneOf2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return jsondecoder.ErrStructIsNIL("xgo/tests/pb/pboptions", "InlineOneOf2")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_2 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "t_string0":
			if x.FString1, err = jsondecoder.ReadValStr(dec); err != nil {
				return err
			}
		case "t_message0":
			if isLoad_o1_2 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_2 = true
			o1_2, ok := x.OneType01.(*InlineOneOf2_FMessage1)
			if !ok {
				o1_2 = new(InlineOneOf2_FMessage1)
				x.OneType01 = o1_2
			}
			if o1_2.FMessage1, err = jsondecoder.ReadValMessage(dec, o1_2.FMessage1); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
