// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/boundary/boundary1.proto

package pbboundary

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message RepeatedElem1 in file tests/proto/cases/boundary/boundary1.proto
func (x *RepeatedElem1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(24)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("r_string1")
	if x.RString1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString1 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message RepeatedElem1 in file tests/proto/cases/boundary/boundary1.proto
func (x *RepeatedElem1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*RepeatedElem1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.CheckJSONBegin(); err != nil || isNULL {
		return err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "r_string1":
			var isEmpty bool
			if isNULL, isEmpty, err = decoder.CheckBeforeReadArray(jsonKey); err != nil {
				return err
			}
			switch {
			case isNULL:
				x.RString1 = nil
			case isEmpty:
				if x.RString1 == nil {
					x.RString1 = make([]string, 0)
				} else {
					x.RString1 = x.RString1[:0]
				}
			default:
				if x.RString1 == nil {
					x.RString1 = make([]string, 0)
				}
				i := 0
				length := len(x.RString1)
			LOOP_LIST_r_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString1[i] = vv
					} else {
						x.RString1 = append(x.RString1, vv)
					}
					i++
					if decoder.ReadArrayElemAfter() { // After read array value.
						break LOOP_LIST_r_string1
					}
				}
				if i < length {
					// truncate the slice to Consistent with standard library json.
					x.RString1 = x.RString1[:i]
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message MapKV1 in file tests/proto/cases/boundary/boundary1.proto
func (x *MapKV1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(24)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("m_string1")
	if x.MString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MapKV1 in file tests/proto/cases/boundary/boundary1.proto
func (x *MapKV1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*MapKV1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.CheckJSONBegin(); err != nil || isNULL {
		return err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "m_string1":
			var isEmpty bool
			if isNULL, isEmpty, err = decoder.CheckBeforeReadMap(jsonKey); err != nil {
				return err
			}
			switch {
			case isNULL:
				x.MString1 = nil
			case isEmpty:
				// do nothing
			default:
				if x.MString1 == nil {
					x.MString1 = make(map[string]string)
				}
			LOOP_MAP_m_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString1[mapKey] = vv
					if decoder.ReadMapValueAfter() { // After read map value
						break LOOP_MAP_m_string1
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
