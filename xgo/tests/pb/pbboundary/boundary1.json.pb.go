// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/boundary/boundary1.proto

package pbboundary

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message Message1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Message1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string1")
	encoder.AppendLiteralString(x.FString1)
	encoder.AppendObjectKey("f_string2")
	encoder.AppendLiteralString(x.FString2)
	encoder.AppendObjectKey("f_string3")
	encoder.AppendLiteralString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Message1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Message1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Message1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Repeated1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Repeated1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(24)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("r_string1")
	if x.RString1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString1 {
			encoder.AppendLiteralString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Repeated1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Repeated1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Repeated1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "r_string1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString1 = nil
				continue LOOP_SCAN
			}
			if x.RString1 == nil {
				x.RString1 = make([]string, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				if i >= len(x.RString1) {
					x.RString1 = append(x.RString1, vv)
				}
				if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
					return err
				}
				x.RString1[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RString1 = x.RString1[:i]
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Map1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Map1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(24)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("m_string1")
	if x.MString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Map1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Map1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Map1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "m_string1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString1 = nil
				continue LOOP_SCAN
			}
			if x.MString1 == nil {
				x.MString1 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv string
				if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
					return err
				}
				x.MString1[mk] = vv
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Complex1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(100)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_int32")
	encoder.AppendLiteralInt32(x.FInt32)
	encoder.AppendObjectKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendLiteralInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_message1")
	if err = encoder.AppendLiteralInterface(x.FMessage1); err != nil {
		return nil, err
	}
	encoder.AppendObjectKey("m_int32")
	if x.MInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64")
	encoder.AppendPointerInt64(x.FInt64)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Complex1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Complex1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32":
			var vv int32
			if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
				return err
			}
			x.FInt32 = vv
		case "r_int64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt64 = nil
				continue LOOP_SCAN
			}
			if x.RInt64 == nil {
				x.RInt64 = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.RInt64) {
					x.RInt64 = append(x.RInt64, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
					return err
				}
				x.RInt64[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RInt64 = x.RInt64[:i]
		case "f_message1":
			var vv *Message1
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.FMessage1 != nil {
					vv = x.FMessage1
				} else {
					vv = new(Message1)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.FMessage1 = vv
		case "m_int32":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MInt32 = nil
				continue LOOP_SCAN
			}
			if x.MInt32 == nil {
				x.MInt32 = make(map[string]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
					return err
				}
				x.MInt32[mk] = vv
			}
		case "f_int64":
			var vv *int64
			if vv, err = decoder.ReadPointerInt64(jsonKey); err != nil {
				return err
			}
			x.FInt64 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Complex2 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(96)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string")
	encoder.AppendLiteralString(x.FString)
	encoder.AppendObjectKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendLiteralInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("level1")
	if err = encoder.AppendLiteralInterface(x.Level1); err != nil {
		return nil, err
	}
	encoder.AppendObjectKey("r_level1")
	if x.RLevel1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RLevel1 {
			if err = encoder.AppendLiteralInterface(ri); err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("r_level2")
	if x.RLevel2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RLevel2 {
			if err = encoder.AppendLiteralInterface(ri); err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Complex2 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Complex2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString = vv
		case "r_int64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt64 = nil
				continue LOOP_SCAN
			}
			if x.RInt64 == nil {
				x.RInt64 = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.RInt64) {
					x.RInt64 = append(x.RInt64, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
					return err
				}
				x.RInt64[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RInt64 = x.RInt64[:i]
		case "level1":
			var vv *Complex2_Level1
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.Level1 != nil {
					vv = x.Level1
				} else {
					vv = new(Complex2_Level1)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.Level1 = vv
		case "r_level1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RLevel1 = nil
				continue LOOP_SCAN
			}
			if x.RLevel1 == nil {
				x.RLevel1 = make([]*Complex2_Level1, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Complex2_Level1
				if i >= len(x.RLevel1) {
					x.RLevel1 = append(x.RLevel1, vv)
				}
				if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
					return err
				}
				if !isNULL {
					if x.RLevel1[i] != nil {
						vv = x.RLevel1[i]
					} else {
						vv = new(Complex2_Level1)
					}
					if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
						return err
					}
				}
				x.RLevel1[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RLevel1 = x.RLevel1[:i]
		case "r_level2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RLevel2 = nil
				continue LOOP_SCAN
			}
			if x.RLevel2 == nil {
				x.RLevel2 = make([]*Complex2_Level1, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Complex2_Level1
				if i >= len(x.RLevel2) {
					x.RLevel2 = append(x.RLevel2, vv)
				}
				if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
					return err
				}
				if !isNULL {
					if x.RLevel2[i] != nil {
						vv = x.RLevel2[i]
					} else {
						vv = new(Complex2_Level1)
					}
					if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
						return err
					}
				}
				x.RLevel2[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RLevel2 = x.RLevel2[:i]
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Level1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(58)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("level2")
	if err = encoder.AppendLiteralInterface(x.Level2); err != nil {
		return nil, err
	}
	encoder.AppendObjectKey("f_string")
	encoder.AppendLiteralString(x.FString)
	encoder.AppendObjectKey("r_string")
	if x.RString != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString {
			encoder.AppendLiteralString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Level1 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Complex2_Level1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "level2":
			var vv *Complex2_Level2
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.Level2 != nil {
					vv = x.Level2
				} else {
					vv = new(Complex2_Level2)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.Level2 = vv
		case "f_string":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString = vv
		case "r_string":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString = nil
				continue LOOP_SCAN
			}
			if x.RString == nil {
				x.RString = make([]string, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				if i >= len(x.RString) {
					x.RString = append(x.RString, vv)
				}
				if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
					return err
				}
				x.RString[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RString = x.RString[:i]
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Level2 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(56)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string")
	encoder.AppendLiteralString(x.FString)
	encoder.AppendObjectKey("level3")
	if err = encoder.AppendLiteralInterface(x.Level3); err != nil {
		return nil, err
	}
	encoder.AppendObjectKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendLiteralInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Level2 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Complex2_Level2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString = vv
		case "level3":
			var vv *Complex2_Level3
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if x.Level3 != nil {
					vv = x.Level3
				} else {
					vv = new(Complex2_Level3)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			x.Level3 = vv
		case "r_int64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt64 = nil
				continue LOOP_SCAN
			}
			if x.RInt64 == nil {
				x.RInt64 = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.RInt64) {
					x.RInt64 = append(x.RInt64, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
					return err
				}
				x.RInt64[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RInt64 = x.RInt64[:i]
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Level3 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level3) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(76)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_int32")
	encoder.AppendLiteralInt32(x.FInt32)
	encoder.AppendObjectKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendLiteralInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("m_int32")
	if x.MInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("p_int64")
	encoder.AppendPointerInt64(x.PInt64)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Level3 in file tests/proto/cases/boundary/boundary1.proto
func (x *Complex2_Level3) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbboundary.(*Complex2_Level3) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32":
			var vv int32
			if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
				return err
			}
			x.FInt32 = vv
		case "r_int64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt64 = nil
				continue LOOP_SCAN
			}
			if x.RInt64 == nil {
				x.RInt64 = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.RInt64) {
					x.RInt64 = append(x.RInt64, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
					return err
				}
				x.RInt64[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.RInt64 = x.RInt64[:i]
		case "m_int32":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MInt32 = nil
				continue LOOP_SCAN
			}
			if x.MInt32 == nil {
				x.MInt32 = make(map[string]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
					return err
				}
				x.MInt32[mk] = vv
			}
		case "p_int64":
			var vv *int64
			if vv, err = decoder.ReadPointerInt64(jsonKey); err != nil {
				return err
			}
			x.PInt64 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
