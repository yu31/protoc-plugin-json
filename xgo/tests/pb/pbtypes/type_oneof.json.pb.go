// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/types/type_oneof.proto

package pbtypes

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message MessageOneOf1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string1")
	encoder.AppendLiteralString(x.FString1)
	encoder.AppendObjectKey("f_string2")
	encoder.AppendLiteralString(x.FString2)
	encoder.AppendObjectKey("f_string3")
	encoder.AppendLiteralString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MessageOneOf1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneOf1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1_Embed1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string1")
	encoder.AppendLiteralString(x.FString1)
	encoder.AppendObjectKey("f_string2")
	encoder.AppendLiteralString(x.FString2)
	encoder.AppendObjectKey("f_string3")
	encoder.AppendLiteralString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1_Embed1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneOf1_Embed1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1_Embed1_Embed2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string1")
	encoder.AppendLiteralString(x.FString1)
	encoder.AppendObjectKey("f_string2")
	encoder.AppendLiteralString(x.FString2)
	encoder.AppendObjectKey("f_string3")
	encoder.AppendLiteralString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneOf1_Embed1_Embed2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneOf1_Embed1_Embed2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneOf1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneOf1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(296)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneOf1_FString1:
		encoder.AppendObjectKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_string1")
		encoder.AppendLiteralString(ov.FString1)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FString2:
		encoder.AppendObjectKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_string2")
		encoder.AppendLiteralString(ov.FString2)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType01")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type02.(type) {
	case *TypeOneOf1_FInt32:
		encoder.AppendObjectKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_int32")
		encoder.AppendLiteralInt32(ov.FInt32)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FInt64:
		encoder.AppendObjectKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_int64")
		encoder.AppendLiteralInt64(ov.FInt64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("One_Type02")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneOf1_FUint32:
		encoder.AppendObjectKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_uint32")
		encoder.AppendLiteralUint32(ov.FUint32)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FUint64:
		encoder.AppendObjectKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_uint64")
		encoder.AppendLiteralUint64(ov.FUint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("One_type03")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type04.(type) {
	case *TypeOneOf1_FSint32:
		encoder.AppendObjectKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_sint32")
		encoder.AppendLiteralInt32(ov.FSint32)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FSint64:
		encoder.AppendObjectKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_sint64")
		encoder.AppendLiteralInt64(ov.FSint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_Type04")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType05.(type) {
	case *TypeOneOf1_FSfixed32:
		encoder.AppendObjectKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_sfixed32")
		encoder.AppendLiteralInt32(ov.FSfixed32)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FSfixed64:
		encoder.AppendObjectKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_sfixed64")
		encoder.AppendLiteralInt64(ov.FSfixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_type05")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType06.(type) {
	case *TypeOneOf1_FFixed32:
		encoder.AppendObjectKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_fixed32")
		encoder.AppendLiteralUint32(ov.FFixed32)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FFixed64:
		encoder.AppendObjectKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_fixed64")
		encoder.AppendLiteralUint64(ov.FFixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("oneType06")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype07.(type) {
	case *TypeOneOf1_FFloat:
		encoder.AppendObjectKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_float")
		encoder.AppendLiteralFloat32(ov.FFloat)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FDouble:
		encoder.AppendObjectKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_double")
		encoder.AppendLiteralFloat64(ov.FDouble)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("Onetype07")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype08.(type) {
	case *TypeOneOf1_FBool1:
		encoder.AppendObjectKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_bool1")
		encoder.AppendLiteralBool(ov.FBool1)
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FBytes1:
		encoder.AppendObjectKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_bytes1")
		encoder.AppendLiteralBytes(ov.FBytes1)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("onetype08")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType09.(type) {
	case *TypeOneOf1_FEnum1:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum1")
		encoder.AppendLiteralInt32(int32(ov.FEnum1.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FEnum2:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum2")
		encoder.AppendLiteralInt32(int32(ov.FEnum2.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FEnum3:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum3")
		encoder.AppendLiteralInt32(int32(ov.FEnum3.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FEnum4:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum4")
		encoder.AppendLiteralInt32(int32(ov.FEnum4.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FEnum5:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum5")
		encoder.AppendLiteralInt32(int32(ov.FEnum5.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FEnum6:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum6")
		encoder.AppendLiteralInt32(int32(ov.FEnum6.Number()))
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType09")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType10.(type) {
	case *TypeOneOf1_FDuration1:
		encoder.AppendObjectKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration1")
		if err = encoder.AppendLiteralInterface(ov.FDuration1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FDuration2:
		encoder.AppendObjectKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration2")
		if err = encoder.AppendLiteralInterface(ov.FDuration2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType10")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType11.(type) {
	case *TypeOneOf1_FTimestamp1:
		encoder.AppendObjectKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp1")
		if err = encoder.AppendLiteralInterface(ov.FTimestamp1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FTimestamp2:
		encoder.AppendObjectKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp2")
		if err = encoder.AppendLiteralInterface(ov.FTimestamp2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType11")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType12.(type) {
	case *TypeOneOf1_FAny1:
		encoder.AppendObjectKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_any1")
		if err = encoder.AppendLiteralInterface(ov.FAny1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FAny2:
		encoder.AppendObjectKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_any2")
		if err = encoder.AppendLiteralInterface(ov.FAny2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType12")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType13.(type) {
	case *TypeOneOf1_FMessage1:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message1")
		if err = encoder.AppendLiteralInterface(ov.FMessage1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage2:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message2")
		if err = encoder.AppendLiteralInterface(ov.FMessage2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage3:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message3")
		if err = encoder.AppendLiteralInterface(ov.FMessage3); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage4:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message4")
		if err = encoder.AppendLiteralInterface(ov.FMessage4); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage5:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message5")
		if err = encoder.AppendLiteralInterface(ov.FMessage5); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage6:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message6")
		if err = encoder.AppendLiteralInterface(ov.FMessage6); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage7:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message7")
		if err = encoder.AppendLiteralInterface(ov.FMessage7); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage8:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message8")
		if err = encoder.AppendLiteralInterface(ov.FMessage8); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOf1_FMessage9:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_message9")
		if err = encoder.AppendLiteralInterface(ov.FMessage9); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType13")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneOf1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneOf1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneOf1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_One_Type02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_One_Type04 bool
	var oneOfIsFill_OneType05 bool
	var oneOfIsFill_OneType06 bool
	var oneOfIsFill_Onetype07 bool
	var oneOfIsFill_Onetype08 bool
	var oneOfIsFill_OneType09 bool
	var oneOfIsFill_OneType10 bool
	var oneOfIsFill_OneType11 bool
	var oneOfIsFill_OneType12 bool
	var oneOfIsFill_OneType13 bool

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "OneType01":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType01 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_string1":
					if oneOfIsFill_OneType01 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType01 = true

					var ok bool
					var ot *TypeOneOf1_FString1
					if ot, ok = x.OneType01.(*TypeOneOf1_FString1); !ok {
						ot = new(TypeOneOf1_FString1)
					}
					var vv string
					if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
						return err
					}
					ot.FString1 = vv
					x.OneType01 = ot
				case "f_string2":
					if oneOfIsFill_OneType01 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType01 = true

					var ok bool
					var ot *TypeOneOf1_FString2
					if ot, ok = x.OneType01.(*TypeOneOf1_FString2); !ok {
						ot = new(TypeOneOf1_FString2)
					}
					var vv string
					if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
						return err
					}
					ot.FString2 = vv
					x.OneType01 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "One_Type02":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.One_Type02 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_int32":
					if oneOfIsFill_One_Type02 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type02 = true

					var ok bool
					var ot *TypeOneOf1_FInt32
					if ot, ok = x.One_Type02.(*TypeOneOf1_FInt32); !ok {
						ot = new(TypeOneOf1_FInt32)
					}
					var vv int32
					if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
						return err
					}
					ot.FInt32 = vv
					x.One_Type02 = ot
				case "f_int64":
					if oneOfIsFill_One_Type02 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type02 = true

					var ok bool
					var ot *TypeOneOf1_FInt64
					if ot, ok = x.One_Type02.(*TypeOneOf1_FInt64); !ok {
						ot = new(TypeOneOf1_FInt64)
					}
					var vv int64
					if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
						return err
					}
					ot.FInt64 = vv
					x.One_Type02 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "One_type03":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType03 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_uint32":
					if oneOfIsFill_OneType03 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType03 = true

					var ok bool
					var ot *TypeOneOf1_FUint32
					if ot, ok = x.OneType03.(*TypeOneOf1_FUint32); !ok {
						ot = new(TypeOneOf1_FUint32)
					}
					var vv uint32
					if vv, err = decoder.ReadLiteralUint32(jsonKey); err != nil {
						return err
					}
					ot.FUint32 = vv
					x.OneType03 = ot
				case "f_uint64":
					if oneOfIsFill_OneType03 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType03 = true

					var ok bool
					var ot *TypeOneOf1_FUint64
					if ot, ok = x.OneType03.(*TypeOneOf1_FUint64); !ok {
						ot = new(TypeOneOf1_FUint64)
					}
					var vv uint64
					if vv, err = decoder.ReadLiteralUint64(jsonKey); err != nil {
						return err
					}
					ot.FUint64 = vv
					x.OneType03 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "one_Type04":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.One_Type04 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_sint32":
					if oneOfIsFill_One_Type04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type04 = true

					var ok bool
					var ot *TypeOneOf1_FSint32
					if ot, ok = x.One_Type04.(*TypeOneOf1_FSint32); !ok {
						ot = new(TypeOneOf1_FSint32)
					}
					var vv int32
					if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
						return err
					}
					ot.FSint32 = vv
					x.One_Type04 = ot
				case "f_sint64":
					if oneOfIsFill_One_Type04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type04 = true

					var ok bool
					var ot *TypeOneOf1_FSint64
					if ot, ok = x.One_Type04.(*TypeOneOf1_FSint64); !ok {
						ot = new(TypeOneOf1_FSint64)
					}
					var vv int64
					if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
						return err
					}
					ot.FSint64 = vv
					x.One_Type04 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "one_type05":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType05 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_sfixed32":
					if oneOfIsFill_OneType05 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType05 = true

					var ok bool
					var ot *TypeOneOf1_FSfixed32
					if ot, ok = x.OneType05.(*TypeOneOf1_FSfixed32); !ok {
						ot = new(TypeOneOf1_FSfixed32)
					}
					var vv int32
					if vv, err = decoder.ReadLiteralInt32(jsonKey); err != nil {
						return err
					}
					ot.FSfixed32 = vv
					x.OneType05 = ot
				case "f_sfixed64":
					if oneOfIsFill_OneType05 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType05 = true

					var ok bool
					var ot *TypeOneOf1_FSfixed64
					if ot, ok = x.OneType05.(*TypeOneOf1_FSfixed64); !ok {
						ot = new(TypeOneOf1_FSfixed64)
					}
					var vv int64
					if vv, err = decoder.ReadLiteralInt64(jsonKey); err != nil {
						return err
					}
					ot.FSfixed64 = vv
					x.OneType05 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "oneType06":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType06 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_fixed32":
					if oneOfIsFill_OneType06 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType06 = true

					var ok bool
					var ot *TypeOneOf1_FFixed32
					if ot, ok = x.OneType06.(*TypeOneOf1_FFixed32); !ok {
						ot = new(TypeOneOf1_FFixed32)
					}
					var vv uint32
					if vv, err = decoder.ReadLiteralUint32(jsonKey); err != nil {
						return err
					}
					ot.FFixed32 = vv
					x.OneType06 = ot
				case "f_fixed64":
					if oneOfIsFill_OneType06 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType06 = true

					var ok bool
					var ot *TypeOneOf1_FFixed64
					if ot, ok = x.OneType06.(*TypeOneOf1_FFixed64); !ok {
						ot = new(TypeOneOf1_FFixed64)
					}
					var vv uint64
					if vv, err = decoder.ReadLiteralUint64(jsonKey); err != nil {
						return err
					}
					ot.FFixed64 = vv
					x.OneType06 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "Onetype07":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.Onetype07 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_float":
					if oneOfIsFill_Onetype07 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype07 = true

					var ok bool
					var ot *TypeOneOf1_FFloat
					if ot, ok = x.Onetype07.(*TypeOneOf1_FFloat); !ok {
						ot = new(TypeOneOf1_FFloat)
					}
					var vv float32
					if vv, err = decoder.ReadLiteralFloat32(jsonKey); err != nil {
						return err
					}
					ot.FFloat = vv
					x.Onetype07 = ot
				case "f_double":
					if oneOfIsFill_Onetype07 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype07 = true

					var ok bool
					var ot *TypeOneOf1_FDouble
					if ot, ok = x.Onetype07.(*TypeOneOf1_FDouble); !ok {
						ot = new(TypeOneOf1_FDouble)
					}
					var vv float64
					if vv, err = decoder.ReadLiteralFloat64(jsonKey); err != nil {
						return err
					}
					ot.FDouble = vv
					x.Onetype07 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "onetype08":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.Onetype08 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_bool1":
					if oneOfIsFill_Onetype08 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype08 = true

					var ok bool
					var ot *TypeOneOf1_FBool1
					if ot, ok = x.Onetype08.(*TypeOneOf1_FBool1); !ok {
						ot = new(TypeOneOf1_FBool1)
					}
					var vv bool
					if vv, err = decoder.ReadLiteralBool(jsonKey); err != nil {
						return err
					}
					ot.FBool1 = vv
					x.Onetype08 = ot
				case "f_bytes1":
					if oneOfIsFill_Onetype08 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype08 = true

					var ok bool
					var ot *TypeOneOf1_FBytes1
					if ot, ok = x.Onetype08.(*TypeOneOf1_FBytes1); !ok {
						ot = new(TypeOneOf1_FBytes1)
					}
					var vv []byte
					if vv, err = decoder.ReadLiteralBytes(jsonKey); err != nil {
						return err
					}
					ot.FBytes1 = vv
					x.Onetype08 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "OneType09":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType09 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_enum1":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum1
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum1); !ok {
						ot = new(TypeOneOf1_FEnum1)
					}
					var vv EnumOneOf1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, EnumOneOf1_name); err != nil {
						return err
					}
					vv = EnumOneOf1(v1)
					ot.FEnum1 = vv
					x.OneType09 = ot
				case "f_enum2":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum2
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum2); !ok {
						ot = new(TypeOneOf1_FEnum2)
					}
					var vv pbexternal.Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, pbexternal.Enum1_name); err != nil {
						return err
					}
					vv = pbexternal.Enum1(v1)
					ot.FEnum2 = vv
					x.OneType09 = ot
				case "f_enum3":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum3
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum3); !ok {
						ot = new(TypeOneOf1_FEnum3)
					}
					var vv pbexternal.Embed_Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, pbexternal.Embed_Enum1_name); err != nil {
						return err
					}
					vv = pbexternal.Embed_Enum1(v1)
					ot.FEnum3 = vv
					x.OneType09 = ot
				case "f_enum4":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum4
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum4); !ok {
						ot = new(TypeOneOf1_FEnum4)
					}
					var vv pbexternal.Embed_Message_Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, pbexternal.Embed_Message_Enum1_name); err != nil {
						return err
					}
					vv = pbexternal.Embed_Message_Enum1(v1)
					ot.FEnum4 = vv
					x.OneType09 = ot
				case "f_enum5":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum5
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum5); !ok {
						ot = new(TypeOneOf1_FEnum5)
					}
					var vv EnumCommon1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, EnumCommon1_name); err != nil {
						return err
					}
					vv = EnumCommon1(v1)
					ot.FEnum5 = vv
					x.OneType09 = ot
				case "f_enum6":
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true

					var ok bool
					var ot *TypeOneOf1_FEnum6
					if ot, ok = x.OneType09.(*TypeOneOf1_FEnum6); !ok {
						ot = new(TypeOneOf1_FEnum6)
					}
					var vv MessageCommon1_Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, MessageCommon1_Enum1_name); err != nil {
						return err
					}
					vv = MessageCommon1_Enum1(v1)
					ot.FEnum6 = vv
					x.OneType09 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "OneType10":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType10 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration1":
					if oneOfIsFill_OneType10 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType10 = true

					var ok bool
					var ot *TypeOneOf1_FDuration1
					if ot, ok = x.OneType10.(*TypeOneOf1_FDuration1); !ok {
						ot = new(TypeOneOf1_FDuration1)
					}
					var vv *durationpb.Duration
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FDuration1 = vv
					x.OneType10 = ot
				case "f_duration2":
					if oneOfIsFill_OneType10 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType10 = true

					var ok bool
					var ot *TypeOneOf1_FDuration2
					if ot, ok = x.OneType10.(*TypeOneOf1_FDuration2); !ok {
						ot = new(TypeOneOf1_FDuration2)
					}
					var vv *durationpb.Duration
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FDuration2 = vv
					x.OneType10 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "OneType11":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType11 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_timestamp1":
					if oneOfIsFill_OneType11 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType11 = true

					var ok bool
					var ot *TypeOneOf1_FTimestamp1
					if ot, ok = x.OneType11.(*TypeOneOf1_FTimestamp1); !ok {
						ot = new(TypeOneOf1_FTimestamp1)
					}
					var vv *timestamppb.Timestamp
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FTimestamp1 != nil {
							vv = ot.FTimestamp1
						} else {
							vv = new(timestamppb.Timestamp)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FTimestamp1 = vv
					x.OneType11 = ot
				case "f_timestamp2":
					if oneOfIsFill_OneType11 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType11 = true

					var ok bool
					var ot *TypeOneOf1_FTimestamp2
					if ot, ok = x.OneType11.(*TypeOneOf1_FTimestamp2); !ok {
						ot = new(TypeOneOf1_FTimestamp2)
					}
					var vv *timestamppb.Timestamp
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FTimestamp2 != nil {
							vv = ot.FTimestamp2
						} else {
							vv = new(timestamppb.Timestamp)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FTimestamp2 = vv
					x.OneType11 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "OneType12":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType12 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_any1":
					if oneOfIsFill_OneType12 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType12 = true

					var ok bool
					var ot *TypeOneOf1_FAny1
					if ot, ok = x.OneType12.(*TypeOneOf1_FAny1); !ok {
						ot = new(TypeOneOf1_FAny1)
					}
					var vv *anypb.Any
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FAny1 != nil {
							vv = ot.FAny1
						} else {
							vv = new(anypb.Any)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FAny1 = vv
					x.OneType12 = ot
				case "f_any2":
					if oneOfIsFill_OneType12 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType12 = true

					var ok bool
					var ot *TypeOneOf1_FAny2
					if ot, ok = x.OneType12.(*TypeOneOf1_FAny2); !ok {
						ot = new(TypeOneOf1_FAny2)
					}
					var vv *anypb.Any
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FAny2 != nil {
							vv = ot.FAny2
						} else {
							vv = new(anypb.Any)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FAny2 = vv
					x.OneType12 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "OneType13":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType13 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_message1":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage1
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage1); !ok {
						ot = new(TypeOneOf1_FMessage1)
					}
					var vv *MessageOneOf1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage1 != nil {
							vv = ot.FMessage1
						} else {
							vv = new(MessageOneOf1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage1 = vv
					x.OneType13 = ot
				case "f_message2":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage2
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage2); !ok {
						ot = new(TypeOneOf1_FMessage2)
					}
					var vv *MessageOneOf1_Embed1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage2 != nil {
							vv = ot.FMessage2
						} else {
							vv = new(MessageOneOf1_Embed1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage2 = vv
					x.OneType13 = ot
				case "f_message3":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage3
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage3); !ok {
						ot = new(TypeOneOf1_FMessage3)
					}
					var vv *MessageOneOf1_Embed1_Embed2
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage3 != nil {
							vv = ot.FMessage3
						} else {
							vv = new(MessageOneOf1_Embed1_Embed2)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage3 = vv
					x.OneType13 = ot
				case "f_message4":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage4
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage4); !ok {
						ot = new(TypeOneOf1_FMessage4)
					}
					var vv *pbexternal.Message1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage4 != nil {
							vv = ot.FMessage4
						} else {
							vv = new(pbexternal.Message1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage4 = vv
					x.OneType13 = ot
				case "f_message5":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage5
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage5); !ok {
						ot = new(TypeOneOf1_FMessage5)
					}
					var vv *pbexternal.Message1_Embed1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage5 != nil {
							vv = ot.FMessage5
						} else {
							vv = new(pbexternal.Message1_Embed1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage5 = vv
					x.OneType13 = ot
				case "f_message6":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage6
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage6); !ok {
						ot = new(TypeOneOf1_FMessage6)
					}
					var vv *pbexternal.Message1_Embed1_Embed2
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage6 != nil {
							vv = ot.FMessage6
						} else {
							vv = new(pbexternal.Message1_Embed1_Embed2)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage6 = vv
					x.OneType13 = ot
				case "f_message7":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage7
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage7); !ok {
						ot = new(TypeOneOf1_FMessage7)
					}
					var vv *MessageCommon1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage7 != nil {
							vv = ot.FMessage7
						} else {
							vv = new(MessageCommon1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage7 = vv
					x.OneType13 = ot
				case "f_message8":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage8
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage8); !ok {
						ot = new(TypeOneOf1_FMessage8)
					}
					var vv *MessageCommon1_Embed1
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage8 != nil {
							vv = ot.FMessage8
						} else {
							vv = new(MessageCommon1_Embed1)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage8 = vv
					x.OneType13 = ot
				case "f_message9":
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true

					var ok bool
					var ot *TypeOneOf1_FMessage9
					if ot, ok = x.OneType13.(*TypeOneOf1_FMessage9); !ok {
						ot = new(TypeOneOf1_FMessage9)
					}
					var vv *MessageCommon1_Embed1_Embed2
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FMessage9 != nil {
							vv = ot.FMessage9
						} else {
							vv = new(MessageCommon1_Embed1_Embed2)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FMessage9 = vv
					x.OneType13 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneOfHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneOfHide1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(90)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneOfHide1_FString1:
		encoder.AppendObjectKey("f_string1")
		encoder.AppendLiteralString(ov.FString1)
	case *TypeOneOfHide1_FString2:
		encoder.AppendObjectKey("f_string2")
		encoder.AppendLiteralString(ov.FString2)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType02.(type) {
	case *TypeOneOfHide1_FMessage1:
		encoder.AppendObjectKey("f_message1")
		if err = encoder.AppendLiteralInterface(ov.FMessage1); err != nil {
			return nil, err
		}
	case *TypeOneOfHide1_FMessage2:
		encoder.AppendObjectKey("f_message2")
		if err = encoder.AppendLiteralInterface(ov.FMessage2); err != nil {
			return nil, err
		}
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneOfHide1_FEnum1:
		encoder.AppendObjectKey("f_enum1")
		encoder.AppendLiteralInt32(int32(ov.FEnum1.Number()))
	case *TypeOneOfHide1_FEnum2:
		encoder.AppendObjectKey("f_enum2")
		encoder.AppendLiteralInt32(int32(ov.FEnum2.Number()))
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType04.(type) {
	case *TypeOneOfHide1_FDuration1:
		encoder.AppendObjectKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration1")
		if err = encoder.AppendLiteralInterface(ov.FDuration1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneOfHide1_FDuration2:
		encoder.AppendObjectKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration2")
		if err = encoder.AppendLiteralInterface(ov.FDuration2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("OneType04")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneOfHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneOfHide1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneOfHide1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_OneType02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_OneType04 bool

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true

			var ok bool
			var ot *TypeOneOfHide1_FString1
			if ot, ok = x.OneType01.(*TypeOneOfHide1_FString1); !ok {
				ot = new(TypeOneOfHide1_FString1)
			}
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			ot.FString1 = vv
			x.OneType01 = ot
		case "f_string2":
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true

			var ok bool
			var ot *TypeOneOfHide1_FString2
			if ot, ok = x.OneType01.(*TypeOneOfHide1_FString2); !ok {
				ot = new(TypeOneOfHide1_FString2)
			}
			var vv string
			if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
				return err
			}
			ot.FString2 = vv
			x.OneType01 = ot
		case "f_message1":
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true

			var ok bool
			var ot *TypeOneOfHide1_FMessage1
			if ot, ok = x.OneType02.(*TypeOneOfHide1_FMessage1); !ok {
				ot = new(TypeOneOfHide1_FMessage1)
			}
			var vv *MessageOneOf1
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if ot.FMessage1 != nil {
					vv = ot.FMessage1
				} else {
					vv = new(MessageOneOf1)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			ot.FMessage1 = vv
			x.OneType02 = ot
		case "f_message2":
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true

			var ok bool
			var ot *TypeOneOfHide1_FMessage2
			if ot, ok = x.OneType02.(*TypeOneOfHide1_FMessage2); !ok {
				ot = new(TypeOneOfHide1_FMessage2)
			}
			var vv *MessageOneOf1
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if ot.FMessage2 != nil {
					vv = ot.FMessage2
				} else {
					vv = new(MessageOneOf1)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			ot.FMessage2 = vv
			x.OneType02 = ot
		case "f_enum1":
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true

			var ok bool
			var ot *TypeOneOfHide1_FEnum1
			if ot, ok = x.OneType03.(*TypeOneOfHide1_FEnum1); !ok {
				ot = new(TypeOneOfHide1_FEnum1)
			}
			var vv EnumOneOf1
			var v1 int32
			if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, EnumOneOf1_name); err != nil {
				return err
			}
			vv = EnumOneOf1(v1)
			ot.FEnum1 = vv
			x.OneType03 = ot
		case "f_enum2":
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true

			var ok bool
			var ot *TypeOneOfHide1_FEnum2
			if ot, ok = x.OneType03.(*TypeOneOfHide1_FEnum2); !ok {
				ot = new(TypeOneOfHide1_FEnum2)
			}
			var vv EnumOneOf1
			var v1 int32
			if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, EnumOneOf1_name); err != nil {
				return err
			}
			vv = EnumOneOf1(v1)
			ot.FEnum2 = vv
			x.OneType03 = ot
		case "OneType04":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType04 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration1":
					if oneOfIsFill_OneType04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType04 = true

					var ok bool
					var ot *TypeOneOfHide1_FDuration1
					if ot, ok = x.OneType04.(*TypeOneOfHide1_FDuration1); !ok {
						ot = new(TypeOneOfHide1_FDuration1)
					}
					var vv *durationpb.Duration
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FDuration1 = vv
					x.OneType04 = ot
				case "f_duration2":
					if oneOfIsFill_OneType04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType04 = true

					var ok bool
					var ot *TypeOneOfHide1_FDuration2
					if ot, ok = x.OneType04.(*TypeOneOfHide1_FDuration2); !ok {
						ot = new(TypeOneOfHide1_FDuration2)
					}
					var vv *durationpb.Duration
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FDuration2 = vv
					x.OneType04 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
