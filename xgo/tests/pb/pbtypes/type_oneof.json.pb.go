// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/types/type_oneof.proto

package pbtypes

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message MessageOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MessageOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1_Embed1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1_Embed2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1_Embed2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1_Embed1_Embed2) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneof1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(296)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneof1_FString1:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_string1")
		encoder.AppendValueString(ov.FString1)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FString2:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_string2")
		encoder.AppendValueString(ov.FString2)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type02.(type) {
	case *TypeOneof1_FInt32:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_int32")
		encoder.AppendValueInt32(ov.FInt32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FInt64:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_int64")
		encoder.AppendValueInt64(ov.FInt64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneof1_FUint32:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_uint32")
		encoder.AppendValueUint32(ov.FUint32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FUint64:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_uint64")
		encoder.AppendValueUint64(ov.FUint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type04.(type) {
	case *TypeOneof1_FSint32:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sint32")
		encoder.AppendValueInt32(ov.FSint32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FSint64:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sint64")
		encoder.AppendValueInt64(ov.FSint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType05.(type) {
	case *TypeOneof1_FSfixed32:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sfixed32")
		encoder.AppendValueInt32(ov.FSfixed32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FSfixed64:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sfixed64")
		encoder.AppendValueInt64(ov.FSfixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType06.(type) {
	case *TypeOneof1_FFixed32:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_fixed32")
		encoder.AppendValueUint32(ov.FFixed32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FFixed64:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_fixed64")
		encoder.AppendValueUint64(ov.FFixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype07.(type) {
	case *TypeOneof1_FFloat:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_float")
		encoder.AppendValueFloat32(ov.FFloat)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FDouble:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_double")
		encoder.AppendValueFloat64(ov.FDouble)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype08.(type) {
	case *TypeOneof1_FBool1:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_bool1")
		encoder.AppendValueBool(ov.FBool1)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FBytes1:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_bytes1")
		encoder.AppendValueBytes(ov.FBytes1)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType09.(type) {
	case *TypeOneof1_FEnum1:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum1")
		encoder.AppendValueInt32(int32(ov.FEnum1.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum2:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum2")
		encoder.AppendValueInt32(int32(ov.FEnum2.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum3:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum3")
		encoder.AppendValueInt32(int32(ov.FEnum3.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum4:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum4")
		encoder.AppendValueInt32(int32(ov.FEnum4.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum5:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum5")
		encoder.AppendValueInt32(int32(ov.FEnum5.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum6:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum6")
		encoder.AppendValueInt32(int32(ov.FEnum6.Number()))
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType10.(type) {
	case *TypeOneof1_FDuration1:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration1")
		err = encoder.AppendValueInterface(ov.FDuration1)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FDuration2:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration2")
		err = encoder.AppendValueInterface(ov.FDuration2)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType11.(type) {
	case *TypeOneof1_FTimestamp1:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_timestamp1")
		err = encoder.AppendValueInterface(ov.FTimestamp1)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FTimestamp2:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_timestamp2")
		err = encoder.AppendValueInterface(ov.FTimestamp2)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType12.(type) {
	case *TypeOneof1_FAny1:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_any1")
		err = encoder.AppendValueInterface(ov.FAny1)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FAny2:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_any2")
		err = encoder.AppendValueInterface(ov.FAny2)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType13.(type) {
	case *TypeOneof1_FMessage1:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message1")
		err = encoder.AppendValueInterface(ov.FMessage1)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage2:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message2")
		err = encoder.AppendValueInterface(ov.FMessage2)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage3:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message3")
		err = encoder.AppendValueInterface(ov.FMessage3)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage4:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message4")
		err = encoder.AppendValueInterface(ov.FMessage4)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage5:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message5")
		err = encoder.AppendValueInterface(ov.FMessage5)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage6:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message6")
		err = encoder.AppendValueInterface(ov.FMessage6)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage7:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message7")
		err = encoder.AppendValueInterface(ov.FMessage7)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage8:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message8")
		err = encoder.AppendValueInterface(ov.FMessage8)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage9:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message9")
		err = encoder.AppendValueInterface(ov.FMessage9)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneof1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneof1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_One_Type02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_One_Type04 bool
	var oneOfIsFill_OneType05 bool
	var oneOfIsFill_OneType06 bool
	var oneOfIsFill_Onetype07 bool
	var oneOfIsFill_Onetype08 bool
	var oneOfIsFill_OneType09 bool
	var oneOfIsFill_OneType10 bool
	var oneOfIsFill_OneType11 bool
	var oneOfIsFill_OneType12 bool
	var oneOfIsFill_OneType13 bool
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "OneType01":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type string", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType01:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType01
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_string1":
						var ot *TypeOneof1_FString1
						if _ot, _ok := x.OneType01.(*TypeOneof1_FString1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FString1)
						}
						vv, _err := decoder.ReadValueString(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType01 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType01 = true
						ot.FString1 = vv
						x.OneType01 = ot
					case oneofKey == "f_string2":
						var ot *TypeOneof1_FString2
						if _ot, _ok := x.OneType01.(*TypeOneof1_FString2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FString2)
						}
						vv, _err := decoder.ReadValueString(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType01 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType01 = true
						ot.FString2 = vv
						x.OneType01 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType01
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "One_Type02":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			LOOP_ONEOF_One_Type02:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_One_Type02
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_int32":
						var ot *TypeOneof1_FInt32
						if _ot, _ok := x.One_Type02.(*TypeOneof1_FInt32); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FInt32)
						}
						vv, _err := decoder.ReadValueInt32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_One_Type02 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_One_Type02 = true
						ot.FInt32 = vv
						x.One_Type02 = ot
					case oneofKey == "f_int64":
						var ot *TypeOneof1_FInt64
						if _ot, _ok := x.One_Type02.(*TypeOneof1_FInt64); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FInt64)
						}
						vv, _err := decoder.ReadValueInt64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_One_Type02 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_One_Type02 = true
						ot.FInt64 = vv
						x.One_Type02 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_One_Type02
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "One_type03":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), jsonKey)
				}
			LOOP_ONEOF_One_type03:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_One_type03
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_uint32":
						var ot *TypeOneof1_FUint32
						if _ot, _ok := x.OneType03.(*TypeOneof1_FUint32); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FUint32)
						}
						vv, _err := decoder.ReadValueUint32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType03 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType03 = true
						ot.FUint32 = vv
						x.OneType03 = ot
					case oneofKey == "f_uint64":
						var ot *TypeOneof1_FUint64
						if _ot, _ok := x.OneType03.(*TypeOneof1_FUint64); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FUint64)
						}
						vv, _err := decoder.ReadValueUint64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType03 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType03 = true
						ot.FUint64 = vv
						x.OneType03 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_One_type03
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "one_Type04":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			LOOP_ONEOF_one_Type04:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_one_Type04
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_sint32":
						var ot *TypeOneof1_FSint32
						if _ot, _ok := x.One_Type04.(*TypeOneof1_FSint32); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FSint32)
						}
						vv, _err := decoder.ReadValueInt32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_One_Type04 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_One_Type04 = true
						ot.FSint32 = vv
						x.One_Type04 = ot
					case oneofKey == "f_sint64":
						var ot *TypeOneof1_FSint64
						if _ot, _ok := x.One_Type04.(*TypeOneof1_FSint64); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FSint64)
						}
						vv, _err := decoder.ReadValueInt64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_One_Type04 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_One_Type04 = true
						ot.FSint64 = vv
						x.One_Type04 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_one_Type04
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "one_type05":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type int32", string(value), jsonKey)
				}
			LOOP_ONEOF_one_type05:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_one_type05
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_sfixed32":
						var ot *TypeOneof1_FSfixed32
						if _ot, _ok := x.OneType05.(*TypeOneof1_FSfixed32); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FSfixed32)
						}
						vv, _err := decoder.ReadValueInt32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType05 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType05 = true
						ot.FSfixed32 = vv
						x.OneType05 = ot
					case oneofKey == "f_sfixed64":
						var ot *TypeOneof1_FSfixed64
						if _ot, _ok := x.OneType05.(*TypeOneof1_FSfixed64); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FSfixed64)
						}
						vv, _err := decoder.ReadValueInt64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType05 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType05 = true
						ot.FSfixed64 = vv
						x.OneType05 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_one_type05
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "oneType06":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type uint32", string(value), jsonKey)
				}
			LOOP_ONEOF_oneType06:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_oneType06
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_fixed32":
						var ot *TypeOneof1_FFixed32
						if _ot, _ok := x.OneType06.(*TypeOneof1_FFixed32); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FFixed32)
						}
						vv, _err := decoder.ReadValueUint32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType06 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType06 = true
						ot.FFixed32 = vv
						x.OneType06 = ot
					case oneofKey == "f_fixed64":
						var ot *TypeOneof1_FFixed64
						if _ot, _ok := x.OneType06.(*TypeOneof1_FFixed64); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FFixed64)
						}
						vv, _err := decoder.ReadValueUint64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType06 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType06 = true
						ot.FFixed64 = vv
						x.OneType06 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_oneType06
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "Onetype07":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float32", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type float32", string(value), jsonKey)
				}
			LOOP_ONEOF_Onetype07:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_Onetype07
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_float":
						var ot *TypeOneof1_FFloat
						if _ot, _ok := x.Onetype07.(*TypeOneof1_FFloat); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FFloat)
						}
						vv, _err := decoder.ReadValueFloat32(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_Onetype07 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_Onetype07 = true
						ot.FFloat = vv
						x.Onetype07 = ot
					case oneofKey == "f_double":
						var ot *TypeOneof1_FDouble
						if _ot, _ok := x.Onetype07.(*TypeOneof1_FDouble); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FDouble)
						}
						vv, _err := decoder.ReadValueFloat64(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_Onetype07 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_Onetype07 = true
						ot.FDouble = vv
						x.Onetype07 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_Onetype07
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "onetype08":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type bool", string(value), jsonKey)
				}
			LOOP_ONEOF_onetype08:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_onetype08
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_bool1":
						var ot *TypeOneof1_FBool1
						if _ot, _ok := x.Onetype08.(*TypeOneof1_FBool1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FBool1)
						}
						vv, _err := decoder.ReadValueBool(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_Onetype08 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_Onetype08 = true
						ot.FBool1 = vv
						x.Onetype08 = ot
					case oneofKey == "f_bytes1":
						var ot *TypeOneof1_FBytes1
						if _ot, _ok := x.Onetype08.(*TypeOneof1_FBytes1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FBytes1)
						}
						vv, _err := decoder.ReadValueBytes(jsonKey)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_Onetype08 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_Onetype08 = true
						ot.FBytes1 = vv
						x.Onetype08 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_onetype08
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "OneType09":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type EnumOneof1", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type EnumOneof1", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType09:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType09
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_enum1":
						var ot *TypeOneof1_FEnum1
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum1)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
						vv := EnumOneof1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum1 = vv
						x.OneType09 = ot
					case oneofKey == "f_enum2":
						var ot *TypeOneof1_FEnum2
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum2)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, pbexternal.Enum1_name)
						vv := pbexternal.Enum1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum2 = vv
						x.OneType09 = ot
					case oneofKey == "f_enum3":
						var ot *TypeOneof1_FEnum3
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum3); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum3)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, pbexternal.Embed_Enum1_name)
						vv := pbexternal.Embed_Enum1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum3 = vv
						x.OneType09 = ot
					case oneofKey == "f_enum4":
						var ot *TypeOneof1_FEnum4
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum4); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum4)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, pbexternal.Embed_Message_Enum1_name)
						vv := pbexternal.Embed_Message_Enum1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum4 = vv
						x.OneType09 = ot
					case oneofKey == "f_enum5":
						var ot *TypeOneof1_FEnum5
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum5); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum5)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, EnumCommon1_name)
						vv := EnumCommon1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum5 = vv
						x.OneType09 = ot
					case oneofKey == "f_enum6":
						var ot *TypeOneof1_FEnum6
						if _ot, _ok := x.OneType09.(*TypeOneof1_FEnum6); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FEnum6)
						}
						v1, _err := decoder.ReadValueEnumNumber(jsonKey, MessageCommon1_Enum1_name)
						vv := MessageCommon1_Enum1(v1)
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType09 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType09 = true
						ot.FEnum6 = vv
						x.OneType09 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType09
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "OneType10":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *durationpb.Duration", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *durationpb.Duration", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType10:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType10
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_duration1":
						var ot *TypeOneof1_FDuration1
						if _ot, _ok := x.OneType10.(*TypeOneof1_FDuration1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FDuration1)
						}
						var vv *durationpb.Duration
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType10 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType10 = true
						ot.FDuration1 = vv
						x.OneType10 = ot
					case oneofKey == "f_duration2":
						var ot *TypeOneof1_FDuration2
						if _ot, _ok := x.OneType10.(*TypeOneof1_FDuration2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FDuration2)
						}
						var vv *durationpb.Duration
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType10 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType10 = true
						ot.FDuration2 = vv
						x.OneType10 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType10
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "OneType11":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *timestamppb.Timestamp", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *timestamppb.Timestamp", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType11:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType11
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_timestamp1":
						var ot *TypeOneof1_FTimestamp1
						if _ot, _ok := x.OneType11.(*TypeOneof1_FTimestamp1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FTimestamp1)
						}
						var vv *timestamppb.Timestamp
						if ot.FTimestamp1 != nil {
							vv = ot.FTimestamp1
						} else {
							vv = new(timestamppb.Timestamp)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType11 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType11 = true
						ot.FTimestamp1 = vv
						x.OneType11 = ot
					case oneofKey == "f_timestamp2":
						var ot *TypeOneof1_FTimestamp2
						if _ot, _ok := x.OneType11.(*TypeOneof1_FTimestamp2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FTimestamp2)
						}
						var vv *timestamppb.Timestamp
						if ot.FTimestamp2 != nil {
							vv = ot.FTimestamp2
						} else {
							vv = new(timestamppb.Timestamp)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType11 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType11 = true
						ot.FTimestamp2 = vv
						x.OneType11 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType11
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "OneType12":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *anypb.Any", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *anypb.Any", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType12:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType12
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_any1":
						var ot *TypeOneof1_FAny1
						if _ot, _ok := x.OneType12.(*TypeOneof1_FAny1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FAny1)
						}
						var vv *anypb.Any
						if ot.FAny1 != nil {
							vv = ot.FAny1
						} else {
							vv = new(anypb.Any)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType12 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType12 = true
						ot.FAny1 = vv
						x.OneType12 = ot
					case oneofKey == "f_any2":
						var ot *TypeOneof1_FAny2
						if _ot, _ok := x.OneType12.(*TypeOneof1_FAny2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FAny2)
						}
						var vv *anypb.Any
						if ot.FAny2 != nil {
							vv = ot.FAny2
						} else {
							vv = new(anypb.Any)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType12 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType12 = true
						ot.FAny2 = vv
						x.OneType12 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType12
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "OneType13":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *MessageOneof1", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *MessageOneof1", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType13:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType13
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_message1":
						var ot *TypeOneof1_FMessage1
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage1)
						}
						var vv *MessageOneof1
						if ot.FMessage1 != nil {
							vv = ot.FMessage1
						} else {
							vv = new(MessageOneof1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage1 = vv
						x.OneType13 = ot
					case oneofKey == "f_message2":
						var ot *TypeOneof1_FMessage2
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage2)
						}
						var vv *MessageOneof1_Embed1
						if ot.FMessage2 != nil {
							vv = ot.FMessage2
						} else {
							vv = new(MessageOneof1_Embed1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage2 = vv
						x.OneType13 = ot
					case oneofKey == "f_message3":
						var ot *TypeOneof1_FMessage3
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage3); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage3)
						}
						var vv *MessageOneof1_Embed1_Embed2
						if ot.FMessage3 != nil {
							vv = ot.FMessage3
						} else {
							vv = new(MessageOneof1_Embed1_Embed2)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage3 = vv
						x.OneType13 = ot
					case oneofKey == "f_message4":
						var ot *TypeOneof1_FMessage4
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage4); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage4)
						}
						var vv *pbexternal.Message1
						if ot.FMessage4 != nil {
							vv = ot.FMessage4
						} else {
							vv = new(pbexternal.Message1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage4 = vv
						x.OneType13 = ot
					case oneofKey == "f_message5":
						var ot *TypeOneof1_FMessage5
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage5); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage5)
						}
						var vv *pbexternal.Message1_Embed1
						if ot.FMessage5 != nil {
							vv = ot.FMessage5
						} else {
							vv = new(pbexternal.Message1_Embed1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage5 = vv
						x.OneType13 = ot
					case oneofKey == "f_message6":
						var ot *TypeOneof1_FMessage6
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage6); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage6)
						}
						var vv *pbexternal.Message1_Embed1_Embed2
						if ot.FMessage6 != nil {
							vv = ot.FMessage6
						} else {
							vv = new(pbexternal.Message1_Embed1_Embed2)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage6 = vv
						x.OneType13 = ot
					case oneofKey == "f_message7":
						var ot *TypeOneof1_FMessage7
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage7); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage7)
						}
						var vv *MessageCommon1
						if ot.FMessage7 != nil {
							vv = ot.FMessage7
						} else {
							vv = new(MessageCommon1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage7 = vv
						x.OneType13 = ot
					case oneofKey == "f_message8":
						var ot *TypeOneof1_FMessage8
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage8); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage8)
						}
						var vv *MessageCommon1_Embed1
						if ot.FMessage8 != nil {
							vv = ot.FMessage8
						} else {
							vv = new(MessageCommon1_Embed1)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage8 = vv
						x.OneType13 = ot
					case oneofKey == "f_message9":
						var ot *TypeOneof1_FMessage9
						if _ot, _ok := x.OneType13.(*TypeOneof1_FMessage9); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneof1_FMessage9)
						}
						var vv *MessageCommon1_Embed1_Embed2
						if ot.FMessage9 != nil {
							vv = ot.FMessage9
						} else {
							vv = new(MessageCommon1_Embed1_Embed2)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType13 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType13 = true
						ot.FMessage9 = vv
						x.OneType13 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType13
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneofHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneofHide1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(90)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneofHide1_FString1:
		encoder.AppendJSONKey("f_string1")
		encoder.AppendValueString(ov.FString1)
	case *TypeOneofHide1_FString2:
		encoder.AppendJSONKey("f_string2")
		encoder.AppendValueString(ov.FString2)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType02.(type) {
	case *TypeOneofHide1_FMessage1:
		encoder.AppendJSONKey("f_message1")
		err = encoder.AppendValueInterface(ov.FMessage1)
		if err != nil {
			return nil, err
		}
	case *TypeOneofHide1_FMessage2:
		encoder.AppendJSONKey("f_message2")
		err = encoder.AppendValueInterface(ov.FMessage2)
		if err != nil {
			return nil, err
		}
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneofHide1_FEnum1:
		encoder.AppendJSONKey("f_enum1")
		encoder.AppendValueInt32(int32(ov.FEnum1.Number()))
	case *TypeOneofHide1_FEnum2:
		encoder.AppendJSONKey("f_enum2")
		encoder.AppendValueInt32(int32(ov.FEnum2.Number()))
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType04.(type) {
	case *TypeOneofHide1_FDuration1:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration1")
		err = encoder.AppendValueInterface(ov.FDuration1)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneofHide1_FDuration2:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration2")
		err = encoder.AppendValueInterface(ov.FDuration2)
		if err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneofHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneofHide1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneofHide1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_OneType02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_OneType04 bool
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			var ot *TypeOneofHide1_FString1
			if _ot, _ok := x.OneType01.(*TypeOneofHide1_FString1); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FString1)
			}
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true
			ot.FString1 = vv
			x.OneType01 = ot
		case jsonKey == "f_string2":
			var ot *TypeOneofHide1_FString2
			if _ot, _ok := x.OneType01.(*TypeOneofHide1_FString2); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FString2)
			}
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true
			ot.FString2 = vv
			x.OneType01 = ot
		case jsonKey == "f_message1":
			var ot *TypeOneofHide1_FMessage1
			if _ot, _ok := x.OneType02.(*TypeOneofHide1_FMessage1); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FMessage1)
			}
			var vv *MessageOneof1
			if ot.FMessage1 != nil {
				vv = ot.FMessage1
			} else {
				vv = new(MessageOneof1)
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true
			ot.FMessage1 = vv
			x.OneType02 = ot
		case jsonKey == "f_message2":
			var ot *TypeOneofHide1_FMessage2
			if _ot, _ok := x.OneType02.(*TypeOneofHide1_FMessage2); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FMessage2)
			}
			var vv *MessageOneof1
			if ot.FMessage2 != nil {
				vv = ot.FMessage2
			} else {
				vv = new(MessageOneof1)
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true
			ot.FMessage2 = vv
			x.OneType02 = ot
		case jsonKey == "f_enum1":
			var ot *TypeOneofHide1_FEnum1
			if _ot, _ok := x.OneType03.(*TypeOneofHide1_FEnum1); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FEnum1)
			}
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
			vv := EnumOneof1(v1)
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true
			ot.FEnum1 = vv
			x.OneType03 = ot
		case jsonKey == "f_enum2":
			var ot *TypeOneofHide1_FEnum2
			if _ot, _ok := x.OneType03.(*TypeOneofHide1_FEnum2); _ok {
				ot = _ot
			} else {
				ot = new(TypeOneofHide1_FEnum2)
			}
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
			vv := EnumOneof1(v1)
			if _err != nil {
				return _err
			}
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true
			ot.FEnum2 = vv
			x.OneType03 = ot
		case jsonKey == "OneType04":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *durationpb.Duration", string(value), jsonKey)
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as oneof into field %s of type *durationpb.Duration", string(value), jsonKey)
				}
			LOOP_ONEOF_OneType04:
				for {
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_ONEOF_OneType04
					}
					oneofKey := decoder.ReadObjectKey() // Read key
					decoder.ReadObjectValueBefore()     // Before read object value
					switch {
					case oneofKey == "f_duration1":
						var ot *TypeOneofHide1_FDuration1
						if _ot, _ok := x.OneType04.(*TypeOneofHide1_FDuration1); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneofHide1_FDuration1)
						}
						var vv *durationpb.Duration
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType04 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType04 = true
						ot.FDuration1 = vv
						x.OneType04 = ot
					case oneofKey == "f_duration2":
						var ot *TypeOneofHide1_FDuration2
						if _ot, _ok := x.OneType04.(*TypeOneofHide1_FDuration2); _ok {
							ot = _ot
						} else {
							ot = new(TypeOneofHide1_FDuration2)
						}
						var vv *durationpb.Duration
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						ok, _err := decoder.ReadValueInterface(jsonKey, vv)
						if !ok { // The field is null
							vv = nil
						}
						if _err != nil {
							return _err
						}
						if oneOfIsFill_OneType04 {
							return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
						}
						oneOfIsFill_OneType04 = true
						ot.FDuration2 = vv
						x.OneType04 = ot
					default:
						_ = decoder.ReadItem() // discard unknown field
					}
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_ONEOF_OneType04
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
