// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/types/type_oneof.proto

package pbtypes

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message MessageOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MessageOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed1 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1_Embed1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1_Embed2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed2 in file tests/proto/cases/types/type_oneof.proto
func (x *MessageOneof1_Embed1_Embed2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageOneof1_Embed1_Embed2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneof1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(296)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneof1_FString1:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_string1")
		encoder.AppendValueString(ov.FString1)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FString2:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_string2")
		encoder.AppendValueString(ov.FString2)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType01")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type02.(type) {
	case *TypeOneof1_FInt32:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_int32")
		encoder.AppendValueInt32(ov.FInt32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FInt64:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_int64")
		encoder.AppendValueInt64(ov.FInt64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("One_Type02")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneof1_FUint32:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_uint32")
		encoder.AppendValueUint32(ov.FUint32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FUint64:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_uint64")
		encoder.AppendValueUint64(ov.FUint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("One_type03")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.One_Type04.(type) {
	case *TypeOneof1_FSint32:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sint32")
		encoder.AppendValueInt32(ov.FSint32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FSint64:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sint64")
		encoder.AppendValueInt64(ov.FSint64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("one_Type04")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType05.(type) {
	case *TypeOneof1_FSfixed32:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sfixed32")
		encoder.AppendValueInt32(ov.FSfixed32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FSfixed64:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_sfixed64")
		encoder.AppendValueInt64(ov.FSfixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("one_type05")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType06.(type) {
	case *TypeOneof1_FFixed32:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_fixed32")
		encoder.AppendValueUint32(ov.FFixed32)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FFixed64:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_fixed64")
		encoder.AppendValueUint64(ov.FFixed64)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("oneType06")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype07.(type) {
	case *TypeOneof1_FFloat:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_float")
		encoder.AppendValueFloat32(ov.FFloat)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FDouble:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_double")
		encoder.AppendValueFloat64(ov.FDouble)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("Onetype07")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.Onetype08.(type) {
	case *TypeOneof1_FBool1:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_bool1")
		encoder.AppendValueBool(ov.FBool1)
		encoder.AppendObjectEnd()
	case *TypeOneof1_FBytes1:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_bytes1")
		encoder.AppendValueBytes(ov.FBytes1)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("onetype08")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType09.(type) {
	case *TypeOneof1_FEnum1:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum1")
		encoder.AppendValueInt32(int32(ov.FEnum1.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum2:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum2")
		encoder.AppendValueInt32(int32(ov.FEnum2.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum3:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum3")
		encoder.AppendValueInt32(int32(ov.FEnum3.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum4:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum4")
		encoder.AppendValueInt32(int32(ov.FEnum4.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum5:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum5")
		encoder.AppendValueInt32(int32(ov.FEnum5.Number()))
		encoder.AppendObjectEnd()
	case *TypeOneof1_FEnum6:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_enum6")
		encoder.AppendValueInt32(int32(ov.FEnum6.Number()))
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType09")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType10.(type) {
	case *TypeOneof1_FDuration1:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration1")
		if err = encoder.AppendValueInterface(ov.FDuration1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FDuration2:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration2")
		if err = encoder.AppendValueInterface(ov.FDuration2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType10")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType11.(type) {
	case *TypeOneof1_FTimestamp1:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_timestamp1")
		if err = encoder.AppendValueInterface(ov.FTimestamp1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FTimestamp2:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_timestamp2")
		if err = encoder.AppendValueInterface(ov.FTimestamp2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType11")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType12.(type) {
	case *TypeOneof1_FAny1:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_any1")
		if err = encoder.AppendValueInterface(ov.FAny1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FAny2:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_any2")
		if err = encoder.AppendValueInterface(ov.FAny2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType12")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType13.(type) {
	case *TypeOneof1_FMessage1:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message1")
		if err = encoder.AppendValueInterface(ov.FMessage1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage2:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message2")
		if err = encoder.AppendValueInterface(ov.FMessage2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage3:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message3")
		if err = encoder.AppendValueInterface(ov.FMessage3); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage4:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message4")
		if err = encoder.AppendValueInterface(ov.FMessage4); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage5:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message5")
		if err = encoder.AppendValueInterface(ov.FMessage5); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage6:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message6")
		if err = encoder.AppendValueInterface(ov.FMessage6); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage7:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message7")
		if err = encoder.AppendValueInterface(ov.FMessage7); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage8:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message8")
		if err = encoder.AppendValueInterface(ov.FMessage8); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneof1_FMessage9:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_message9")
		if err = encoder.AppendValueInterface(ov.FMessage9); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType13")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneof1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneof1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneof1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_One_Type02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_One_Type04 bool
	var oneOfIsFill_OneType05 bool
	var oneOfIsFill_OneType06 bool
	var oneOfIsFill_Onetype07 bool
	var oneOfIsFill_Onetype08 bool
	var oneOfIsFill_OneType09 bool
	var oneOfIsFill_OneType10 bool
	var oneOfIsFill_OneType11 bool
	var oneOfIsFill_OneType12 bool
	var oneOfIsFill_OneType13 bool

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "OneType01":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType01 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_string1":
					var ok bool
					var ot *TypeOneof1_FString1
					if ot, ok = x.OneType01.(*TypeOneof1_FString1); !ok {
						ot = new(TypeOneof1_FString1)
					}
					var vv string
					vv, err = decoder.ReadValueString(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType01 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType01 = true
					ot.FString1 = vv
					x.OneType01 = ot
				case "f_string2":
					var ok bool
					var ot *TypeOneof1_FString2
					if ot, ok = x.OneType01.(*TypeOneof1_FString2); !ok {
						ot = new(TypeOneof1_FString2)
					}
					var vv string
					vv, err = decoder.ReadValueString(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType01 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType01 = true
					ot.FString2 = vv
					x.OneType01 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "One_Type02":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.One_Type02 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_int32":
					var ok bool
					var ot *TypeOneof1_FInt32
					if ot, ok = x.One_Type02.(*TypeOneof1_FInt32); !ok {
						ot = new(TypeOneof1_FInt32)
					}
					var vv int32
					vv, err = decoder.ReadValueInt32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_One_Type02 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type02 = true
					ot.FInt32 = vv
					x.One_Type02 = ot
				case "f_int64":
					var ok bool
					var ot *TypeOneof1_FInt64
					if ot, ok = x.One_Type02.(*TypeOneof1_FInt64); !ok {
						ot = new(TypeOneof1_FInt64)
					}
					var vv int64
					vv, err = decoder.ReadValueInt64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_One_Type02 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type02 = true
					ot.FInt64 = vv
					x.One_Type02 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "One_type03":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType03 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_uint32":
					var ok bool
					var ot *TypeOneof1_FUint32
					if ot, ok = x.OneType03.(*TypeOneof1_FUint32); !ok {
						ot = new(TypeOneof1_FUint32)
					}
					var vv uint32
					vv, err = decoder.ReadValueUint32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType03 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType03 = true
					ot.FUint32 = vv
					x.OneType03 = ot
				case "f_uint64":
					var ok bool
					var ot *TypeOneof1_FUint64
					if ot, ok = x.OneType03.(*TypeOneof1_FUint64); !ok {
						ot = new(TypeOneof1_FUint64)
					}
					var vv uint64
					vv, err = decoder.ReadValueUint64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType03 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType03 = true
					ot.FUint64 = vv
					x.OneType03 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "one_Type04":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.One_Type04 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_sint32":
					var ok bool
					var ot *TypeOneof1_FSint32
					if ot, ok = x.One_Type04.(*TypeOneof1_FSint32); !ok {
						ot = new(TypeOneof1_FSint32)
					}
					var vv int32
					vv, err = decoder.ReadValueInt32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_One_Type04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type04 = true
					ot.FSint32 = vv
					x.One_Type04 = ot
				case "f_sint64":
					var ok bool
					var ot *TypeOneof1_FSint64
					if ot, ok = x.One_Type04.(*TypeOneof1_FSint64); !ok {
						ot = new(TypeOneof1_FSint64)
					}
					var vv int64
					vv, err = decoder.ReadValueInt64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_One_Type04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_One_Type04 = true
					ot.FSint64 = vv
					x.One_Type04 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "one_type05":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType05 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_sfixed32":
					var ok bool
					var ot *TypeOneof1_FSfixed32
					if ot, ok = x.OneType05.(*TypeOneof1_FSfixed32); !ok {
						ot = new(TypeOneof1_FSfixed32)
					}
					var vv int32
					vv, err = decoder.ReadValueInt32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType05 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType05 = true
					ot.FSfixed32 = vv
					x.OneType05 = ot
				case "f_sfixed64":
					var ok bool
					var ot *TypeOneof1_FSfixed64
					if ot, ok = x.OneType05.(*TypeOneof1_FSfixed64); !ok {
						ot = new(TypeOneof1_FSfixed64)
					}
					var vv int64
					vv, err = decoder.ReadValueInt64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType05 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType05 = true
					ot.FSfixed64 = vv
					x.OneType05 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "oneType06":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType06 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_fixed32":
					var ok bool
					var ot *TypeOneof1_FFixed32
					if ot, ok = x.OneType06.(*TypeOneof1_FFixed32); !ok {
						ot = new(TypeOneof1_FFixed32)
					}
					var vv uint32
					vv, err = decoder.ReadValueUint32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType06 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType06 = true
					ot.FFixed32 = vv
					x.OneType06 = ot
				case "f_fixed64":
					var ok bool
					var ot *TypeOneof1_FFixed64
					if ot, ok = x.OneType06.(*TypeOneof1_FFixed64); !ok {
						ot = new(TypeOneof1_FFixed64)
					}
					var vv uint64
					vv, err = decoder.ReadValueUint64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType06 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType06 = true
					ot.FFixed64 = vv
					x.OneType06 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "Onetype07":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.Onetype07 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_float":
					var ok bool
					var ot *TypeOneof1_FFloat
					if ot, ok = x.Onetype07.(*TypeOneof1_FFloat); !ok {
						ot = new(TypeOneof1_FFloat)
					}
					var vv float32
					vv, err = decoder.ReadValueFloat32(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_Onetype07 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype07 = true
					ot.FFloat = vv
					x.Onetype07 = ot
				case "f_double":
					var ok bool
					var ot *TypeOneof1_FDouble
					if ot, ok = x.Onetype07.(*TypeOneof1_FDouble); !ok {
						ot = new(TypeOneof1_FDouble)
					}
					var vv float64
					vv, err = decoder.ReadValueFloat64(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_Onetype07 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype07 = true
					ot.FDouble = vv
					x.Onetype07 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "onetype08":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.Onetype08 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_bool1":
					var ok bool
					var ot *TypeOneof1_FBool1
					if ot, ok = x.Onetype08.(*TypeOneof1_FBool1); !ok {
						ot = new(TypeOneof1_FBool1)
					}
					var vv bool
					vv, err = decoder.ReadValueBool(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_Onetype08 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype08 = true
					ot.FBool1 = vv
					x.Onetype08 = ot
				case "f_bytes1":
					var ok bool
					var ot *TypeOneof1_FBytes1
					if ot, ok = x.Onetype08.(*TypeOneof1_FBytes1); !ok {
						ot = new(TypeOneof1_FBytes1)
					}
					var vv []byte
					vv, err = decoder.ReadValueBytes(jsonKey)
					if err != nil {
						return err
					}
					if oneOfIsFill_Onetype08 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_Onetype08 = true
					ot.FBytes1 = vv
					x.Onetype08 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "OneType09":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType09 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_enum1":
					var ok bool
					var ot *TypeOneof1_FEnum1
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum1); !ok {
						ot = new(TypeOneof1_FEnum1)
					}
					var vv EnumOneof1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
					vv = EnumOneof1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum1 = vv
					x.OneType09 = ot
				case "f_enum2":
					var ok bool
					var ot *TypeOneof1_FEnum2
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum2); !ok {
						ot = new(TypeOneof1_FEnum2)
					}
					var vv pbexternal.Enum1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, pbexternal.Enum1_name)
					vv = pbexternal.Enum1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum2 = vv
					x.OneType09 = ot
				case "f_enum3":
					var ok bool
					var ot *TypeOneof1_FEnum3
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum3); !ok {
						ot = new(TypeOneof1_FEnum3)
					}
					var vv pbexternal.Embed_Enum1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, pbexternal.Embed_Enum1_name)
					vv = pbexternal.Embed_Enum1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum3 = vv
					x.OneType09 = ot
				case "f_enum4":
					var ok bool
					var ot *TypeOneof1_FEnum4
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum4); !ok {
						ot = new(TypeOneof1_FEnum4)
					}
					var vv pbexternal.Embed_Message_Enum1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, pbexternal.Embed_Message_Enum1_name)
					vv = pbexternal.Embed_Message_Enum1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum4 = vv
					x.OneType09 = ot
				case "f_enum5":
					var ok bool
					var ot *TypeOneof1_FEnum5
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum5); !ok {
						ot = new(TypeOneof1_FEnum5)
					}
					var vv EnumCommon1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, EnumCommon1_name)
					vv = EnumCommon1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum5 = vv
					x.OneType09 = ot
				case "f_enum6":
					var ok bool
					var ot *TypeOneof1_FEnum6
					if ot, ok = x.OneType09.(*TypeOneof1_FEnum6); !ok {
						ot = new(TypeOneof1_FEnum6)
					}
					var vv MessageCommon1_Enum1
					var v1 int32
					v1, err = decoder.ReadValueEnumNumber(jsonKey, MessageCommon1_Enum1_name)
					vv = MessageCommon1_Enum1(v1)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType09 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType09 = true
					ot.FEnum6 = vv
					x.OneType09 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "OneType10":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType10 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration1":
					var ok bool
					var ot *TypeOneof1_FDuration1
					if ot, ok = x.OneType10.(*TypeOneof1_FDuration1); !ok {
						ot = new(TypeOneof1_FDuration1)
					}
					var vv *durationpb.Duration
					initFN := func() interface{} {
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType10 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType10 = true
					ot.FDuration1 = vv
					x.OneType10 = ot
				case "f_duration2":
					var ok bool
					var ot *TypeOneof1_FDuration2
					if ot, ok = x.OneType10.(*TypeOneof1_FDuration2); !ok {
						ot = new(TypeOneof1_FDuration2)
					}
					var vv *durationpb.Duration
					initFN := func() interface{} {
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType10 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType10 = true
					ot.FDuration2 = vv
					x.OneType10 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "OneType11":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType11 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_timestamp1":
					var ok bool
					var ot *TypeOneof1_FTimestamp1
					if ot, ok = x.OneType11.(*TypeOneof1_FTimestamp1); !ok {
						ot = new(TypeOneof1_FTimestamp1)
					}
					var vv *timestamppb.Timestamp
					initFN := func() interface{} {
						if ot.FTimestamp1 != nil {
							vv = ot.FTimestamp1
						} else {
							vv = new(timestamppb.Timestamp)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType11 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType11 = true
					ot.FTimestamp1 = vv
					x.OneType11 = ot
				case "f_timestamp2":
					var ok bool
					var ot *TypeOneof1_FTimestamp2
					if ot, ok = x.OneType11.(*TypeOneof1_FTimestamp2); !ok {
						ot = new(TypeOneof1_FTimestamp2)
					}
					var vv *timestamppb.Timestamp
					initFN := func() interface{} {
						if ot.FTimestamp2 != nil {
							vv = ot.FTimestamp2
						} else {
							vv = new(timestamppb.Timestamp)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType11 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType11 = true
					ot.FTimestamp2 = vv
					x.OneType11 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "OneType12":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType12 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_any1":
					var ok bool
					var ot *TypeOneof1_FAny1
					if ot, ok = x.OneType12.(*TypeOneof1_FAny1); !ok {
						ot = new(TypeOneof1_FAny1)
					}
					var vv *anypb.Any
					initFN := func() interface{} {
						if ot.FAny1 != nil {
							vv = ot.FAny1
						} else {
							vv = new(anypb.Any)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType12 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType12 = true
					ot.FAny1 = vv
					x.OneType12 = ot
				case "f_any2":
					var ok bool
					var ot *TypeOneof1_FAny2
					if ot, ok = x.OneType12.(*TypeOneof1_FAny2); !ok {
						ot = new(TypeOneof1_FAny2)
					}
					var vv *anypb.Any
					initFN := func() interface{} {
						if ot.FAny2 != nil {
							vv = ot.FAny2
						} else {
							vv = new(anypb.Any)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType12 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType12 = true
					ot.FAny2 = vv
					x.OneType12 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		case "OneType13":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType13 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_message1":
					var ok bool
					var ot *TypeOneof1_FMessage1
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage1); !ok {
						ot = new(TypeOneof1_FMessage1)
					}
					var vv *MessageOneof1
					initFN := func() interface{} {
						if ot.FMessage1 != nil {
							vv = ot.FMessage1
						} else {
							vv = new(MessageOneof1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage1 = vv
					x.OneType13 = ot
				case "f_message2":
					var ok bool
					var ot *TypeOneof1_FMessage2
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage2); !ok {
						ot = new(TypeOneof1_FMessage2)
					}
					var vv *MessageOneof1_Embed1
					initFN := func() interface{} {
						if ot.FMessage2 != nil {
							vv = ot.FMessage2
						} else {
							vv = new(MessageOneof1_Embed1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage2 = vv
					x.OneType13 = ot
				case "f_message3":
					var ok bool
					var ot *TypeOneof1_FMessage3
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage3); !ok {
						ot = new(TypeOneof1_FMessage3)
					}
					var vv *MessageOneof1_Embed1_Embed2
					initFN := func() interface{} {
						if ot.FMessage3 != nil {
							vv = ot.FMessage3
						} else {
							vv = new(MessageOneof1_Embed1_Embed2)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage3 = vv
					x.OneType13 = ot
				case "f_message4":
					var ok bool
					var ot *TypeOneof1_FMessage4
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage4); !ok {
						ot = new(TypeOneof1_FMessage4)
					}
					var vv *pbexternal.Message1
					initFN := func() interface{} {
						if ot.FMessage4 != nil {
							vv = ot.FMessage4
						} else {
							vv = new(pbexternal.Message1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage4 = vv
					x.OneType13 = ot
				case "f_message5":
					var ok bool
					var ot *TypeOneof1_FMessage5
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage5); !ok {
						ot = new(TypeOneof1_FMessage5)
					}
					var vv *pbexternal.Message1_Embed1
					initFN := func() interface{} {
						if ot.FMessage5 != nil {
							vv = ot.FMessage5
						} else {
							vv = new(pbexternal.Message1_Embed1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage5 = vv
					x.OneType13 = ot
				case "f_message6":
					var ok bool
					var ot *TypeOneof1_FMessage6
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage6); !ok {
						ot = new(TypeOneof1_FMessage6)
					}
					var vv *pbexternal.Message1_Embed1_Embed2
					initFN := func() interface{} {
						if ot.FMessage6 != nil {
							vv = ot.FMessage6
						} else {
							vv = new(pbexternal.Message1_Embed1_Embed2)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage6 = vv
					x.OneType13 = ot
				case "f_message7":
					var ok bool
					var ot *TypeOneof1_FMessage7
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage7); !ok {
						ot = new(TypeOneof1_FMessage7)
					}
					var vv *MessageCommon1
					initFN := func() interface{} {
						if ot.FMessage7 != nil {
							vv = ot.FMessage7
						} else {
							vv = new(MessageCommon1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage7 = vv
					x.OneType13 = ot
				case "f_message8":
					var ok bool
					var ot *TypeOneof1_FMessage8
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage8); !ok {
						ot = new(TypeOneof1_FMessage8)
					}
					var vv *MessageCommon1_Embed1
					initFN := func() interface{} {
						if ot.FMessage8 != nil {
							vv = ot.FMessage8
						} else {
							vv = new(MessageCommon1_Embed1)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage8 = vv
					x.OneType13 = ot
				case "f_message9":
					var ok bool
					var ot *TypeOneof1_FMessage9
					if ot, ok = x.OneType13.(*TypeOneof1_FMessage9); !ok {
						ot = new(TypeOneof1_FMessage9)
					}
					var vv *MessageCommon1_Embed1_Embed2
					initFN := func() interface{} {
						if ot.FMessage9 != nil {
							vv = ot.FMessage9
						} else {
							vv = new(MessageCommon1_Embed1_Embed2)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType13 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType13 = true
					ot.FMessage9 = vv
					x.OneType13 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneofHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneofHide1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(90)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneType01.(type) {
	case *TypeOneofHide1_FString1:
		encoder.AppendJSONKey("f_string1")
		encoder.AppendValueString(ov.FString1)
	case *TypeOneofHide1_FString2:
		encoder.AppendJSONKey("f_string2")
		encoder.AppendValueString(ov.FString2)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType02.(type) {
	case *TypeOneofHide1_FMessage1:
		encoder.AppendJSONKey("f_message1")
		if err = encoder.AppendValueInterface(ov.FMessage1); err != nil {
			return nil, err
		}
	case *TypeOneofHide1_FMessage2:
		encoder.AppendJSONKey("f_message2")
		if err = encoder.AppendValueInterface(ov.FMessage2); err != nil {
			return nil, err
		}
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType03.(type) {
	case *TypeOneofHide1_FEnum1:
		encoder.AppendJSONKey("f_enum1")
		encoder.AppendValueInt32(int32(ov.FEnum1.Number()))
	case *TypeOneofHide1_FEnum2:
		encoder.AppendJSONKey("f_enum2")
		encoder.AppendValueInt32(int32(ov.FEnum2.Number()))
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneType04.(type) {
	case *TypeOneofHide1_FDuration1:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration1")
		if err = encoder.AppendValueInterface(ov.FDuration1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *TypeOneofHide1_FDuration2:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendObjectBegin()
		encoder.AppendJSONKey("f_duration2")
		if err = encoder.AppendValueInterface(ov.FDuration2); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendJSONKey("OneType04")
		encoder.AppendValueNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneofHide1 in file tests/proto/cases/types/type_oneof.proto
func (x *TypeOneofHide1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeOneofHide1) is nil")
	}
	var oneOfIsFill_OneType01 bool
	var oneOfIsFill_OneType02 bool
	var oneOfIsFill_OneType03 bool
	var oneOfIsFill_OneType04 bool

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var ok bool
			var ot *TypeOneofHide1_FString1
			if ot, ok = x.OneType01.(*TypeOneofHide1_FString1); !ok {
				ot = new(TypeOneofHide1_FString1)
			}
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true
			ot.FString1 = vv
			x.OneType01 = ot
		case "f_string2":
			var ok bool
			var ot *TypeOneofHide1_FString2
			if ot, ok = x.OneType01.(*TypeOneofHide1_FString2); !ok {
				ot = new(TypeOneofHide1_FString2)
			}
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType01 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType01 = true
			ot.FString2 = vv
			x.OneType01 = ot
		case "f_message1":
			var ok bool
			var ot *TypeOneofHide1_FMessage1
			if ot, ok = x.OneType02.(*TypeOneofHide1_FMessage1); !ok {
				ot = new(TypeOneofHide1_FMessage1)
			}
			var vv *MessageOneof1
			initFN := func() interface{} {
				if ot.FMessage1 != nil {
					vv = ot.FMessage1
				} else {
					vv = new(MessageOneof1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true
			ot.FMessage1 = vv
			x.OneType02 = ot
		case "f_message2":
			var ok bool
			var ot *TypeOneofHide1_FMessage2
			if ot, ok = x.OneType02.(*TypeOneofHide1_FMessage2); !ok {
				ot = new(TypeOneofHide1_FMessage2)
			}
			var vv *MessageOneof1
			initFN := func() interface{} {
				if ot.FMessage2 != nil {
					vv = ot.FMessage2
				} else {
					vv = new(MessageOneof1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType02 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType02 = true
			ot.FMessage2 = vv
			x.OneType02 = ot
		case "f_enum1":
			var ok bool
			var ot *TypeOneofHide1_FEnum1
			if ot, ok = x.OneType03.(*TypeOneofHide1_FEnum1); !ok {
				ot = new(TypeOneofHide1_FEnum1)
			}
			var vv EnumOneof1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
			vv = EnumOneof1(v1)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true
			ot.FEnum1 = vv
			x.OneType03 = ot
		case "f_enum2":
			var ok bool
			var ot *TypeOneofHide1_FEnum2
			if ot, ok = x.OneType03.(*TypeOneofHide1_FEnum2); !ok {
				ot = new(TypeOneofHide1_FEnum2)
			}
			var vv EnumOneof1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, EnumOneof1_name)
			vv = EnumOneof1(v1)
			if err != nil {
				return err
			}
			if oneOfIsFill_OneType03 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneType03 = true
			ot.FEnum2 = vv
			x.OneType03 = ot
		case "OneType04":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneType04 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration1":
					var ok bool
					var ot *TypeOneofHide1_FDuration1
					if ot, ok = x.OneType04.(*TypeOneofHide1_FDuration1); !ok {
						ot = new(TypeOneofHide1_FDuration1)
					}
					var vv *durationpb.Duration
					initFN := func() interface{} {
						if ot.FDuration1 != nil {
							vv = ot.FDuration1
						} else {
							vv = new(durationpb.Duration)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType04 = true
					ot.FDuration1 = vv
					x.OneType04 = ot
				case "f_duration2":
					var ok bool
					var ot *TypeOneofHide1_FDuration2
					if ot, ok = x.OneType04.(*TypeOneofHide1_FDuration2); !ok {
						ot = new(TypeOneofHide1_FDuration2)
					}
					var vv *durationpb.Duration
					initFN := func() interface{} {
						if ot.FDuration2 != nil {
							vv = ot.FDuration2
						} else {
							vv = new(durationpb.Duration)
						}
						return vv
					}
					err = decoder.ReadValueInterface(jsonKey, initFN)
					if err != nil {
						return err
					}
					if oneOfIsFill_OneType04 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneType04 = true
					ot.FDuration2 = vv
					x.OneType04 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				}
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}
