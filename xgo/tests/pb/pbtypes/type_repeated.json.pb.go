// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/types/type_repeated.proto

package pbtypes

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message MessageRepeated1 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MessageRepeated1 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageRepeated1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed1 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1_Embed1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed1 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1_Embed1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageRepeated1_Embed1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed2 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1_Embed1_Embed2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed2 in file tests/proto/cases/types/type_repeated.proto
func (x *MessageRepeated1_Embed1_Embed2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageRepeated1_Embed1_Embed2) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeRepeated1 in file tests/proto/cases/types/type_repeated.proto
func (x *TypeRepeated1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(794)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	if x.FString1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FString1 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_string2")
	if x.FString2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FString2 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int32")
	if x.FInt32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int64")
	if x.FInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint32")
	if x.FUint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint64")
	if x.FUint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint32")
	if x.FSint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint64")
	if x.FSint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed32")
	if x.FSfixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed64")
	if x.FSfixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed32")
	if x.FFixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed64")
	if x.FFixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_float")
	if x.FFloat != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFloat {
			encoder.AppendValueFloat32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_double")
	if x.FDouble != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FDouble {
			encoder.AppendValueFloat64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_bool1")
	if x.FBool1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FBool1 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_bytes1")
	if x.FBytes1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FBytes1 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum1")
	if x.FEnum1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum1 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum2")
	if x.FEnum2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum2 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum3")
	if x.FEnum3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum3 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum4")
	if x.FEnum4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum4 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum5")
	if x.FEnum5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum5 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum6")
	if x.FEnum6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FEnum6 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_duration1")
	if x.FDuration1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FDuration1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_duration2")
	if x.FDuration2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FDuration2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_timestamp1")
	if x.FTimestamp1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FTimestamp1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_timestamp2")
	if x.FTimestamp2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FTimestamp2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_any1")
	if x.FAny1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FAny1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_any2")
	if x.FAny2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FAny2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message1")
	if x.FMessage1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message2")
	if x.FMessage2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message3")
	if x.FMessage3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage3 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message4")
	if x.FMessage4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage4 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message5")
	if x.FMessage5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage5 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message6")
	if x.FMessage6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage6 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message7")
	if x.FMessage7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage7 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message8")
	if x.FMessage8 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage8 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message9")
	if x.FMessage9 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FMessage9 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeRepeated1 in file tests/proto/cases/types/type_repeated.proto
func (x *TypeRepeated1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeRepeated1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.FString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.FString1 == nil {
					x.FString1 = make([]string, 0)
				}
				i := 0
				length := len(x.FString1)
			LOOP_LIST_f_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_string1
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FString1[i] = vv
					} else {
						x.FString1 = append(x.FString1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_string1
					}
				}
				if i < length {
					x.FString1 = x.FString1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_string2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.FString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.FString2 == nil {
					x.FString2 = make([]string, 0)
				}
				i := 0
				length := len(x.FString2)
			LOOP_LIST_f_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_string2
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FString2[i] = vv
					} else {
						x.FString2 = append(x.FString2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_string2
					}
				}
				if i < length {
					x.FString2 = x.FString2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_int32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.FInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.FInt32 == nil {
					x.FInt32 = make([]int32, 0)
				}
				i := 0
				length := len(x.FInt32)
			LOOP_LIST_f_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_int32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FInt32[i] = vv
					} else {
						x.FInt32 = append(x.FInt32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_int32
					}
				}
				if i < length {
					x.FInt32 = x.FInt32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_int64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.FInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.FInt64 == nil {
					x.FInt64 = make([]int64, 0)
				}
				i := 0
				length := len(x.FInt64)
			LOOP_LIST_f_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_int64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FInt64[i] = vv
					} else {
						x.FInt64 = append(x.FInt64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_int64
					}
				}
				if i < length {
					x.FInt64 = x.FInt64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_uint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				} else {
					x.FUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				}
				if x.FUint32 == nil {
					x.FUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(x.FUint32)
			LOOP_LIST_f_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_uint32
					}
					vv, _err := decoder.ReadArrayElemUint32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FUint32[i] = vv
					} else {
						x.FUint32 = append(x.FUint32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_uint32
					}
				}
				if i < length {
					x.FUint32 = x.FUint32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_uint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				} else {
					x.FUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				}
				if x.FUint64 == nil {
					x.FUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(x.FUint64)
			LOOP_LIST_f_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_uint64
					}
					vv, _err := decoder.ReadArrayElemUint64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FUint64[i] = vv
					} else {
						x.FUint64 = append(x.FUint64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_uint64
					}
				}
				if i < length {
					x.FUint64 = x.FUint64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_sint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.FSint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.FSint32 == nil {
					x.FSint32 = make([]int32, 0)
				}
				i := 0
				length := len(x.FSint32)
			LOOP_LIST_f_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_sint32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FSint32[i] = vv
					} else {
						x.FSint32 = append(x.FSint32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_sint32
					}
				}
				if i < length {
					x.FSint32 = x.FSint32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_sint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.FSint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.FSint64 == nil {
					x.FSint64 = make([]int64, 0)
				}
				i := 0
				length := len(x.FSint64)
			LOOP_LIST_f_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_sint64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FSint64[i] = vv
					} else {
						x.FSint64 = append(x.FSint64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_sint64
					}
				}
				if i < length {
					x.FSint64 = x.FSint64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_sfixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.FSfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.FSfixed32 == nil {
					x.FSfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(x.FSfixed32)
			LOOP_LIST_f_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_sfixed32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FSfixed32[i] = vv
					} else {
						x.FSfixed32 = append(x.FSfixed32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_sfixed32
					}
				}
				if i < length {
					x.FSfixed32 = x.FSfixed32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_sfixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.FSfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.FSfixed64 == nil {
					x.FSfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(x.FSfixed64)
			LOOP_LIST_f_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_sfixed64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FSfixed64[i] = vv
					} else {
						x.FSfixed64 = append(x.FSfixed64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_sfixed64
					}
				}
				if i < length {
					x.FSfixed64 = x.FSfixed64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_fixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				} else {
					x.FFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				}
				if x.FFixed32 == nil {
					x.FFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(x.FFixed32)
			LOOP_LIST_f_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_fixed32
					}
					vv, _err := decoder.ReadArrayElemUint32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FFixed32[i] = vv
					} else {
						x.FFixed32 = append(x.FFixed32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_fixed32
					}
				}
				if i < length {
					x.FFixed32 = x.FFixed32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_fixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				} else {
					x.FFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				}
				if x.FFixed64 == nil {
					x.FFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(x.FFixed64)
			LOOP_LIST_f_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_fixed64
					}
					vv, _err := decoder.ReadArrayElemUint64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FFixed64[i] = vv
					} else {
						x.FFixed64 = append(x.FFixed64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_fixed64
					}
				}
				if i < length {
					x.FFixed64 = x.FFixed64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_float":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), jsonKey)
				} else {
					x.FFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), jsonKey)
				}
				if x.FFloat == nil {
					x.FFloat = make([]float32, 0)
				}
				i := 0
				length := len(x.FFloat)
			LOOP_LIST_f_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_float
					}
					vv, _err := decoder.ReadArrayElemFloat32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FFloat[i] = vv
					} else {
						x.FFloat = append(x.FFloat, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_float
					}
				}
				if i < length {
					x.FFloat = x.FFloat[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_double":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), jsonKey)
				} else {
					x.FDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), jsonKey)
				}
				if x.FDouble == nil {
					x.FDouble = make([]float64, 0)
				}
				i := 0
				length := len(x.FDouble)
			LOOP_LIST_f_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_double
					}
					vv, _err := decoder.ReadArrayElemFloat64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FDouble[i] = vv
					} else {
						x.FDouble = append(x.FDouble, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_double
					}
				}
				if i < length {
					x.FDouble = x.FDouble[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_bool1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				} else {
					x.FBool1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				}
				if x.FBool1 == nil {
					x.FBool1 = make([]bool, 0)
				}
				i := 0
				length := len(x.FBool1)
			LOOP_LIST_f_bool1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_bool1
					}
					vv, _err := decoder.ReadArrayElemBool(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FBool1[i] = vv
					} else {
						x.FBool1 = append(x.FBool1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_bool1
					}
				}
				if i < length {
					x.FBool1 = x.FBool1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_bytes1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				} else {
					x.FBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				}
				if x.FBytes1 == nil {
					x.FBytes1 = make([][]byte, 0)
				}
				i := 0
				length := len(x.FBytes1)
			LOOP_LIST_f_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_bytes1
					}
					vv, _err := decoder.ReadArrayElemBytes(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FBytes1[i] = vv
					} else {
						x.FBytes1 = append(x.FBytes1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_bytes1
					}
				}
				if i < length {
					x.FBytes1 = x.FBytes1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumRepeated1", string(value), jsonKey)
				} else {
					x.FEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumRepeated1", string(value), jsonKey)
				}
				if x.FEnum1 == nil {
					x.FEnum1 = make([]EnumRepeated1, 0)
				}
				i := 0
				length := len(x.FEnum1)
			LOOP_LIST_f_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum1
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, EnumRepeated1_name)
					vv := EnumRepeated1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum1[i] = vv
					} else {
						x.FEnum1 = append(x.FEnum1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum1
					}
				}
				if i < length {
					x.FEnum1 = x.FEnum1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Enum1", string(value), jsonKey)
				} else {
					x.FEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Enum1", string(value), jsonKey)
				}
				if x.FEnum2 == nil {
					x.FEnum2 = make([]pbexternal.Enum1, 0)
				}
				i := 0
				length := len(x.FEnum2)
			LOOP_LIST_f_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum2
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, pbexternal.Enum1_name)
					vv := pbexternal.Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum2[i] = vv
					} else {
						x.FEnum2 = append(x.FEnum2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum2
					}
				}
				if i < length {
					x.FEnum2 = x.FEnum2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Embed_Enum1", string(value), jsonKey)
				} else {
					x.FEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Embed_Enum1", string(value), jsonKey)
				}
				if x.FEnum3 == nil {
					x.FEnum3 = make([]pbexternal.Embed_Enum1, 0)
				}
				i := 0
				length := len(x.FEnum3)
			LOOP_LIST_f_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum3
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, pbexternal.Embed_Enum1_name)
					vv := pbexternal.Embed_Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum3[i] = vv
					} else {
						x.FEnum3 = append(x.FEnum3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum3
					}
				}
				if i < length {
					x.FEnum3 = x.FEnum3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Embed_Message_Enum1", string(value), jsonKey)
				} else {
					x.FEnum4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []pbexternal.Embed_Message_Enum1", string(value), jsonKey)
				}
				if x.FEnum4 == nil {
					x.FEnum4 = make([]pbexternal.Embed_Message_Enum1, 0)
				}
				i := 0
				length := len(x.FEnum4)
			LOOP_LIST_f_enum4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum4
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, pbexternal.Embed_Message_Enum1_name)
					vv := pbexternal.Embed_Message_Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum4[i] = vv
					} else {
						x.FEnum4 = append(x.FEnum4, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum4
					}
				}
				if i < length {
					x.FEnum4 = x.FEnum4[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumCommon1", string(value), jsonKey)
				} else {
					x.FEnum5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []EnumCommon1", string(value), jsonKey)
				}
				if x.FEnum5 == nil {
					x.FEnum5 = make([]EnumCommon1, 0)
				}
				i := 0
				length := len(x.FEnum5)
			LOOP_LIST_f_enum5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum5
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, EnumCommon1_name)
					vv := EnumCommon1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum5[i] = vv
					} else {
						x.FEnum5 = append(x.FEnum5, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum5
					}
				}
				if i < length {
					x.FEnum5 = x.FEnum5[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_enum6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []MessageCommon1_Enum1", string(value), jsonKey)
				} else {
					x.FEnum6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []MessageCommon1_Enum1", string(value), jsonKey)
				}
				if x.FEnum6 == nil {
					x.FEnum6 = make([]MessageCommon1_Enum1, 0)
				}
				i := 0
				length := len(x.FEnum6)
			LOOP_LIST_f_enum6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_enum6
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, MessageCommon1_Enum1_name)
					vv := MessageCommon1_Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.FEnum6[i] = vv
					} else {
						x.FEnum6 = append(x.FEnum6, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_enum6
					}
				}
				if i < length {
					x.FEnum6 = x.FEnum6[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_duration1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*durationpb.Duration", string(value), jsonKey)
				} else {
					x.FDuration1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*durationpb.Duration", string(value), jsonKey)
				}
				if x.FDuration1 == nil {
					x.FDuration1 = make([]*durationpb.Duration, 0)
				}
				i := 0
				length := len(x.FDuration1)
			LOOP_LIST_f_duration1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_duration1
					}
					var vv *durationpb.Duration
					if i < length {
						vv = x.FDuration1[i]
					}
					if vv == nil {
						vv = new(durationpb.Duration)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FDuration1[i] = vv
					} else {
						x.FDuration1 = append(x.FDuration1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_duration1
					}
				}
				if i < length {
					x.FDuration1 = x.FDuration1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_duration2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*durationpb.Duration", string(value), jsonKey)
				} else {
					x.FDuration2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*durationpb.Duration", string(value), jsonKey)
				}
				if x.FDuration2 == nil {
					x.FDuration2 = make([]*durationpb.Duration, 0)
				}
				i := 0
				length := len(x.FDuration2)
			LOOP_LIST_f_duration2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_duration2
					}
					var vv *durationpb.Duration
					if i < length {
						vv = x.FDuration2[i]
					}
					if vv == nil {
						vv = new(durationpb.Duration)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FDuration2[i] = vv
					} else {
						x.FDuration2 = append(x.FDuration2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_duration2
					}
				}
				if i < length {
					x.FDuration2 = x.FDuration2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_timestamp1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*timestamppb.Timestamp", string(value), jsonKey)
				} else {
					x.FTimestamp1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*timestamppb.Timestamp", string(value), jsonKey)
				}
				if x.FTimestamp1 == nil {
					x.FTimestamp1 = make([]*timestamppb.Timestamp, 0)
				}
				i := 0
				length := len(x.FTimestamp1)
			LOOP_LIST_f_timestamp1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_timestamp1
					}
					var vv *timestamppb.Timestamp
					if i < length {
						vv = x.FTimestamp1[i]
					}
					if vv == nil {
						vv = new(timestamppb.Timestamp)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FTimestamp1[i] = vv
					} else {
						x.FTimestamp1 = append(x.FTimestamp1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_timestamp1
					}
				}
				if i < length {
					x.FTimestamp1 = x.FTimestamp1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_timestamp2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*timestamppb.Timestamp", string(value), jsonKey)
				} else {
					x.FTimestamp2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*timestamppb.Timestamp", string(value), jsonKey)
				}
				if x.FTimestamp2 == nil {
					x.FTimestamp2 = make([]*timestamppb.Timestamp, 0)
				}
				i := 0
				length := len(x.FTimestamp2)
			LOOP_LIST_f_timestamp2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_timestamp2
					}
					var vv *timestamppb.Timestamp
					if i < length {
						vv = x.FTimestamp2[i]
					}
					if vv == nil {
						vv = new(timestamppb.Timestamp)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FTimestamp2[i] = vv
					} else {
						x.FTimestamp2 = append(x.FTimestamp2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_timestamp2
					}
				}
				if i < length {
					x.FTimestamp2 = x.FTimestamp2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_any1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*anypb.Any", string(value), jsonKey)
				} else {
					x.FAny1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*anypb.Any", string(value), jsonKey)
				}
				if x.FAny1 == nil {
					x.FAny1 = make([]*anypb.Any, 0)
				}
				i := 0
				length := len(x.FAny1)
			LOOP_LIST_f_any1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_any1
					}
					var vv *anypb.Any
					if i < length {
						vv = x.FAny1[i]
					}
					if vv == nil {
						vv = new(anypb.Any)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FAny1[i] = vv
					} else {
						x.FAny1 = append(x.FAny1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_any1
					}
				}
				if i < length {
					x.FAny1 = x.FAny1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_any2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*anypb.Any", string(value), jsonKey)
				} else {
					x.FAny2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*anypb.Any", string(value), jsonKey)
				}
				if x.FAny2 == nil {
					x.FAny2 = make([]*anypb.Any, 0)
				}
				i := 0
				length := len(x.FAny2)
			LOOP_LIST_f_any2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_any2
					}
					var vv *anypb.Any
					if i < length {
						vv = x.FAny2[i]
					}
					if vv == nil {
						vv = new(anypb.Any)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FAny2[i] = vv
					} else {
						x.FAny2 = append(x.FAny2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_any2
					}
				}
				if i < length {
					x.FAny2 = x.FAny2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1", string(value), jsonKey)
				} else {
					x.FMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1", string(value), jsonKey)
				}
				if x.FMessage1 == nil {
					x.FMessage1 = make([]*MessageRepeated1, 0)
				}
				i := 0
				length := len(x.FMessage1)
			LOOP_LIST_f_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message1
					}
					var vv *MessageRepeated1
					if i < length {
						vv = x.FMessage1[i]
					}
					if vv == nil {
						vv = new(MessageRepeated1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage1[i] = vv
					} else {
						x.FMessage1 = append(x.FMessage1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message1
					}
				}
				if i < length {
					x.FMessage1 = x.FMessage1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1_Embed1", string(value), jsonKey)
				} else {
					x.FMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1_Embed1", string(value), jsonKey)
				}
				if x.FMessage2 == nil {
					x.FMessage2 = make([]*MessageRepeated1_Embed1, 0)
				}
				i := 0
				length := len(x.FMessage2)
			LOOP_LIST_f_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message2
					}
					var vv *MessageRepeated1_Embed1
					if i < length {
						vv = x.FMessage2[i]
					}
					if vv == nil {
						vv = new(MessageRepeated1_Embed1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage2[i] = vv
					} else {
						x.FMessage2 = append(x.FMessage2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message2
					}
				}
				if i < length {
					x.FMessage2 = x.FMessage2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1_Embed1_Embed2", string(value), jsonKey)
				} else {
					x.FMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageRepeated1_Embed1_Embed2", string(value), jsonKey)
				}
				if x.FMessage3 == nil {
					x.FMessage3 = make([]*MessageRepeated1_Embed1_Embed2, 0)
				}
				i := 0
				length := len(x.FMessage3)
			LOOP_LIST_f_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message3
					}
					var vv *MessageRepeated1_Embed1_Embed2
					if i < length {
						vv = x.FMessage3[i]
					}
					if vv == nil {
						vv = new(MessageRepeated1_Embed1_Embed2)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage3[i] = vv
					} else {
						x.FMessage3 = append(x.FMessage3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message3
					}
				}
				if i < length {
					x.FMessage3 = x.FMessage3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1", string(value), jsonKey)
				} else {
					x.FMessage4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1", string(value), jsonKey)
				}
				if x.FMessage4 == nil {
					x.FMessage4 = make([]*pbexternal.Message1, 0)
				}
				i := 0
				length := len(x.FMessage4)
			LOOP_LIST_f_message4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message4
					}
					var vv *pbexternal.Message1
					if i < length {
						vv = x.FMessage4[i]
					}
					if vv == nil {
						vv = new(pbexternal.Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage4[i] = vv
					} else {
						x.FMessage4 = append(x.FMessage4, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message4
					}
				}
				if i < length {
					x.FMessage4 = x.FMessage4[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1_Embed1", string(value), jsonKey)
				} else {
					x.FMessage5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1_Embed1", string(value), jsonKey)
				}
				if x.FMessage5 == nil {
					x.FMessage5 = make([]*pbexternal.Message1_Embed1, 0)
				}
				i := 0
				length := len(x.FMessage5)
			LOOP_LIST_f_message5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message5
					}
					var vv *pbexternal.Message1_Embed1
					if i < length {
						vv = x.FMessage5[i]
					}
					if vv == nil {
						vv = new(pbexternal.Message1_Embed1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage5[i] = vv
					} else {
						x.FMessage5 = append(x.FMessage5, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message5
					}
				}
				if i < length {
					x.FMessage5 = x.FMessage5[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1_Embed1_Embed2", string(value), jsonKey)
				} else {
					x.FMessage6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*pbexternal.Message1_Embed1_Embed2", string(value), jsonKey)
				}
				if x.FMessage6 == nil {
					x.FMessage6 = make([]*pbexternal.Message1_Embed1_Embed2, 0)
				}
				i := 0
				length := len(x.FMessage6)
			LOOP_LIST_f_message6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message6
					}
					var vv *pbexternal.Message1_Embed1_Embed2
					if i < length {
						vv = x.FMessage6[i]
					}
					if vv == nil {
						vv = new(pbexternal.Message1_Embed1_Embed2)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage6[i] = vv
					} else {
						x.FMessage6 = append(x.FMessage6, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message6
					}
				}
				if i < length {
					x.FMessage6 = x.FMessage6[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1", string(value), jsonKey)
				} else {
					x.FMessage7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1", string(value), jsonKey)
				}
				if x.FMessage7 == nil {
					x.FMessage7 = make([]*MessageCommon1, 0)
				}
				i := 0
				length := len(x.FMessage7)
			LOOP_LIST_f_message7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message7
					}
					var vv *MessageCommon1
					if i < length {
						vv = x.FMessage7[i]
					}
					if vv == nil {
						vv = new(MessageCommon1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage7[i] = vv
					} else {
						x.FMessage7 = append(x.FMessage7, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message7
					}
				}
				if i < length {
					x.FMessage7 = x.FMessage7[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message8":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1_Embed1", string(value), jsonKey)
				} else {
					x.FMessage8 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1_Embed1", string(value), jsonKey)
				}
				if x.FMessage8 == nil {
					x.FMessage8 = make([]*MessageCommon1_Embed1, 0)
				}
				i := 0
				length := len(x.FMessage8)
			LOOP_LIST_f_message8:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message8
					}
					var vv *MessageCommon1_Embed1
					if i < length {
						vv = x.FMessage8[i]
					}
					if vv == nil {
						vv = new(MessageCommon1_Embed1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage8[i] = vv
					} else {
						x.FMessage8 = append(x.FMessage8, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message8
					}
				}
				if i < length {
					x.FMessage8 = x.FMessage8[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "f_message9":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1_Embed1_Embed2", string(value), jsonKey)
				} else {
					x.FMessage9 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*MessageCommon1_Embed1_Embed2", string(value), jsonKey)
				}
				if x.FMessage9 == nil {
					x.FMessage9 = make([]*MessageCommon1_Embed1_Embed2, 0)
				}
				i := 0
				length := len(x.FMessage9)
			LOOP_LIST_f_message9:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_f_message9
					}
					var vv *MessageCommon1_Embed1_Embed2
					if i < length {
						vv = x.FMessage9[i]
					}
					if vv == nil {
						vv = new(MessageCommon1_Embed1_Embed2)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.FMessage9[i] = vv
					} else {
						x.FMessage9 = append(x.FMessage9, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_f_message9
					}
				}
				if i < length {
					x.FMessage9 = x.FMessage9[:i]
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
