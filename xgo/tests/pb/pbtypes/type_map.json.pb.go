// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/types/type_map.proto

package pbtypes

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	pbexternal "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message MessageMap1 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message MessageMap1 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageMap1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
	// Loop to scan object.
LOOP_SCAN:
	for {
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch { // match the JSON KEY
		case jsonKey == "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed1 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1_Embed1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed1 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1_Embed1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageMap1_Embed1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
	// Loop to scan object.
LOOP_SCAN:
	for {
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch { // match the JSON KEY
		case jsonKey == "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message Embed2 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1_Embed1_Embed2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Embed2 in file tests/proto/cases/types/type_map.proto
func (x *MessageMap1_Embed1_Embed2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*MessageMap1_Embed1_Embed2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
	// Loop to scan object.
LOOP_SCAN:
	for {
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch { // match the JSON KEY
		case jsonKey == "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeMap1 in file tests/proto/cases/types/type_map.proto
func (x *TypeMap1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(794)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	if x.FString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_string2")
	if x.FString2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FString2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int32")
	if x.FInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int64")
	if x.FInt64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint32")
	if x.FUint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint64")
	if x.FUint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint32")
	if x.FSint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint64")
	if x.FSint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed32")
	if x.FSfixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed64")
	if x.FSfixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed32")
	if x.FFixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed64")
	if x.FFixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_float")
	if x.FFloat != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFloat {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_double")
	if x.FDouble != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDouble {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_bool1")
	if x.FBool1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FBool1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_bytes1")
	if x.FBytes1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FBytes1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum1")
	if x.FEnum1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum2")
	if x.FEnum2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum3")
	if x.FEnum3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum4")
	if x.FEnum4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum4 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum5")
	if x.FEnum5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum5 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_enum6")
	if x.FEnum6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FEnum6 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_duration1")
	if x.FDuration1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDuration1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_duration2")
	if x.FDuration2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDuration2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_timestamp1")
	if x.FTimestamp1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FTimestamp1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_timestamp2")
	if x.FTimestamp2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FTimestamp2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_any1")
	if x.FAny1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FAny1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_any2")
	if x.FAny2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FAny2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message1")
	if x.FMessage1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message2")
	if x.FMessage2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message3")
	if x.FMessage3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage3 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message4")
	if x.FMessage4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage4 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message5")
	if x.FMessage5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage5 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message6")
	if x.FMessage6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage6 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message7")
	if x.FMessage7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage7 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message8")
	if x.FMessage8 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage8 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_message9")
	if x.FMessage9 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FMessage9 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeMap1 in file tests/proto/cases/types/type_map.proto
func (x *TypeMap1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeMap1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
	// Loop to scan object.
LOOP_SCAN:
	for {
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch { // match the JSON KEY
		case jsonKey == "f_string1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FString1 = nil
				continue LOOP_SCAN
			}
			if x.FString1 == nil {
				x.FString1 = make(map[string]string)
			}
		LOOP_MAP_f_string1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_string1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.FString1[mapKey] = mapVal
			}
		case jsonKey == "f_string2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FString2 = nil
				continue LOOP_SCAN
			}
			if x.FString2 == nil {
				x.FString2 = make(map[string]string)
			}
		LOOP_MAP_f_string2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_string2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.FString2[mapKey] = mapVal
			}
		case jsonKey == "f_int32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32 = nil
				continue LOOP_SCAN
			}
			if x.FInt32 == nil {
				x.FInt32 = make(map[string]int32)
			}
		LOOP_MAP_f_int32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_int32
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FInt32[mapKey] = mapVal
			}
		case jsonKey == "f_int64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64 = nil
				continue LOOP_SCAN
			}
			if x.FInt64 == nil {
				x.FInt64 = make(map[string]int64)
			}
		LOOP_MAP_f_int64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_int64
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FInt64[mapKey] = mapVal
			}
		case jsonKey == "f_uint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32 = nil
				continue LOOP_SCAN
			}
			if x.FUint32 == nil {
				x.FUint32 = make(map[string]uint32)
			}
		LOOP_MAP_f_uint32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_uint32
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.FUint32[mapKey] = mapVal
			}
		case jsonKey == "f_uint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64 = nil
				continue LOOP_SCAN
			}
			if x.FUint64 == nil {
				x.FUint64 = make(map[string]uint64)
			}
		LOOP_MAP_f_uint64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_uint64
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.FUint64[mapKey] = mapVal
			}
		case jsonKey == "f_sint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32 = nil
				continue LOOP_SCAN
			}
			if x.FSint32 == nil {
				x.FSint32 = make(map[string]int32)
			}
		LOOP_MAP_f_sint32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sint32
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FSint32[mapKey] = mapVal
			}
		case jsonKey == "f_sint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64 = nil
				continue LOOP_SCAN
			}
			if x.FSint64 == nil {
				x.FSint64 = make(map[string]int64)
			}
		LOOP_MAP_f_sint64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sint64
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FSint64[mapKey] = mapVal
			}
		case jsonKey == "f_sfixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32 = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32 == nil {
				x.FSfixed32 = make(map[string]int32)
			}
		LOOP_MAP_f_sfixed32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sfixed32
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FSfixed32[mapKey] = mapVal
			}
		case jsonKey == "f_sfixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64 = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64 == nil {
				x.FSfixed64 = make(map[string]int64)
			}
		LOOP_MAP_f_sfixed64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sfixed64
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FSfixed64[mapKey] = mapVal
			}
		case jsonKey == "f_fixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32 = nil
				continue LOOP_SCAN
			}
			if x.FFixed32 == nil {
				x.FFixed32 = make(map[string]uint32)
			}
		LOOP_MAP_f_fixed32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_fixed32
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.FFixed32[mapKey] = mapVal
			}
		case jsonKey == "f_fixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64 = nil
				continue LOOP_SCAN
			}
			if x.FFixed64 == nil {
				x.FFixed64 = make(map[string]uint64)
			}
		LOOP_MAP_f_fixed64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_fixed64
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.FFixed64[mapKey] = mapVal
			}
		case jsonKey == "f_float":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat = nil
				continue LOOP_SCAN
			}
			if x.FFloat == nil {
				x.FFloat = make(map[string]float32)
			}
		LOOP_MAP_f_float:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_float
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal float32
				mapVal, err = decoder.ReadMapValueFloat32(jsonKey)
				if err != nil {
					return err
				}
				x.FFloat[mapKey] = mapVal
			}
		case jsonKey == "f_double":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble = nil
				continue LOOP_SCAN
			}
			if x.FDouble == nil {
				x.FDouble = make(map[string]float64)
			}
		LOOP_MAP_f_double:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_double
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal float64
				mapVal, err = decoder.ReadMapValueFloat64(jsonKey)
				if err != nil {
					return err
				}
				x.FDouble[mapKey] = mapVal
			}
		case jsonKey == "f_bool1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBool1 = nil
				continue LOOP_SCAN
			}
			if x.FBool1 == nil {
				x.FBool1 = make(map[string]bool)
			}
		LOOP_MAP_f_bool1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_bool1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal bool
				mapVal, err = decoder.ReadMapValueBool(jsonKey)
				if err != nil {
					return err
				}
				x.FBool1[mapKey] = mapVal
			}
		case jsonKey == "f_bytes1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBytes1 = nil
				continue LOOP_SCAN
			}
			if x.FBytes1 == nil {
				x.FBytes1 = make(map[string][]byte)
			}
		LOOP_MAP_f_bytes1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_bytes1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal []byte
				mapVal, err = decoder.ReadMapValueBytes(jsonKey)
				if err != nil {
					return err
				}
				x.FBytes1[mapKey] = mapVal
			}
		case jsonKey == "f_enum1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum1 = nil
				continue LOOP_SCAN
			}
			if x.FEnum1 == nil {
				x.FEnum1 = make(map[string]EnumMap1)
			}
		LOOP_MAP_f_enum1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal EnumMap1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, EnumMap1_name)
				mapVal = EnumMap1(v1)
				if err != nil {
					return err
				}
				x.FEnum1[mapKey] = mapVal
			}
		case jsonKey == "f_enum2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum2 = nil
				continue LOOP_SCAN
			}
			if x.FEnum2 == nil {
				x.FEnum2 = make(map[string]pbexternal.Enum1)
			}
		LOOP_MAP_f_enum2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal pbexternal.Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, pbexternal.Enum1_name)
				mapVal = pbexternal.Enum1(v1)
				if err != nil {
					return err
				}
				x.FEnum2[mapKey] = mapVal
			}
		case jsonKey == "f_enum3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum3 = nil
				continue LOOP_SCAN
			}
			if x.FEnum3 == nil {
				x.FEnum3 = make(map[string]pbexternal.Embed_Enum1)
			}
		LOOP_MAP_f_enum3:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum3
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal pbexternal.Embed_Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, pbexternal.Embed_Enum1_name)
				mapVal = pbexternal.Embed_Enum1(v1)
				if err != nil {
					return err
				}
				x.FEnum3[mapKey] = mapVal
			}
		case jsonKey == "f_enum4":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum4 = nil
				continue LOOP_SCAN
			}
			if x.FEnum4 == nil {
				x.FEnum4 = make(map[string]pbexternal.Embed_Message_Enum1)
			}
		LOOP_MAP_f_enum4:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum4
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal pbexternal.Embed_Message_Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, pbexternal.Embed_Message_Enum1_name)
				mapVal = pbexternal.Embed_Message_Enum1(v1)
				if err != nil {
					return err
				}
				x.FEnum4[mapKey] = mapVal
			}
		case jsonKey == "f_enum5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum5 = nil
				continue LOOP_SCAN
			}
			if x.FEnum5 == nil {
				x.FEnum5 = make(map[string]EnumCommon1)
			}
		LOOP_MAP_f_enum5:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum5
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal EnumCommon1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, EnumCommon1_name)
				mapVal = EnumCommon1(v1)
				if err != nil {
					return err
				}
				x.FEnum5[mapKey] = mapVal
			}
		case jsonKey == "f_enum6":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FEnum6 = nil
				continue LOOP_SCAN
			}
			if x.FEnum6 == nil {
				x.FEnum6 = make(map[string]MessageCommon1_Enum1)
			}
		LOOP_MAP_f_enum6:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_enum6
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal MessageCommon1_Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, MessageCommon1_Enum1_name)
				mapVal = MessageCommon1_Enum1(v1)
				if err != nil {
					return err
				}
				x.FEnum6[mapKey] = mapVal
			}
		case jsonKey == "f_duration1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDuration1 = nil
				continue LOOP_SCAN
			}
			if x.FDuration1 == nil {
				x.FDuration1 = make(map[string]*durationpb.Duration)
			}
		LOOP_MAP_f_duration1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_duration1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *durationpb.Duration
				initFN := func() interface{} {
					mapVal = x.FDuration1[mapKey]
					if mapVal == nil {
						mapVal = new(durationpb.Duration)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FDuration1[mapKey] = mapVal
			}
		case jsonKey == "f_duration2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDuration2 = nil
				continue LOOP_SCAN
			}
			if x.FDuration2 == nil {
				x.FDuration2 = make(map[string]*durationpb.Duration)
			}
		LOOP_MAP_f_duration2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_duration2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *durationpb.Duration
				initFN := func() interface{} {
					mapVal = x.FDuration2[mapKey]
					if mapVal == nil {
						mapVal = new(durationpb.Duration)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FDuration2[mapKey] = mapVal
			}
		case jsonKey == "f_timestamp1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FTimestamp1 = nil
				continue LOOP_SCAN
			}
			if x.FTimestamp1 == nil {
				x.FTimestamp1 = make(map[string]*timestamppb.Timestamp)
			}
		LOOP_MAP_f_timestamp1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_timestamp1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *timestamppb.Timestamp
				initFN := func() interface{} {
					mapVal = x.FTimestamp1[mapKey]
					if mapVal == nil {
						mapVal = new(timestamppb.Timestamp)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FTimestamp1[mapKey] = mapVal
			}
		case jsonKey == "f_timestamp2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FTimestamp2 = nil
				continue LOOP_SCAN
			}
			if x.FTimestamp2 == nil {
				x.FTimestamp2 = make(map[string]*timestamppb.Timestamp)
			}
		LOOP_MAP_f_timestamp2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_timestamp2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *timestamppb.Timestamp
				initFN := func() interface{} {
					mapVal = x.FTimestamp2[mapKey]
					if mapVal == nil {
						mapVal = new(timestamppb.Timestamp)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FTimestamp2[mapKey] = mapVal
			}
		case jsonKey == "f_any1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FAny1 = nil
				continue LOOP_SCAN
			}
			if x.FAny1 == nil {
				x.FAny1 = make(map[string]*anypb.Any)
			}
		LOOP_MAP_f_any1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_any1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *anypb.Any
				initFN := func() interface{} {
					mapVal = x.FAny1[mapKey]
					if mapVal == nil {
						mapVal = new(anypb.Any)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FAny1[mapKey] = mapVal
			}
		case jsonKey == "f_any2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FAny2 = nil
				continue LOOP_SCAN
			}
			if x.FAny2 == nil {
				x.FAny2 = make(map[string]*anypb.Any)
			}
		LOOP_MAP_f_any2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_any2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *anypb.Any
				initFN := func() interface{} {
					mapVal = x.FAny2[mapKey]
					if mapVal == nil {
						mapVal = new(anypb.Any)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FAny2[mapKey] = mapVal
			}
		case jsonKey == "f_message1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage1 = nil
				continue LOOP_SCAN
			}
			if x.FMessage1 == nil {
				x.FMessage1 = make(map[string]*MessageMap1)
			}
		LOOP_MAP_f_message1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageMap1
				initFN := func() interface{} {
					mapVal = x.FMessage1[mapKey]
					if mapVal == nil {
						mapVal = new(MessageMap1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage1[mapKey] = mapVal
			}
		case jsonKey == "f_message2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage2 = nil
				continue LOOP_SCAN
			}
			if x.FMessage2 == nil {
				x.FMessage2 = make(map[string]*MessageMap1_Embed1)
			}
		LOOP_MAP_f_message2:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message2
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageMap1_Embed1
				initFN := func() interface{} {
					mapVal = x.FMessage2[mapKey]
					if mapVal == nil {
						mapVal = new(MessageMap1_Embed1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage2[mapKey] = mapVal
			}
		case jsonKey == "f_message3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage3 = nil
				continue LOOP_SCAN
			}
			if x.FMessage3 == nil {
				x.FMessage3 = make(map[string]*MessageMap1_Embed1_Embed2)
			}
		LOOP_MAP_f_message3:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message3
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageMap1_Embed1_Embed2
				initFN := func() interface{} {
					mapVal = x.FMessage3[mapKey]
					if mapVal == nil {
						mapVal = new(MessageMap1_Embed1_Embed2)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage3[mapKey] = mapVal
			}
		case jsonKey == "f_message4":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage4 = nil
				continue LOOP_SCAN
			}
			if x.FMessage4 == nil {
				x.FMessage4 = make(map[string]*pbexternal.Message1)
			}
		LOOP_MAP_f_message4:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message4
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *pbexternal.Message1
				initFN := func() interface{} {
					mapVal = x.FMessage4[mapKey]
					if mapVal == nil {
						mapVal = new(pbexternal.Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage4[mapKey] = mapVal
			}
		case jsonKey == "f_message5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage5 = nil
				continue LOOP_SCAN
			}
			if x.FMessage5 == nil {
				x.FMessage5 = make(map[string]*pbexternal.Message1_Embed1)
			}
		LOOP_MAP_f_message5:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message5
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *pbexternal.Message1_Embed1
				initFN := func() interface{} {
					mapVal = x.FMessage5[mapKey]
					if mapVal == nil {
						mapVal = new(pbexternal.Message1_Embed1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage5[mapKey] = mapVal
			}
		case jsonKey == "f_message6":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage6 = nil
				continue LOOP_SCAN
			}
			if x.FMessage6 == nil {
				x.FMessage6 = make(map[string]*pbexternal.Message1_Embed1_Embed2)
			}
		LOOP_MAP_f_message6:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message6
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *pbexternal.Message1_Embed1_Embed2
				initFN := func() interface{} {
					mapVal = x.FMessage6[mapKey]
					if mapVal == nil {
						mapVal = new(pbexternal.Message1_Embed1_Embed2)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage6[mapKey] = mapVal
			}
		case jsonKey == "f_message7":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage7 = nil
				continue LOOP_SCAN
			}
			if x.FMessage7 == nil {
				x.FMessage7 = make(map[string]*MessageCommon1)
			}
		LOOP_MAP_f_message7:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message7
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageCommon1
				initFN := func() interface{} {
					mapVal = x.FMessage7[mapKey]
					if mapVal == nil {
						mapVal = new(MessageCommon1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage7[mapKey] = mapVal
			}
		case jsonKey == "f_message8":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage8 = nil
				continue LOOP_SCAN
			}
			if x.FMessage8 == nil {
				x.FMessage8 = make(map[string]*MessageCommon1_Embed1)
			}
		LOOP_MAP_f_message8:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message8
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageCommon1_Embed1
				initFN := func() interface{} {
					mapVal = x.FMessage8[mapKey]
					if mapVal == nil {
						mapVal = new(MessageCommon1_Embed1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage8[mapKey] = mapVal
			}
		case jsonKey == "f_message9":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FMessage9 = nil
				continue LOOP_SCAN
			}
			if x.FMessage9 == nil {
				x.FMessage9 = make(map[string]*MessageCommon1_Embed1_Embed2)
			}
		LOOP_MAP_f_message9:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_message9
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *MessageCommon1_Embed1_Embed2
				initFN := func() interface{} {
					mapVal = x.FMessage9[mapKey]
					if mapVal == nil {
						mapVal = new(MessageCommon1_Embed1_Embed2)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.FMessage9[mapKey] = mapVal
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeMap2 in file tests/proto/cases/types/type_map.proto
func (x *TypeMap2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(232)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	if x.FString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int32")
	if x.FInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32 {
			encoder.AppendMapKeyInt32(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_int64")
	if x.FInt64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64 {
			encoder.AppendMapKeyInt64(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint32")
	if x.FUint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32 {
			encoder.AppendMapKeyUInt32(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_uint64")
	if x.FUint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64 {
			encoder.AppendMapKeyUInt64(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint32")
	if x.FSint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32 {
			encoder.AppendMapKeyInt32(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sint64")
	if x.FSint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64 {
			encoder.AppendMapKeyInt64(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed32")
	if x.FSfixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32 {
			encoder.AppendMapKeyInt32(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_sfixed64")
	if x.FSfixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64 {
			encoder.AppendMapKeyInt64(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed32")
	if x.FFixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32 {
			encoder.AppendMapKeyUInt32(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("f_fixed64")
	if x.FFixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64 {
			encoder.AppendMapKeyUInt64(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeMap2 in file tests/proto/cases/types/type_map.proto
func (x *TypeMap2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbtypes.(*TypeMap2) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
	// Loop to scan object.
LOOP_SCAN:
	for {
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch { // match the JSON KEY
		case jsonKey == "f_string1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FString1 = nil
				continue LOOP_SCAN
			}
			if x.FString1 == nil {
				x.FString1 = make(map[string]string)
			}
		LOOP_MAP_f_string1:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_string1
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.FString1[mapKey] = mapVal
			}
		case jsonKey == "f_int32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32 = nil
				continue LOOP_SCAN
			}
			if x.FInt32 == nil {
				x.FInt32 = make(map[int32]int32)
			}
		LOOP_MAP_f_int32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_int32
				}
				var mapKey int32
				mapKey, err = decoder.ReadMapKeyInt32(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FInt32[mapKey] = mapVal
			}
		case jsonKey == "f_int64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64 = nil
				continue LOOP_SCAN
			}
			if x.FInt64 == nil {
				x.FInt64 = make(map[int64]int64)
			}
		LOOP_MAP_f_int64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_int64
				}
				var mapKey int64
				mapKey, err = decoder.ReadMapKeyInt64(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FInt64[mapKey] = mapVal
			}
		case jsonKey == "f_uint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32 = nil
				continue LOOP_SCAN
			}
			if x.FUint32 == nil {
				x.FUint32 = make(map[uint32]uint32)
			}
		LOOP_MAP_f_uint32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_uint32
				}
				var mapKey uint32
				mapKey, err = decoder.ReadMapKeyUint32(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.FUint32[mapKey] = mapVal
			}
		case jsonKey == "f_uint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64 = nil
				continue LOOP_SCAN
			}
			if x.FUint64 == nil {
				x.FUint64 = make(map[uint64]uint64)
			}
		LOOP_MAP_f_uint64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_uint64
				}
				var mapKey uint64
				mapKey, err = decoder.ReadMapKeyUint64(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.FUint64[mapKey] = mapVal
			}
		case jsonKey == "f_sint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32 = nil
				continue LOOP_SCAN
			}
			if x.FSint32 == nil {
				x.FSint32 = make(map[int32]int32)
			}
		LOOP_MAP_f_sint32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sint32
				}
				var mapKey int32
				mapKey, err = decoder.ReadMapKeyInt32(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FSint32[mapKey] = mapVal
			}
		case jsonKey == "f_sint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64 = nil
				continue LOOP_SCAN
			}
			if x.FSint64 == nil {
				x.FSint64 = make(map[int64]int64)
			}
		LOOP_MAP_f_sint64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sint64
				}
				var mapKey int64
				mapKey, err = decoder.ReadMapKeyInt64(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FSint64[mapKey] = mapVal
			}
		case jsonKey == "f_sfixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32 = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32 == nil {
				x.FSfixed32 = make(map[int32]int32)
			}
		LOOP_MAP_f_sfixed32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sfixed32
				}
				var mapKey int32
				mapKey, err = decoder.ReadMapKeyInt32(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.FSfixed32[mapKey] = mapVal
			}
		case jsonKey == "f_sfixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64 = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64 == nil {
				x.FSfixed64 = make(map[int64]int64)
			}
		LOOP_MAP_f_sfixed64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_sfixed64
				}
				var mapKey int64
				mapKey, err = decoder.ReadMapKeyInt64(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.FSfixed64[mapKey] = mapVal
			}
		case jsonKey == "f_fixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32 = nil
				continue LOOP_SCAN
			}
			if x.FFixed32 == nil {
				x.FFixed32 = make(map[uint32]uint32)
			}
		LOOP_MAP_f_fixed32:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_fixed32
				}
				var mapKey uint32
				mapKey, err = decoder.ReadMapKeyUint32(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.FFixed32[mapKey] = mapVal
			}
		case jsonKey == "f_fixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64 = nil
				continue LOOP_SCAN
			}
			if x.FFixed64 == nil {
				x.FFixed64 = make(map[uint64]uint64)
			}
		LOOP_MAP_f_fixed64:
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break LOOP_MAP_f_fixed64
				}
				var mapKey uint64
				mapKey, err = decoder.ReadMapKeyUint64(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.FFixed64[mapKey] = mapVal
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}
