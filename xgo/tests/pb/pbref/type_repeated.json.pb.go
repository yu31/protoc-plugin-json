// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/references/type_repeated.proto

package pbref

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message TypeRepeated1 in file tests/proto/cases/references/type_repeated.proto
func (x *TypeRepeated1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(584)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_int32a")
	if x.FInt32A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt32A {
			encoder.AppendLiteralInt32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int32b")
	if x.FInt32B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt32B {
			encoder.AppendLiteralInt32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64a")
	if x.FInt64A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt64A {
			encoder.AppendLiteralInt64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64b")
	if x.FInt64B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FInt64B {
			encoder.AppendLiteralInt64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32a")
	if x.FUint32A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint32A {
			encoder.AppendLiteralUint32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32b")
	if x.FUint32B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint32B {
			encoder.AppendLiteralUint32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64a")
	if x.FUint64A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint64A {
			encoder.AppendLiteralUint64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64b")
	if x.FUint64B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FUint64B {
			encoder.AppendLiteralUint64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32a")
	if x.FSint32A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint32A {
			encoder.AppendLiteralInt32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32b")
	if x.FSint32B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint32B {
			encoder.AppendLiteralInt32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64a")
	if x.FSint64A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint64A {
			encoder.AppendLiteralInt64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64b")
	if x.FSint64B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSint64B {
			encoder.AppendLiteralInt64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32a")
	if x.FSfixed32A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed32A {
			encoder.AppendLiteralInt32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32b")
	if x.FSfixed32B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed32B {
			encoder.AppendLiteralInt32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64a")
	if x.FSfixed64A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed64A {
			encoder.AppendLiteralInt64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64b")
	if x.FSfixed64B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FSfixed64B {
			encoder.AppendLiteralInt64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32a")
	if x.FFixed32A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed32A {
			encoder.AppendLiteralUint32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32b")
	if x.FFixed32B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed32B {
			encoder.AppendLiteralUint32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64a")
	if x.FFixed64A != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed64A {
			encoder.AppendLiteralUint64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64b")
	if x.FFixed64B != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFixed64B {
			encoder.AppendLiteralUint64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float1")
	if x.FFloat1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFloat1 {
			encoder.AppendLiteralFloat32(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float2")
	if x.FFloat2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FFloat2 {
			encoder.AppendLiteralFloat32(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double1")
	if x.FDouble1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FDouble1 {
			encoder.AppendLiteralFloat64(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double2")
	if x.FDouble2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FDouble2 {
			encoder.AppendLiteralFloat64(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_bool1")
	if x.FBool1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FBool1 {
			encoder.AppendLiteralBool(ri, false)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_bool2")
	if x.FBool2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.FBool2 {
			encoder.AppendLiteralBool(ri, true)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeRepeated1 in file tests/proto/cases/references/type_repeated.proto
func (x *TypeRepeated1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbref.(*TypeRepeated1) is nil")
	}
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32A = nil
				continue LOOP_SCAN
			}
			if x.FInt32A == nil {
				x.FInt32A = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FInt32A) {
					x.FInt32A = append(x.FInt32A, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FInt32A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FInt32A = x.FInt32A[:i]
		case "f_int32b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32B = nil
				continue LOOP_SCAN
			}
			if x.FInt32B == nil {
				x.FInt32B = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FInt32B) {
					x.FInt32B = append(x.FInt32B, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FInt32B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FInt32B = x.FInt32B[:i]
		case "f_int64a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64A = nil
				continue LOOP_SCAN
			}
			if x.FInt64A == nil {
				x.FInt64A = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FInt64A) {
					x.FInt64A = append(x.FInt64A, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FInt64A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FInt64A = x.FInt64A[:i]
		case "f_int64b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64B = nil
				continue LOOP_SCAN
			}
			if x.FInt64B == nil {
				x.FInt64B = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FInt64B) {
					x.FInt64B = append(x.FInt64B, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FInt64B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FInt64B = x.FInt64B[:i]
		case "f_uint32a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32A = nil
				continue LOOP_SCAN
			}
			if x.FUint32A == nil {
				x.FUint32A = make([]uint32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				if i >= len(x.FUint32A) {
					x.FUint32A = append(x.FUint32A, vv)
				}
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FUint32A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FUint32A = x.FUint32A[:i]
		case "f_uint32b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32B = nil
				continue LOOP_SCAN
			}
			if x.FUint32B == nil {
				x.FUint32B = make([]uint32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				if i >= len(x.FUint32B) {
					x.FUint32B = append(x.FUint32B, vv)
				}
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FUint32B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FUint32B = x.FUint32B[:i]
		case "f_uint64a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64A = nil
				continue LOOP_SCAN
			}
			if x.FUint64A == nil {
				x.FUint64A = make([]uint64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				if i >= len(x.FUint64A) {
					x.FUint64A = append(x.FUint64A, vv)
				}
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FUint64A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FUint64A = x.FUint64A[:i]
		case "f_uint64b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64B = nil
				continue LOOP_SCAN
			}
			if x.FUint64B == nil {
				x.FUint64B = make([]uint64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				if i >= len(x.FUint64B) {
					x.FUint64B = append(x.FUint64B, vv)
				}
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FUint64B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FUint64B = x.FUint64B[:i]
		case "f_sint32a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32A = nil
				continue LOOP_SCAN
			}
			if x.FSint32A == nil {
				x.FSint32A = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FSint32A) {
					x.FSint32A = append(x.FSint32A, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSint32A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSint32A = x.FSint32A[:i]
		case "f_sint32b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32B = nil
				continue LOOP_SCAN
			}
			if x.FSint32B == nil {
				x.FSint32B = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FSint32B) {
					x.FSint32B = append(x.FSint32B, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSint32B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSint32B = x.FSint32B[:i]
		case "f_sint64a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64A = nil
				continue LOOP_SCAN
			}
			if x.FSint64A == nil {
				x.FSint64A = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FSint64A) {
					x.FSint64A = append(x.FSint64A, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSint64A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSint64A = x.FSint64A[:i]
		case "f_sint64b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64B = nil
				continue LOOP_SCAN
			}
			if x.FSint64B == nil {
				x.FSint64B = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FSint64B) {
					x.FSint64B = append(x.FSint64B, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSint64B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSint64B = x.FSint64B[:i]
		case "f_sfixed32a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32A == nil {
				x.FSfixed32A = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FSfixed32A) {
					x.FSfixed32A = append(x.FSfixed32A, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed32A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSfixed32A = x.FSfixed32A[:i]
		case "f_sfixed32b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32B == nil {
				x.FSfixed32B = make([]int32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				if i >= len(x.FSfixed32B) {
					x.FSfixed32B = append(x.FSfixed32B, vv)
				}
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed32B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSfixed32B = x.FSfixed32B[:i]
		case "f_sfixed64a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64A == nil {
				x.FSfixed64A = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FSfixed64A) {
					x.FSfixed64A = append(x.FSfixed64A, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed64A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSfixed64A = x.FSfixed64A[:i]
		case "f_sfixed64b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64B == nil {
				x.FSfixed64B = make([]int64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				if i >= len(x.FSfixed64B) {
					x.FSfixed64B = append(x.FSfixed64B, vv)
				}
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed64B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FSfixed64B = x.FSfixed64B[:i]
		case "f_fixed32a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32A = nil
				continue LOOP_SCAN
			}
			if x.FFixed32A == nil {
				x.FFixed32A = make([]uint32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				if i >= len(x.FFixed32A) {
					x.FFixed32A = append(x.FFixed32A, vv)
				}
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FFixed32A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFixed32A = x.FFixed32A[:i]
		case "f_fixed32b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32B = nil
				continue LOOP_SCAN
			}
			if x.FFixed32B == nil {
				x.FFixed32B = make([]uint32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				if i >= len(x.FFixed32B) {
					x.FFixed32B = append(x.FFixed32B, vv)
				}
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FFixed32B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFixed32B = x.FFixed32B[:i]
		case "f_fixed64a":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64A = nil
				continue LOOP_SCAN
			}
			if x.FFixed64A == nil {
				x.FFixed64A = make([]uint64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				if i >= len(x.FFixed64A) {
					x.FFixed64A = append(x.FFixed64A, vv)
				}
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FFixed64A[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFixed64A = x.FFixed64A[:i]
		case "f_fixed64b":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64B = nil
				continue LOOP_SCAN
			}
			if x.FFixed64B == nil {
				x.FFixed64B = make([]uint64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				if i >= len(x.FFixed64B) {
					x.FFixed64B = append(x.FFixed64B, vv)
				}
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FFixed64B[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFixed64B = x.FFixed64B[:i]
		case "f_float1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat1 = nil
				continue LOOP_SCAN
			}
			if x.FFloat1 == nil {
				x.FFloat1 = make([]float32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float32
				if i >= len(x.FFloat1) {
					x.FFloat1 = append(x.FFloat1, vv)
				}
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, false); err != nil {
					return err
				}
				x.FFloat1[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFloat1 = x.FFloat1[:i]
		case "f_float2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat2 = nil
				continue LOOP_SCAN
			}
			if x.FFloat2 == nil {
				x.FFloat2 = make([]float32, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float32
				if i >= len(x.FFloat2) {
					x.FFloat2 = append(x.FFloat2, vv)
				}
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, true); err != nil {
					return err
				}
				x.FFloat2[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FFloat2 = x.FFloat2[:i]
		case "f_double1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble1 = nil
				continue LOOP_SCAN
			}
			if x.FDouble1 == nil {
				x.FDouble1 = make([]float64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float64
				if i >= len(x.FDouble1) {
					x.FDouble1 = append(x.FDouble1, vv)
				}
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, false); err != nil {
					return err
				}
				x.FDouble1[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FDouble1 = x.FDouble1[:i]
		case "f_double2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble2 = nil
				continue LOOP_SCAN
			}
			if x.FDouble2 == nil {
				x.FDouble2 = make([]float64, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float64
				if i >= len(x.FDouble2) {
					x.FDouble2 = append(x.FDouble2, vv)
				}
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, true); err != nil {
					return err
				}
				x.FDouble2[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FDouble2 = x.FDouble2[:i]
		case "f_bool1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBool1 = nil
				continue LOOP_SCAN
			}
			if x.FBool1 == nil {
				x.FBool1 = make([]bool, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv bool
				if i >= len(x.FBool1) {
					x.FBool1 = append(x.FBool1, vv)
				}
				if vv, err = decoder.ReadLiteralBool(jsonKey, false); err != nil {
					return err
				}
				x.FBool1[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FBool1 = x.FBool1[:i]
		case "f_bool2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBool2 = nil
				continue LOOP_SCAN
			}
			if x.FBool2 == nil {
				x.FBool2 = make([]bool, 0)
			}
			i := 0
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv bool
				if i >= len(x.FBool2) {
					x.FBool2 = append(x.FBool2, vv)
				}
				if vv, err = decoder.ReadLiteralBool(jsonKey, true); err != nil {
					return err
				}
				x.FBool2[i] = vv
				i++
			}
			// truncate the slice to consistent with standard library json.
			x.FBool2 = x.FBool2[:i]
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
