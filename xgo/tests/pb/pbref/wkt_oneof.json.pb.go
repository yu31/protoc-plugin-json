// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/references/wkt_oneof.proto

package pbref

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message WKTOneOf1 in file tests/proto/cases/references/wkt_oneof.proto
func (x *WKTOneOf1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(1888)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	switch ov := x.OneEnum1.(type) {
	case *WKTOneOf1_FEnumNumber1:
		encoder.AppendObjectKey("one_enum1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum_number1")
		encoder.AppendLiteralInt32(int32(ov.FEnumNumber1.Number()), false)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FEnumString1:
		encoder.AppendObjectKey("one_enum1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_enum_string1")
		encoder.AppendLiteralString(ov.FEnumString1.String())
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_enum1")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneEnum2.(type) {
	case *WKTOneOf1_FEnumNumberString1:
		encoder.AppendObjectKey("f_enum_number_string1")
		encoder.AppendLiteralInt32(int32(ov.FEnumNumberString1.Number()), true)
	case *WKTOneOf1_FEnumNumberString2:
		encoder.AppendObjectKey("f_enum_number_string2")
		encoder.AppendLiteralInt32(int32(ov.FEnumNumberString2.Number()), true)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneAny1.(type) {
	case *WKTOneOf1_FAnyNative1:
		encoder.AppendObjectKey("f_any_native1")
		if err = encoder.AppendLiteralInterface(ov.FAnyNative1); err != nil {
			return nil, err
		}
	case *WKTOneOf1_FAnyProto1:
		encoder.AppendObjectKey("f_any_proto1")
		if err = encoder.AppendWKTAnyByProto(ov.FAnyProto1); err != nil {
			return nil, err
		}
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration1.(type) {
	case *WKTOneOf1_FDurationNative1:
		encoder.AppendObjectKey("one_duration1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_native1")
		if err = encoder.AppendLiteralInterface(ov.FDurationNative1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FDurationString1:
		encoder.AppendObjectKey("one_duration1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_string1")
		encoder.AppendLiteralString(ov.FDurationString1.AsDuration().String())
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_duration1")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration2.(type) {
	case *WKTOneOf1_FDurationNanosecond1:
		encoder.AppendObjectKey("f_duration_nanosecond1")
		encoder.AppendLiteralInt64(ov.FDurationNanosecond1.AsDuration().Nanoseconds(), false)
	case *WKTOneOf1_FDurationMicrosecond1:
		encoder.AppendObjectKey("f_duration_microsecond1")
		encoder.AppendLiteralInt64(ov.FDurationMicrosecond1.AsDuration().Microseconds(), false)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration3.(type) {
	case *WKTOneOf1_FDurationMillisecond1:
		encoder.AppendObjectKey("one_duration3")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_millisecond1")
		encoder.AppendLiteralInt64(ov.FDurationMillisecond1.AsDuration().Milliseconds(), false)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FDurationSecond1:
		encoder.AppendObjectKey("one_duration3")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_second1")
		encoder.AppendLiteralFloat64(ov.FDurationSecond1.AsDuration().Seconds(), false)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_duration3")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration4.(type) {
	case *WKTOneOf1_FDurationMinute1:
		encoder.AppendObjectKey("f_duration_minute1")
		encoder.AppendLiteralFloat64(ov.FDurationMinute1.AsDuration().Minutes(), false)
	case *WKTOneOf1_FDurationHour1:
		encoder.AppendObjectKey("f_duration_hour1")
		encoder.AppendLiteralFloat64(ov.FDurationHour1.AsDuration().Hours(), false)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration5.(type) {
	case *WKTOneOf1_FDurationNanosecondString1:
		encoder.AppendObjectKey("one_duration5")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_nanosecond_string1")
		encoder.AppendLiteralInt64(ov.FDurationNanosecondString1.AsDuration().Nanoseconds(), true)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FDurationMicrosecondString1:
		encoder.AppendObjectKey("one_duration5")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_microsecond_string1")
		encoder.AppendLiteralInt64(ov.FDurationMicrosecondString1.AsDuration().Microseconds(), true)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_duration5")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration6.(type) {
	case *WKTOneOf1_FDurationMillisecondString1:
		encoder.AppendObjectKey("f_duration_millisecond_string1")
		encoder.AppendLiteralInt64(ov.FDurationMillisecondString1.AsDuration().Milliseconds(), true)
	case *WKTOneOf1_FDurationSecondString1:
		encoder.AppendObjectKey("f_duration_second_string1")
		encoder.AppendLiteralFloat64(ov.FDurationSecondString1.AsDuration().Seconds(), true)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneDuration7.(type) {
	case *WKTOneOf1_FDurationMinuteString1:
		encoder.AppendObjectKey("one_duration7")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_minute_string1")
		encoder.AppendLiteralFloat64(ov.FDurationMinuteString1.AsDuration().Minutes(), true)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FDurationHourString1:
		encoder.AppendObjectKey("one_duration7")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_duration_hour_string1")
		encoder.AppendLiteralFloat64(ov.FDurationHourString1.AsDuration().Hours(), true)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_duration7")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneTimestamp1.(type) {
	case *WKTOneOf1_FTimestampNative1:
		encoder.AppendObjectKey("one_timestamp1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_native1")
		if err = encoder.AppendLiteralInterface(ov.FTimestampNative1); err != nil {
			return nil, err
		}
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FTimestampTimeLayout1:
		encoder.AppendObjectKey("one_timestamp1")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_time_layout1")
		encoder.AppendLiteralString(ov.FTimestampTimeLayout1.AsTime().Format("2006-01-02T15:04:05Z07:00"))
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_timestamp1")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneTimestamp2.(type) {
	case *WKTOneOf1_FTimestampUnixNano1:
		encoder.AppendObjectKey("f_timestamp_unix_nano1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixNano1.AsTime().UnixNano(), false)
	case *WKTOneOf1_FTimestampUnixMicro1:
		encoder.AppendObjectKey("f_timestamp_unix_micro1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixMicro1.AsTime().UnixMicro(), false)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneTimestamp3.(type) {
	case *WKTOneOf1_FTimestampUnixMilli1:
		encoder.AppendObjectKey("one_timestamp3")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_unix_milli1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixMilli1.AsTime().UnixMilli(), false)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FTimestampUnixSec1:
		encoder.AppendObjectKey("one_timestamp3")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_unix_sec1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixSec1.AsTime().Unix(), false)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_timestamp3")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneTimestamp4.(type) {
	case *WKTOneOf1_FTimestampUnixNanoString1:
		encoder.AppendObjectKey("f_timestamp_unix_nano_string1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixNanoString1.AsTime().UnixNano(), true)
	case *WKTOneOf1_FTimestampUnixMicroString1:
		encoder.AppendObjectKey("f_timestamp_unix_micro_string1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixMicroString1.AsTime().UnixMicro(), true)
	default:
		_ = ov // to avoids unused panics
	}
	switch ov := x.OneTimestamp5.(type) {
	case *WKTOneOf1_FTimestampUnixMilliString1:
		encoder.AppendObjectKey("one_timestamp5")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_unix_milli_string1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixMilliString1.AsTime().UnixMilli(), true)
		encoder.AppendObjectEnd()
	case *WKTOneOf1_FTimestampUnixSecString1:
		encoder.AppendObjectKey("one_timestamp5")
		encoder.AppendObjectBegin()
		encoder.AppendObjectKey("f_timestamp_unix_sec_string1")
		encoder.AppendLiteralInt64(ov.FTimestampUnixSecString1.AsTime().Unix(), true)
		encoder.AppendObjectEnd()
	case nil:
		encoder.AppendObjectKey("one_timestamp5")
		encoder.AppendLiteralNULL()
	default:
		_ = ov // to avoids unused panics
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message WKTOneOf1 in file tests/proto/cases/references/wkt_oneof.proto
func (x *WKTOneOf1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbref.(*WKTOneOf1) is nil")
	}
	var (
		oneOfIsFill_OneEnum1      bool
		oneOfIsFill_OneEnum2      bool
		oneOfIsFill_OneAny1       bool
		oneOfIsFill_OneDuration1  bool
		oneOfIsFill_OneDuration2  bool
		oneOfIsFill_OneDuration3  bool
		oneOfIsFill_OneDuration4  bool
		oneOfIsFill_OneDuration5  bool
		oneOfIsFill_OneDuration6  bool
		oneOfIsFill_OneDuration7  bool
		oneOfIsFill_OneTimestamp1 bool
		oneOfIsFill_OneTimestamp2 bool
		oneOfIsFill_OneTimestamp3 bool
		oneOfIsFill_OneTimestamp4 bool
		oneOfIsFill_OneTimestamp5 bool
	)
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeReadJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "one_enum1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneEnum1 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_enum_number1":
					if oneOfIsFill_OneEnum1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneEnum1 = true

					var ok bool
					var ot *WKTOneOf1_FEnumNumber1
					if ot, ok = x.OneEnum1.(*WKTOneOf1_FEnumNumber1); !ok {
						ot = new(WKTOneOf1_FEnumNumber1)
					}
					var vv Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, false); err != nil {
						return err
					}
					vv = Enum1(v1)
					ot.FEnumNumber1 = vv
					x.OneEnum1 = ot
				case "f_enum_string1":
					if oneOfIsFill_OneEnum1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneEnum1 = true

					var ok bool
					var ot *WKTOneOf1_FEnumString1
					if ot, ok = x.OneEnum1.(*WKTOneOf1_FEnumString1); !ok {
						ot = new(WKTOneOf1_FEnumString1)
					}
					var vv Enum1
					var v1 int32
					if v1, err = decoder.ReadLiteralEnumString(jsonKey, Enum1_value); err != nil {
						return err
					}
					vv = Enum1(v1)
					ot.FEnumString1 = vv
					x.OneEnum1 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_enum_number_string1":
			if oneOfIsFill_OneEnum2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneEnum2 = true

			var ok bool
			var ot *WKTOneOf1_FEnumNumberString1
			if ot, ok = x.OneEnum2.(*WKTOneOf1_FEnumNumberString1); !ok {
				ot = new(WKTOneOf1_FEnumNumberString1)
			}
			var vv Enum1
			var v1 int32
			if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, true); err != nil {
				return err
			}
			vv = Enum1(v1)
			ot.FEnumNumberString1 = vv
			x.OneEnum2 = ot
		case "f_enum_number_string2":
			if oneOfIsFill_OneEnum2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneEnum2 = true

			var ok bool
			var ot *WKTOneOf1_FEnumNumberString2
			if ot, ok = x.OneEnum2.(*WKTOneOf1_FEnumNumberString2); !ok {
				ot = new(WKTOneOf1_FEnumNumberString2)
			}
			var vv Enum1
			var v1 int32
			if v1, err = decoder.ReadLiteralEnumNumber(jsonKey, true); err != nil {
				return err
			}
			vv = Enum1(v1)
			ot.FEnumNumberString2 = vv
			x.OneEnum2 = ot
		case "f_any_native1":
			if oneOfIsFill_OneAny1 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneAny1 = true

			var ok bool
			var ot *WKTOneOf1_FAnyNative1
			if ot, ok = x.OneAny1.(*WKTOneOf1_FAnyNative1); !ok {
				ot = new(WKTOneOf1_FAnyNative1)
			}
			var vv *anypb.Any
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if ot.FAnyNative1 != nil {
					vv = ot.FAnyNative1
				} else {
					vv = new(anypb.Any)
				}
				if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
					return err
				}
			}
			ot.FAnyNative1 = vv
			x.OneAny1 = ot
		case "f_any_proto1":
			if oneOfIsFill_OneAny1 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneAny1 = true

			var ok bool
			var ot *WKTOneOf1_FAnyProto1
			if ot, ok = x.OneAny1.(*WKTOneOf1_FAnyProto1); !ok {
				ot = new(WKTOneOf1_FAnyProto1)
			}
			var vv *anypb.Any
			if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
				return err
			}
			if !isNULL {
				if ot.FAnyProto1 != nil {
					vv = ot.FAnyProto1
				} else {
					vv = new(anypb.Any)
				}
				if err = decoder.ReadWKTAnyByProto(jsonKey, vv); err != nil {
					return err
				}
			}
			ot.FAnyProto1 = vv
			x.OneAny1 = ot
		case "one_duration1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration1 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration_native1":
					if oneOfIsFill_OneDuration1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration1 = true

					var ok bool
					var ot *WKTOneOf1_FDurationNative1
					if ot, ok = x.OneDuration1.(*WKTOneOf1_FDurationNative1); !ok {
						ot = new(WKTOneOf1_FDurationNative1)
					}
					var vv *durationpb.Duration
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FDurationNative1 != nil {
							vv = ot.FDurationNative1
						} else {
							vv = new(durationpb.Duration)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FDurationNative1 = vv
					x.OneDuration1 = ot
				case "f_duration_string1":
					if oneOfIsFill_OneDuration1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration1 = true

					var ok bool
					var ot *WKTOneOf1_FDurationString1
					if ot, ok = x.OneDuration1.(*WKTOneOf1_FDurationString1); !ok {
						ot = new(WKTOneOf1_FDurationString1)
					}
					var vv *durationpb.Duration
					if ot.FDurationString1 != nil {
						vv = ot.FDurationString1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByString(jsonKey, vv); err != nil {
						return err
					}
					ot.FDurationString1 = vv
					x.OneDuration1 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_duration_nanosecond1":
			if oneOfIsFill_OneDuration2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration2 = true

			var ok bool
			var ot *WKTOneOf1_FDurationNanosecond1
			if ot, ok = x.OneDuration2.(*WKTOneOf1_FDurationNanosecond1); !ok {
				ot = new(WKTOneOf1_FDurationNanosecond1)
			}
			var vv *durationpb.Duration
			if ot.FDurationNanosecond1 != nil {
				vv = ot.FDurationNanosecond1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationByNanoseconds(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FDurationNanosecond1 = vv
			x.OneDuration2 = ot
		case "f_duration_microsecond1":
			if oneOfIsFill_OneDuration2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration2 = true

			var ok bool
			var ot *WKTOneOf1_FDurationMicrosecond1
			if ot, ok = x.OneDuration2.(*WKTOneOf1_FDurationMicrosecond1); !ok {
				ot = new(WKTOneOf1_FDurationMicrosecond1)
			}
			var vv *durationpb.Duration
			if ot.FDurationMicrosecond1 != nil {
				vv = ot.FDurationMicrosecond1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationByMicroseconds(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FDurationMicrosecond1 = vv
			x.OneDuration2 = ot
		case "one_duration3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration3 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration_millisecond1":
					if oneOfIsFill_OneDuration3 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration3 = true

					var ok bool
					var ot *WKTOneOf1_FDurationMillisecond1
					if ot, ok = x.OneDuration3.(*WKTOneOf1_FDurationMillisecond1); !ok {
						ot = new(WKTOneOf1_FDurationMillisecond1)
					}
					var vv *durationpb.Duration
					if ot.FDurationMillisecond1 != nil {
						vv = ot.FDurationMillisecond1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByMilliseconds(jsonKey, vv, false); err != nil {
						return err
					}
					ot.FDurationMillisecond1 = vv
					x.OneDuration3 = ot
				case "f_duration_second1":
					if oneOfIsFill_OneDuration3 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration3 = true

					var ok bool
					var ot *WKTOneOf1_FDurationSecond1
					if ot, ok = x.OneDuration3.(*WKTOneOf1_FDurationSecond1); !ok {
						ot = new(WKTOneOf1_FDurationSecond1)
					}
					var vv *durationpb.Duration
					if ot.FDurationSecond1 != nil {
						vv = ot.FDurationSecond1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationBySeconds(jsonKey, vv, false); err != nil {
						return err
					}
					ot.FDurationSecond1 = vv
					x.OneDuration3 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_duration_minute1":
			if oneOfIsFill_OneDuration4 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration4 = true

			var ok bool
			var ot *WKTOneOf1_FDurationMinute1
			if ot, ok = x.OneDuration4.(*WKTOneOf1_FDurationMinute1); !ok {
				ot = new(WKTOneOf1_FDurationMinute1)
			}
			var vv *durationpb.Duration
			if ot.FDurationMinute1 != nil {
				vv = ot.FDurationMinute1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationByMinutes(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FDurationMinute1 = vv
			x.OneDuration4 = ot
		case "f_duration_hour1":
			if oneOfIsFill_OneDuration4 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration4 = true

			var ok bool
			var ot *WKTOneOf1_FDurationHour1
			if ot, ok = x.OneDuration4.(*WKTOneOf1_FDurationHour1); !ok {
				ot = new(WKTOneOf1_FDurationHour1)
			}
			var vv *durationpb.Duration
			if ot.FDurationHour1 != nil {
				vv = ot.FDurationHour1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationByHours(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FDurationHour1 = vv
			x.OneDuration4 = ot
		case "one_duration5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration5 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration_nanosecond_string1":
					if oneOfIsFill_OneDuration5 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration5 = true

					var ok bool
					var ot *WKTOneOf1_FDurationNanosecondString1
					if ot, ok = x.OneDuration5.(*WKTOneOf1_FDurationNanosecondString1); !ok {
						ot = new(WKTOneOf1_FDurationNanosecondString1)
					}
					var vv *durationpb.Duration
					if ot.FDurationNanosecondString1 != nil {
						vv = ot.FDurationNanosecondString1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByNanoseconds(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FDurationNanosecondString1 = vv
					x.OneDuration5 = ot
				case "f_duration_microsecond_string1":
					if oneOfIsFill_OneDuration5 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration5 = true

					var ok bool
					var ot *WKTOneOf1_FDurationMicrosecondString1
					if ot, ok = x.OneDuration5.(*WKTOneOf1_FDurationMicrosecondString1); !ok {
						ot = new(WKTOneOf1_FDurationMicrosecondString1)
					}
					var vv *durationpb.Duration
					if ot.FDurationMicrosecondString1 != nil {
						vv = ot.FDurationMicrosecondString1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByMicroseconds(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FDurationMicrosecondString1 = vv
					x.OneDuration5 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_duration_millisecond_string1":
			if oneOfIsFill_OneDuration6 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration6 = true

			var ok bool
			var ot *WKTOneOf1_FDurationMillisecondString1
			if ot, ok = x.OneDuration6.(*WKTOneOf1_FDurationMillisecondString1); !ok {
				ot = new(WKTOneOf1_FDurationMillisecondString1)
			}
			var vv *durationpb.Duration
			if ot.FDurationMillisecondString1 != nil {
				vv = ot.FDurationMillisecondString1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationByMilliseconds(jsonKey, vv, true); err != nil {
				return err
			}
			ot.FDurationMillisecondString1 = vv
			x.OneDuration6 = ot
		case "f_duration_second_string1":
			if oneOfIsFill_OneDuration6 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneDuration6 = true

			var ok bool
			var ot *WKTOneOf1_FDurationSecondString1
			if ot, ok = x.OneDuration6.(*WKTOneOf1_FDurationSecondString1); !ok {
				ot = new(WKTOneOf1_FDurationSecondString1)
			}
			var vv *durationpb.Duration
			if ot.FDurationSecondString1 != nil {
				vv = ot.FDurationSecondString1
			} else {
				vv = new(durationpb.Duration)
			}
			if err = decoder.ReadWKTDurationBySeconds(jsonKey, vv, true); err != nil {
				return err
			}
			ot.FDurationSecondString1 = vv
			x.OneDuration6 = ot
		case "one_duration7":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration7 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_duration_minute_string1":
					if oneOfIsFill_OneDuration7 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration7 = true

					var ok bool
					var ot *WKTOneOf1_FDurationMinuteString1
					if ot, ok = x.OneDuration7.(*WKTOneOf1_FDurationMinuteString1); !ok {
						ot = new(WKTOneOf1_FDurationMinuteString1)
					}
					var vv *durationpb.Duration
					if ot.FDurationMinuteString1 != nil {
						vv = ot.FDurationMinuteString1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByMinutes(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FDurationMinuteString1 = vv
					x.OneDuration7 = ot
				case "f_duration_hour_string1":
					if oneOfIsFill_OneDuration7 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneDuration7 = true

					var ok bool
					var ot *WKTOneOf1_FDurationHourString1
					if ot, ok = x.OneDuration7.(*WKTOneOf1_FDurationHourString1); !ok {
						ot = new(WKTOneOf1_FDurationHourString1)
					}
					var vv *durationpb.Duration
					if ot.FDurationHourString1 != nil {
						vv = ot.FDurationHourString1
					} else {
						vv = new(durationpb.Duration)
					}
					if err = decoder.ReadWKTDurationByHours(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FDurationHourString1 = vv
					x.OneDuration7 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "one_timestamp1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp1 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_timestamp_native1":
					if oneOfIsFill_OneTimestamp1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp1 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampNative1
					if ot, ok = x.OneTimestamp1.(*WKTOneOf1_FTimestampNative1); !ok {
						ot = new(WKTOneOf1_FTimestampNative1)
					}
					var vv *timestamppb.Timestamp
					if isNULL, err = decoder.NextLiteralIsNULL(jsonKey); err != nil {
						return err
					}
					if !isNULL {
						if ot.FTimestampNative1 != nil {
							vv = ot.FTimestampNative1
						} else {
							vv = new(timestamppb.Timestamp)
						}
						if err = decoder.ReadLiteralInterface(jsonKey, vv); err != nil {
							return err
						}
					}
					ot.FTimestampNative1 = vv
					x.OneTimestamp1 = ot
				case "f_timestamp_time_layout1":
					if oneOfIsFill_OneTimestamp1 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp1 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampTimeLayout1
					if ot, ok = x.OneTimestamp1.(*WKTOneOf1_FTimestampTimeLayout1); !ok {
						ot = new(WKTOneOf1_FTimestampTimeLayout1)
					}
					var vv *timestamppb.Timestamp
					if ot.FTimestampTimeLayout1 != nil {
						vv = ot.FTimestampTimeLayout1
					} else {
						vv = new(timestamppb.Timestamp)
					}
					if err = decoder.ReadWKTTimestampByString(jsonKey, vv, "2006-01-02T15:04:05Z07:00"); err != nil {
						return err
					}
					ot.FTimestampTimeLayout1 = vv
					x.OneTimestamp1 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_timestamp_unix_nano1":
			if oneOfIsFill_OneTimestamp2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneTimestamp2 = true

			var ok bool
			var ot *WKTOneOf1_FTimestampUnixNano1
			if ot, ok = x.OneTimestamp2.(*WKTOneOf1_FTimestampUnixNano1); !ok {
				ot = new(WKTOneOf1_FTimestampUnixNano1)
			}
			var vv *timestamppb.Timestamp
			if ot.FTimestampUnixNano1 != nil {
				vv = ot.FTimestampUnixNano1
			} else {
				vv = new(timestamppb.Timestamp)
			}
			if err = decoder.ReadWKTTimestampByUnixNano(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FTimestampUnixNano1 = vv
			x.OneTimestamp2 = ot
		case "f_timestamp_unix_micro1":
			if oneOfIsFill_OneTimestamp2 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneTimestamp2 = true

			var ok bool
			var ot *WKTOneOf1_FTimestampUnixMicro1
			if ot, ok = x.OneTimestamp2.(*WKTOneOf1_FTimestampUnixMicro1); !ok {
				ot = new(WKTOneOf1_FTimestampUnixMicro1)
			}
			var vv *timestamppb.Timestamp
			if ot.FTimestampUnixMicro1 != nil {
				vv = ot.FTimestampUnixMicro1
			} else {
				vv = new(timestamppb.Timestamp)
			}
			if err = decoder.ReadWKTTimestampByUnixMicro(jsonKey, vv, false); err != nil {
				return err
			}
			ot.FTimestampUnixMicro1 = vv
			x.OneTimestamp2 = ot
		case "one_timestamp3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp3 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_timestamp_unix_milli1":
					if oneOfIsFill_OneTimestamp3 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp3 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampUnixMilli1
					if ot, ok = x.OneTimestamp3.(*WKTOneOf1_FTimestampUnixMilli1); !ok {
						ot = new(WKTOneOf1_FTimestampUnixMilli1)
					}
					var vv *timestamppb.Timestamp
					if ot.FTimestampUnixMilli1 != nil {
						vv = ot.FTimestampUnixMilli1
					} else {
						vv = new(timestamppb.Timestamp)
					}
					if err = decoder.ReadWKTTimestampByUnixMilli(jsonKey, vv, false); err != nil {
						return err
					}
					ot.FTimestampUnixMilli1 = vv
					x.OneTimestamp3 = ot
				case "f_timestamp_unix_sec1":
					if oneOfIsFill_OneTimestamp3 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp3 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampUnixSec1
					if ot, ok = x.OneTimestamp3.(*WKTOneOf1_FTimestampUnixSec1); !ok {
						ot = new(WKTOneOf1_FTimestampUnixSec1)
					}
					var vv *timestamppb.Timestamp
					if ot.FTimestampUnixSec1 != nil {
						vv = ot.FTimestampUnixSec1
					} else {
						vv = new(timestamppb.Timestamp)
					}
					if err = decoder.ReadWKTTimestampByUnixSec(jsonKey, vv, false); err != nil {
						return err
					}
					ot.FTimestampUnixSec1 = vv
					x.OneTimestamp3 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		case "f_timestamp_unix_nano_string1":
			if oneOfIsFill_OneTimestamp4 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneTimestamp4 = true

			var ok bool
			var ot *WKTOneOf1_FTimestampUnixNanoString1
			if ot, ok = x.OneTimestamp4.(*WKTOneOf1_FTimestampUnixNanoString1); !ok {
				ot = new(WKTOneOf1_FTimestampUnixNanoString1)
			}
			var vv *timestamppb.Timestamp
			if ot.FTimestampUnixNanoString1 != nil {
				vv = ot.FTimestampUnixNanoString1
			} else {
				vv = new(timestamppb.Timestamp)
			}
			if err = decoder.ReadWKTTimestampByUnixNano(jsonKey, vv, true); err != nil {
				return err
			}
			ot.FTimestampUnixNanoString1 = vv
			x.OneTimestamp4 = ot
		case "f_timestamp_unix_micro_string1":
			if oneOfIsFill_OneTimestamp4 {
				return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
			}
			oneOfIsFill_OneTimestamp4 = true

			var ok bool
			var ot *WKTOneOf1_FTimestampUnixMicroString1
			if ot, ok = x.OneTimestamp4.(*WKTOneOf1_FTimestampUnixMicroString1); !ok {
				ot = new(WKTOneOf1_FTimestampUnixMicroString1)
			}
			var vv *timestamppb.Timestamp
			if ot.FTimestampUnixMicroString1 != nil {
				vv = ot.FTimestampUnixMicroString1
			} else {
				vv = new(timestamppb.Timestamp)
			}
			if err = decoder.ReadWKTTimestampByUnixMicro(jsonKey, vv, true); err != nil {
				return err
			}
			ot.FTimestampUnixMicroString1 = vv
			x.OneTimestamp4 = ot
		case "one_timestamp5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp5 = nil
				continue LOOP_SCAN
			}
			for {
				var oneofKey string
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				if oneofKey, err = decoder.ReadObjectKey(jsonKey); err != nil {
					return err
				}
				switch oneofKey { // match oneof key
				case "f_timestamp_unix_milli_string1":
					if oneOfIsFill_OneTimestamp5 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp5 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampUnixMilliString1
					if ot, ok = x.OneTimestamp5.(*WKTOneOf1_FTimestampUnixMilliString1); !ok {
						ot = new(WKTOneOf1_FTimestampUnixMilliString1)
					}
					var vv *timestamppb.Timestamp
					if ot.FTimestampUnixMilliString1 != nil {
						vv = ot.FTimestampUnixMilliString1
					} else {
						vv = new(timestamppb.Timestamp)
					}
					if err = decoder.ReadWKTTimestampByUnixMilli(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FTimestampUnixMilliString1 = vv
					x.OneTimestamp5 = ot
				case "f_timestamp_unix_sec_string1":
					if oneOfIsFill_OneTimestamp5 {
						return fmt.Errorf("json: unmarshal: the field %s is type oneof, allow contains only one", jsonKey)
					}
					oneOfIsFill_OneTimestamp5 = true

					var ok bool
					var ot *WKTOneOf1_FTimestampUnixSecString1
					if ot, ok = x.OneTimestamp5.(*WKTOneOf1_FTimestampUnixSecString1); !ok {
						ot = new(WKTOneOf1_FTimestampUnixSecString1)
					}
					var vv *timestamppb.Timestamp
					if ot.FTimestampUnixSecString1 != nil {
						vv = ot.FTimestampUnixSecString1
					} else {
						vv = new(timestamppb.Timestamp)
					}
					if err = decoder.ReadWKTTimestampByUnixSec(jsonKey, vv, true); err != nil {
						return err
					}
					ot.FTimestampUnixSecString1 = vv
					x.OneTimestamp5 = ot
				default:
					if err = decoder.DiscardValue(jsonKey); err != nil {
						return err
					}
				} // end switch
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
