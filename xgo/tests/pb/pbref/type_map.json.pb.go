// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/references/type_map.proto

package pbref

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message TypeMap1 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(552)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_int32a")
	if x.FInt32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32A {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int32b")
	if x.FInt32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64a")
	if x.FInt64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64A {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64b")
	if x.FInt64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32a")
	if x.FUint32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32A {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32b")
	if x.FUint32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32B {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64a")
	if x.FUint64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64A {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64b")
	if x.FUint64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64B {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32a")
	if x.FSint32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32A {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32b")
	if x.FSint32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64a")
	if x.FSint64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64A {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64b")
	if x.FSint64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32a")
	if x.FSfixed32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32A {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32b")
	if x.FSfixed32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64a")
	if x.FSfixed64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64A {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64b")
	if x.FSfixed64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32a")
	if x.FFixed32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32A {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32b")
	if x.FFixed32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32B {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64a")
	if x.FFixed64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64A {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64b")
	if x.FFixed64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64B {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float1")
	if x.FFloat1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFloat1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float2")
	if x.FFloat2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFloat2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double1")
	if x.FDouble1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDouble1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double2")
	if x.FDouble2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDouble2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeMap1 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbref.(*TypeMap1) is nil")
	}
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32A = nil
				continue LOOP_SCAN
			}
			if x.FInt32A == nil {
				x.FInt32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FInt32A[mk] = vv
			}
		case "f_int32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32B = nil
				continue LOOP_SCAN
			}
			if x.FInt32B == nil {
				x.FInt32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FInt32B[mk] = vv
			}
		case "f_int64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64A = nil
				continue LOOP_SCAN
			}
			if x.FInt64A == nil {
				x.FInt64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FInt64A[mk] = vv
			}
		case "f_int64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64B = nil
				continue LOOP_SCAN
			}
			if x.FInt64B == nil {
				x.FInt64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FInt64B[mk] = vv
			}
		case "f_uint32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32A = nil
				continue LOOP_SCAN
			}
			if x.FUint32A == nil {
				x.FUint32A = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FUint32A[mk] = vv
			}
		case "f_uint32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32B = nil
				continue LOOP_SCAN
			}
			if x.FUint32B == nil {
				x.FUint32B = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FUint32B[mk] = vv
			}
		case "f_uint64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64A = nil
				continue LOOP_SCAN
			}
			if x.FUint64A == nil {
				x.FUint64A = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FUint64A[mk] = vv
			}
		case "f_uint64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64B = nil
				continue LOOP_SCAN
			}
			if x.FUint64B == nil {
				x.FUint64B = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FUint64B[mk] = vv
			}
		case "f_sint32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32A = nil
				continue LOOP_SCAN
			}
			if x.FSint32A == nil {
				x.FSint32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSint32A[mk] = vv
			}
		case "f_sint32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32B = nil
				continue LOOP_SCAN
			}
			if x.FSint32B == nil {
				x.FSint32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSint32B[mk] = vv
			}
		case "f_sint64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64A = nil
				continue LOOP_SCAN
			}
			if x.FSint64A == nil {
				x.FSint64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSint64A[mk] = vv
			}
		case "f_sint64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64B = nil
				continue LOOP_SCAN
			}
			if x.FSint64B == nil {
				x.FSint64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSint64B[mk] = vv
			}
		case "f_sfixed32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32A == nil {
				x.FSfixed32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed32A[mk] = vv
			}
		case "f_sfixed32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32B == nil {
				x.FSfixed32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed32B[mk] = vv
			}
		case "f_sfixed64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64A == nil {
				x.FSfixed64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed64A[mk] = vv
			}
		case "f_sfixed64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64B == nil {
				x.FSfixed64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed64B[mk] = vv
			}
		case "f_fixed32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32A = nil
				continue LOOP_SCAN
			}
			if x.FFixed32A == nil {
				x.FFixed32A = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FFixed32A[mk] = vv
			}
		case "f_fixed32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32B = nil
				continue LOOP_SCAN
			}
			if x.FFixed32B == nil {
				x.FFixed32B = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FFixed32B[mk] = vv
			}
		case "f_fixed64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64A = nil
				continue LOOP_SCAN
			}
			if x.FFixed64A == nil {
				x.FFixed64A = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FFixed64A[mk] = vv
			}
		case "f_fixed64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64B = nil
				continue LOOP_SCAN
			}
			if x.FFixed64B == nil {
				x.FFixed64B = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FFixed64B[mk] = vv
			}
		case "f_float1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat1 = nil
				continue LOOP_SCAN
			}
			if x.FFloat1 == nil {
				x.FFloat1 = make(map[string]float32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float32
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, false); err != nil {
					return err
				}
				x.FFloat1[mk] = vv
			}
		case "f_float2":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat2 = nil
				continue LOOP_SCAN
			}
			if x.FFloat2 == nil {
				x.FFloat2 = make(map[string]float32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float32
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, true); err != nil {
					return err
				}
				x.FFloat2[mk] = vv
			}
		case "f_double1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble1 = nil
				continue LOOP_SCAN
			}
			if x.FDouble1 == nil {
				x.FDouble1 = make(map[string]float64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float64
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, false); err != nil {
					return err
				}
				x.FDouble1[mk] = vv
			}
		case "f_double2":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble2 = nil
				continue LOOP_SCAN
			}
			if x.FDouble2 == nil {
				x.FDouble2 = make(map[string]float64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float64
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, true); err != nil {
					return err
				}
				x.FDouble2[mk] = vv
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeMap2 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(584)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_int32a")
	if x.FInt32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32A {
			encoder.AppendMapKeyInt32(mk, false)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int32b")
	if x.FInt32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64a")
	if x.FInt64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64A {
			encoder.AppendMapKeyInt64(mk, false)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_int64b")
	if x.FInt64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FInt64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32a")
	if x.FUint32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32A {
			encoder.AppendMapKeyUInt32(mk, false)
			encoder.AppendLiteralUint32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint32b")
	if x.FUint32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint32B {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64a")
	if x.FUint64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64A {
			encoder.AppendMapKeyUInt64(mk, false)
			encoder.AppendLiteralUint64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_uint64b")
	if x.FUint64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FUint64B {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32a")
	if x.FSint32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32A {
			encoder.AppendMapKeyInt32(mk, false)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint32b")
	if x.FSint32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64a")
	if x.FSint64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64A {
			encoder.AppendMapKeyInt64(mk, false)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sint64b")
	if x.FSint64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSint64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32a")
	if x.FSfixed32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32A {
			encoder.AppendMapKeyInt32(mk, false)
			encoder.AppendLiteralInt32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed32b")
	if x.FSfixed32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed32B {
			encoder.AppendMapKeyInt32(mk, true)
			encoder.AppendLiteralInt32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64a")
	if x.FSfixed64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64A {
			encoder.AppendMapKeyInt64(mk, false)
			encoder.AppendLiteralInt64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_sfixed64b")
	if x.FSfixed64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FSfixed64B {
			encoder.AppendMapKeyInt64(mk, true)
			encoder.AppendLiteralInt64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32a")
	if x.FFixed32A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32A {
			encoder.AppendMapKeyUInt32(mk, false)
			encoder.AppendLiteralUint32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed32b")
	if x.FFixed32B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed32B {
			encoder.AppendMapKeyUInt32(mk, true)
			encoder.AppendLiteralUint32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64a")
	if x.FFixed64A != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64A {
			encoder.AppendMapKeyUInt64(mk, false)
			encoder.AppendLiteralUint64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_fixed64b")
	if x.FFixed64B != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFixed64B {
			encoder.AppendMapKeyUInt64(mk, true)
			encoder.AppendLiteralUint64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float1")
	if x.FFloat1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFloat1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat32(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_float2")
	if x.FFloat2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FFloat2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat32(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double1")
	if x.FDouble1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDouble1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat64(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_double2")
	if x.FDouble2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FDouble2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralFloat64(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_bool1")
	if x.FBool1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FBool1 {
			encoder.AppendMapKeyBool(mk, false)
			encoder.AppendLiteralBool(mv, false)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_bool2")
	if x.FBool2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FBool2 {
			encoder.AppendMapKeyBool(mk, true)
			encoder.AppendLiteralBool(mv, true)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeMap2 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbref.(*TypeMap2) is nil")
	}
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32A = nil
				continue LOOP_SCAN
			}
			if x.FInt32A == nil {
				x.FInt32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, false); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FInt32A[mk] = vv
			}
		case "f_int32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt32B = nil
				continue LOOP_SCAN
			}
			if x.FInt32B == nil {
				x.FInt32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FInt32B[mk] = vv
			}
		case "f_int64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64A = nil
				continue LOOP_SCAN
			}
			if x.FInt64A == nil {
				x.FInt64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, false); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FInt64A[mk] = vv
			}
		case "f_int64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FInt64B = nil
				continue LOOP_SCAN
			}
			if x.FInt64B == nil {
				x.FInt64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FInt64B[mk] = vv
			}
		case "f_uint32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32A = nil
				continue LOOP_SCAN
			}
			if x.FUint32A == nil {
				x.FUint32A = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, false); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FUint32A[mk] = vv
			}
		case "f_uint32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint32B = nil
				continue LOOP_SCAN
			}
			if x.FUint32B == nil {
				x.FUint32B = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FUint32B[mk] = vv
			}
		case "f_uint64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64A = nil
				continue LOOP_SCAN
			}
			if x.FUint64A == nil {
				x.FUint64A = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, false); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FUint64A[mk] = vv
			}
		case "f_uint64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FUint64B = nil
				continue LOOP_SCAN
			}
			if x.FUint64B == nil {
				x.FUint64B = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FUint64B[mk] = vv
			}
		case "f_sint32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32A = nil
				continue LOOP_SCAN
			}
			if x.FSint32A == nil {
				x.FSint32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, false); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSint32A[mk] = vv
			}
		case "f_sint32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint32B = nil
				continue LOOP_SCAN
			}
			if x.FSint32B == nil {
				x.FSint32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSint32B[mk] = vv
			}
		case "f_sint64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64A = nil
				continue LOOP_SCAN
			}
			if x.FSint64A == nil {
				x.FSint64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, false); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSint64A[mk] = vv
			}
		case "f_sint64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSint64B = nil
				continue LOOP_SCAN
			}
			if x.FSint64B == nil {
				x.FSint64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSint64B[mk] = vv
			}
		case "f_sfixed32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32A == nil {
				x.FSfixed32A = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, false); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed32A[mk] = vv
			}
		case "f_sfixed32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed32B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed32B == nil {
				x.FSfixed32B = make(map[int32]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int32
				if mk, err = decoder.ReadMapKeyInt32(jsonKey, true); err != nil {
					return err
				}
				var vv int32
				if vv, err = decoder.ReadLiteralInt32(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed32B[mk] = vv
			}
		case "f_sfixed64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64A = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64A == nil {
				x.FSfixed64A = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, false); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, false); err != nil {
					return err
				}
				x.FSfixed64A[mk] = vv
			}
		case "f_sfixed64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FSfixed64B = nil
				continue LOOP_SCAN
			}
			if x.FSfixed64B == nil {
				x.FSfixed64B = make(map[int64]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk int64
				if mk, err = decoder.ReadMapKeyInt64(jsonKey, true); err != nil {
					return err
				}
				var vv int64
				if vv, err = decoder.ReadLiteralInt64(jsonKey, true); err != nil {
					return err
				}
				x.FSfixed64B[mk] = vv
			}
		case "f_fixed32a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32A = nil
				continue LOOP_SCAN
			}
			if x.FFixed32A == nil {
				x.FFixed32A = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, false); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, false); err != nil {
					return err
				}
				x.FFixed32A[mk] = vv
			}
		case "f_fixed32b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed32B = nil
				continue LOOP_SCAN
			}
			if x.FFixed32B == nil {
				x.FFixed32B = make(map[uint32]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint32
				if mk, err = decoder.ReadMapKeyUint32(jsonKey, true); err != nil {
					return err
				}
				var vv uint32
				if vv, err = decoder.ReadLiteralUint32(jsonKey, true); err != nil {
					return err
				}
				x.FFixed32B[mk] = vv
			}
		case "f_fixed64a":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64A = nil
				continue LOOP_SCAN
			}
			if x.FFixed64A == nil {
				x.FFixed64A = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, false); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, false); err != nil {
					return err
				}
				x.FFixed64A[mk] = vv
			}
		case "f_fixed64b":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFixed64B = nil
				continue LOOP_SCAN
			}
			if x.FFixed64B == nil {
				x.FFixed64B = make(map[uint64]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk uint64
				if mk, err = decoder.ReadMapKeyUint64(jsonKey, true); err != nil {
					return err
				}
				var vv uint64
				if vv, err = decoder.ReadLiteralUint64(jsonKey, true); err != nil {
					return err
				}
				x.FFixed64B[mk] = vv
			}
		case "f_float1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat1 = nil
				continue LOOP_SCAN
			}
			if x.FFloat1 == nil {
				x.FFloat1 = make(map[string]float32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float32
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, false); err != nil {
					return err
				}
				x.FFloat1[mk] = vv
			}
		case "f_float2":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FFloat2 = nil
				continue LOOP_SCAN
			}
			if x.FFloat2 == nil {
				x.FFloat2 = make(map[string]float32)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float32
				if vv, err = decoder.ReadLiteralFloat32(jsonKey, true); err != nil {
					return err
				}
				x.FFloat2[mk] = vv
			}
		case "f_double1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble1 = nil
				continue LOOP_SCAN
			}
			if x.FDouble1 == nil {
				x.FDouble1 = make(map[string]float64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float64
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, false); err != nil {
					return err
				}
				x.FDouble1[mk] = vv
			}
		case "f_double2":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FDouble2 = nil
				continue LOOP_SCAN
			}
			if x.FDouble2 == nil {
				x.FDouble2 = make(map[string]float64)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv float64
				if vv, err = decoder.ReadLiteralFloat64(jsonKey, true); err != nil {
					return err
				}
				x.FDouble2[mk] = vv
			}
		case "f_bool1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBool1 = nil
				continue LOOP_SCAN
			}
			if x.FBool1 == nil {
				x.FBool1 = make(map[bool]bool)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk bool
				if mk, err = decoder.ReadMapKeyBool(jsonKey, false); err != nil {
					return err
				}
				var vv bool
				if vv, err = decoder.ReadLiteralBool(jsonKey, false); err != nil {
					return err
				}
				x.FBool1[mk] = vv
			}
		case "f_bool2":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBool2 = nil
				continue LOOP_SCAN
			}
			if x.FBool2 == nil {
				x.FBool2 = make(map[bool]bool)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk bool
				if mk, err = decoder.ReadMapKeyBool(jsonKey, true); err != nil {
					return err
				}
				var vv bool
				if vv, err = decoder.ReadLiteralBool(jsonKey, true); err != nil {
					return err
				}
				x.FBool2[mk] = vv
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeMap3 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap3) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(48)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendObjectKey("f_string1")
	if x.FString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}
	encoder.AppendObjectKey("f_bytes1")
	if x.FBytes1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.FBytes1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendLiteralBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendLiteralNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeMap3 in file tests/proto/cases/references/type_map.proto
func (x *TypeMap3) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbref.(*TypeMap3) is nil")
	}
	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_string1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FString1 = nil
				continue LOOP_SCAN
			}
			if x.FString1 == nil {
				x.FString1 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv string
				if vv, err = decoder.ReadLiteralString(jsonKey); err != nil {
					return err
				}
				x.FString1[mk] = vv
			}
		case "f_bytes1":
			if isNULL, err = decoder.BeforeReadMap(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.FBytes1 = nil
				continue LOOP_SCAN
			}
			if x.FBytes1 == nil {
				x.FBytes1 = make(map[string][]byte)
			}
			for {
				if isEnd, err = decoder.BeforeReadNext(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mk string
				if mk, err = decoder.ReadMapKeyString(jsonKey); err != nil {
					return err
				}
				var vv []byte
				if vv, err = decoder.ReadLiteralBytes(jsonKey); err != nil {
					return err
				}
				x.FBytes1[mk] = vv
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
