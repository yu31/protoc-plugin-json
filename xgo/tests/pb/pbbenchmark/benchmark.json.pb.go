// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/benchmark/benchmark.proto

package pbbenchmark

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message Message1 in file tests/proto/benchmark/benchmark.proto
func (x *Message1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Message1 in file tests/proto/benchmark/benchmark.proto
func (x *Message1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*Message1) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message BenchModelSimple in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelSimple) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(500)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)
	encoder.AppendJSONKey("f_string4")
	encoder.AppendValueString(x.FString4)
	encoder.AppendJSONKey("f_string5")
	encoder.AppendValueString(x.FString5)
	encoder.AppendJSONKey("f_string6")
	encoder.AppendValueString(x.FString6)
	encoder.AppendJSONKey("f_string7")
	encoder.AppendValueString(x.FString7)
	encoder.AppendJSONKey("f_string8")
	encoder.AppendValueString(x.FString8)
	encoder.AppendJSONKey("f_string9")
	encoder.AppendValueString(x.FString9)
	encoder.AppendJSONKey("f_int32")
	encoder.AppendValueInt32(x.FInt32)
	encoder.AppendJSONKey("f_int64")
	encoder.AppendValueInt64(x.FInt64)
	encoder.AppendJSONKey("f_uint32")
	encoder.AppendValueUint32(x.FUint32)
	encoder.AppendJSONKey("f_uint64")
	encoder.AppendValueUint64(x.FUint64)
	encoder.AppendJSONKey("f_sint32")
	encoder.AppendValueInt32(x.FSint32)
	encoder.AppendJSONKey("f_sint64")
	encoder.AppendValueInt64(x.FSint64)
	encoder.AppendJSONKey("f_sfixed32")
	encoder.AppendValueInt32(x.FSfixed32)
	encoder.AppendJSONKey("f_sfixed64")
	encoder.AppendValueInt64(x.FSfixed64)
	encoder.AppendJSONKey("f_fixed32")
	encoder.AppendValueUint32(x.FFixed32)
	encoder.AppendJSONKey("f_fixed64")
	encoder.AppendValueUint64(x.FFixed64)
	encoder.AppendJSONKey("f_float")
	encoder.AppendValueFloat32(x.FFloat)
	encoder.AppendJSONKey("f_double")
	encoder.AppendValueFloat64(x.FDouble)
	encoder.AppendJSONKey("f_bool1")
	encoder.AppendValueBool(x.FBool1)
	encoder.AppendJSONKey("f_bool2")
	encoder.AppendValueBool(x.FBool2)
	encoder.AppendJSONKey("f_bool3")
	encoder.AppendValueBool(x.FBool3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message BenchModelSimple in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelSimple) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*BenchModelSimple) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		case "f_string4":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString4 = vv
		case "f_string5":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString5 = vv
		case "f_string6":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString6 = vv
		case "f_string7":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString7 = vv
		case "f_string8":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString8 = vv
		case "f_string9":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString9 = vv
		case "f_int32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FInt32 = vv
		case "f_int64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FInt64 = vv
		case "f_uint32":
			var vv uint32
			vv, err = decoder.ReadValueUint32(jsonKey)
			if err != nil {
				return err
			}
			x.FUint32 = vv
		case "f_uint64":
			var vv uint64
			vv, err = decoder.ReadValueUint64(jsonKey)
			if err != nil {
				return err
			}
			x.FUint64 = vv
		case "f_sint32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FSint32 = vv
		case "f_sint64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FSint64 = vv
		case "f_sfixed32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FSfixed32 = vv
		case "f_sfixed64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FSfixed64 = vv
		case "f_fixed32":
			var vv uint32
			vv, err = decoder.ReadValueUint32(jsonKey)
			if err != nil {
				return err
			}
			x.FFixed32 = vv
		case "f_fixed64":
			var vv uint64
			vv, err = decoder.ReadValueUint64(jsonKey)
			if err != nil {
				return err
			}
			x.FFixed64 = vv
		case "f_float":
			var vv float32
			vv, err = decoder.ReadValueFloat32(jsonKey)
			if err != nil {
				return err
			}
			x.FFloat = vv
		case "f_double":
			var vv float64
			vv, err = decoder.ReadValueFloat64(jsonKey)
			if err != nil {
				return err
			}
			x.FDouble = vv
		case "f_bool1":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool1 = vv
		case "f_bool2":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool2 = vv
		case "f_bool3":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool3 = vv
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message BenchModelComplex in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelComplex) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(3492)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)
	encoder.AppendJSONKey("f_string4")
	encoder.AppendValueString(x.FString4)
	encoder.AppendJSONKey("f_string5")
	encoder.AppendValueString(x.FString5)
	encoder.AppendJSONKey("f_string6")
	encoder.AppendValueString(x.FString6)
	encoder.AppendJSONKey("f_string7")
	encoder.AppendValueString(x.FString7)
	encoder.AppendJSONKey("f_string8")
	encoder.AppendValueString(x.FString8)
	encoder.AppendJSONKey("f_string9")
	encoder.AppendValueString(x.FString9)
	encoder.AppendJSONKey("f_int32")
	encoder.AppendValueInt32(x.FInt32)
	encoder.AppendJSONKey("f_int64")
	encoder.AppendValueInt64(x.FInt64)
	encoder.AppendJSONKey("f_uint32")
	encoder.AppendValueUint32(x.FUint32)
	encoder.AppendJSONKey("f_uint64")
	encoder.AppendValueUint64(x.FUint64)
	encoder.AppendJSONKey("f_sint32")
	encoder.AppendValueInt32(x.FSint32)
	encoder.AppendJSONKey("f_sint64")
	encoder.AppendValueInt64(x.FSint64)
	encoder.AppendJSONKey("f_sfixed32")
	encoder.AppendValueInt32(x.FSfixed32)
	encoder.AppendJSONKey("f_sfixed64")
	encoder.AppendValueInt64(x.FSfixed64)
	encoder.AppendJSONKey("f_fixed32")
	encoder.AppendValueUint32(x.FFixed32)
	encoder.AppendJSONKey("f_fixed64")
	encoder.AppendValueUint64(x.FFixed64)
	encoder.AppendJSONKey("f_float")
	encoder.AppendValueFloat32(x.FFloat)
	encoder.AppendJSONKey("f_double")
	encoder.AppendValueFloat64(x.FDouble)
	encoder.AppendJSONKey("f_bool1")
	encoder.AppendValueBool(x.FBool1)
	encoder.AppendJSONKey("f_bool2")
	encoder.AppendValueBool(x.FBool2)
	encoder.AppendJSONKey("f_bool3")
	encoder.AppendValueBool(x.FBool3)
	encoder.AppendJSONKey("f_bytes1")
	encoder.AppendValueBytes(x.FBytes1)
	encoder.AppendJSONKey("f_bytes2")
	encoder.AppendValueBytes(x.FBytes2)
	encoder.AppendJSONKey("f_bytes3")
	encoder.AppendValueBytes(x.FBytes3)
	encoder.AppendJSONKey("f_enum1")
	encoder.AppendValueInt32(int32(x.FEnum1.Number()))
	encoder.AppendJSONKey("f_enum2")
	encoder.AppendValueInt32(int32(x.FEnum2.Number()))
	encoder.AppendJSONKey("f_enum3")
	encoder.AppendValueInt32(int32(x.FEnum3.Number()))
	encoder.AppendJSONKey("f_enum4")
	encoder.AppendValueInt32(int32(x.FEnum4.Number()))
	encoder.AppendJSONKey("f_enum5")
	encoder.AppendValueInt32(int32(x.FEnum5.Number()))
	encoder.AppendJSONKey("f_enum6")
	encoder.AppendValueInt32(int32(x.FEnum6.Number()))
	encoder.AppendJSONKey("f_enum7")
	encoder.AppendValueInt32(int32(x.FEnum7.Number()))
	encoder.AppendJSONKey("f_message1")
	err = encoder.AppendValueInterface(x.FMessage1)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message2")
	err = encoder.AppendValueInterface(x.FMessage2)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message3")
	err = encoder.AppendValueInterface(x.FMessage3)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message4")
	err = encoder.AppendValueInterface(x.FMessage4)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message5")
	err = encoder.AppendValueInterface(x.FMessage5)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message6")
	err = encoder.AppendValueInterface(x.FMessage6)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message7")
	err = encoder.AppendValueInterface(x.FMessage7)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_string1")
	encoder.AppendPointerString(x.PString1)
	encoder.AppendJSONKey("p_string2")
	encoder.AppendPointerString(x.PString2)
	encoder.AppendJSONKey("p_string3")
	encoder.AppendPointerString(x.PString3)
	encoder.AppendJSONKey("p_string4")
	encoder.AppendPointerString(x.PString4)
	encoder.AppendJSONKey("p_string5")
	encoder.AppendPointerString(x.PString5)
	encoder.AppendJSONKey("p_string6")
	encoder.AppendPointerString(x.PString6)
	encoder.AppendJSONKey("p_string7")
	encoder.AppendPointerString(x.PString7)
	encoder.AppendJSONKey("p_string8")
	encoder.AppendPointerString(x.PString8)
	encoder.AppendJSONKey("p_string9")
	encoder.AppendPointerString(x.PString9)
	encoder.AppendJSONKey("p_int32")
	encoder.AppendPointerInt32(x.PInt32)
	encoder.AppendJSONKey("p_int64")
	encoder.AppendPointerInt64(x.PInt64)
	encoder.AppendJSONKey("p_uint32")
	encoder.AppendPointerUint32(x.PUint32)
	encoder.AppendJSONKey("p_uint64")
	encoder.AppendPointerUint64(x.PUint64)
	encoder.AppendJSONKey("p_sint32")
	encoder.AppendPointerInt32(x.PSint32)
	encoder.AppendJSONKey("p_sint64")
	encoder.AppendPointerInt64(x.PSint64)
	encoder.AppendJSONKey("p_sfixed32")
	encoder.AppendPointerInt32(x.PSfixed32)
	encoder.AppendJSONKey("p_sfixed64")
	encoder.AppendPointerInt64(x.PSfixed64)
	encoder.AppendJSONKey("p_fixed32")
	encoder.AppendPointerUint32(x.PFixed32)
	encoder.AppendJSONKey("p_fixed64")
	encoder.AppendPointerUint64(x.PFixed64)
	encoder.AppendJSONKey("p_float")
	encoder.AppendPointerFloat32(x.PFloat)
	encoder.AppendJSONKey("p_double")
	encoder.AppendPointerFloat64(x.PDouble)
	encoder.AppendJSONKey("p_bool1")
	encoder.AppendPointerBool(x.PBool1)
	encoder.AppendJSONKey("p_bool2")
	encoder.AppendPointerBool(x.PBool2)
	encoder.AppendJSONKey("p_bool3")
	encoder.AppendPointerBool(x.PBool3)
	encoder.AppendJSONKey("p_bytes1")
	encoder.AppendValueBytes(x.PBytes1)
	encoder.AppendJSONKey("p_bytes2")
	encoder.AppendValueBytes(x.PBytes2)
	encoder.AppendJSONKey("p_bytes3")
	encoder.AppendValueBytes(x.PBytes3)
	encoder.AppendJSONKey("p_enum1")
	if x.PEnum1 != nil {
		encoder.AppendValueInt32(int32(x.PEnum1.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum2")
	if x.PEnum2 != nil {
		encoder.AppendValueInt32(int32(x.PEnum2.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum3")
	if x.PEnum3 != nil {
		encoder.AppendValueInt32(int32(x.PEnum3.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum4")
	if x.PEnum4 != nil {
		encoder.AppendValueInt32(int32(x.PEnum4.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum5")
	if x.PEnum5 != nil {
		encoder.AppendValueInt32(int32(x.PEnum5.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum6")
	if x.PEnum6 != nil {
		encoder.AppendValueInt32(int32(x.PEnum6.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum7")
	if x.PEnum7 != nil {
		encoder.AppendValueInt32(int32(x.PEnum7.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_message1")
	err = encoder.AppendValueInterface(x.PMessage1)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message2")
	err = encoder.AppendValueInterface(x.PMessage2)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message3")
	err = encoder.AppendValueInterface(x.PMessage3)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message4")
	err = encoder.AppendValueInterface(x.PMessage4)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message5")
	err = encoder.AppendValueInterface(x.PMessage5)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message6")
	err = encoder.AppendValueInterface(x.PMessage6)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message7")
	err = encoder.AppendValueInterface(x.PMessage7)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("r_string1")
	if x.RString1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString1 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string2")
	if x.RString2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString2 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string3")
	if x.RString3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString3 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string4")
	if x.RString4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString4 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string5")
	if x.RString5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString5 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string6")
	if x.RString6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString6 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string7")
	if x.RString7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString7 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string8")
	if x.RString8 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString8 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string9")
	if x.RString9 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString9 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_int32")
	if x.RInt32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_uint32")
	if x.RUint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RUint32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_uint64")
	if x.RUint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RUint64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sint32")
	if x.RSint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSint32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sint64")
	if x.RSint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSint64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sfixed32")
	if x.RSfixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSfixed32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sfixed64")
	if x.RSfixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSfixed64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_fixed32")
	if x.RFixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFixed32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_fixed64")
	if x.RFixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFixed64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_float")
	if x.RFloat != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFloat {
			encoder.AppendValueFloat32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_double")
	if x.RDouble != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RDouble {
			encoder.AppendValueFloat64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool1")
	if x.RBool1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool1 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool2")
	if x.RBool2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool2 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool3")
	if x.RBool3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool3 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes1")
	if x.RBytes1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes1 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes2")
	if x.RBytes2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes2 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes3")
	if x.RBytes3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes3 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum1")
	if x.REnum1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum1 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum2")
	if x.REnum2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum2 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum3")
	if x.REnum3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum3 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum4")
	if x.REnum4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum4 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum5")
	if x.REnum5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum5 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum6")
	if x.REnum6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum6 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum7")
	if x.REnum7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum7 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message1")
	if x.RMessage1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message2")
	if x.RMessage2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message3")
	if x.RMessage3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage3 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message4")
	if x.RMessage4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage4 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message5")
	if x.RMessage5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage5 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message6")
	if x.RMessage6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage6 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message7")
	if x.RMessage7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage7 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string1")
	if x.MString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string2")
	if x.MString2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string3")
	if x.MString3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string4")
	if x.MString4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString4 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string5")
	if x.MString5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString5 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string6")
	if x.MString6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString6 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string7")
	if x.MString7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString7 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string8")
	if x.MString8 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString8 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string9")
	if x.MString9 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString9 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_int32")
	if x.MInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_int64")
	if x.MInt64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_uint32")
	if x.MUint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MUint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_uint64")
	if x.MUint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MUint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sint32")
	if x.MSint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sint64")
	if x.MSint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sfixed32")
	if x.MSfixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSfixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sfixed64")
	if x.MSfixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSfixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_fixed32")
	if x.MFixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_fixed64")
	if x.MFixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_float")
	if x.MFloat != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFloat {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_double")
	if x.MDouble != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MDouble {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool1")
	if x.MBool1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool2")
	if x.MBool2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool3")
	if x.MBool3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes1")
	if x.MBytes1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes2")
	if x.MBytes2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes3")
	if x.MBytes3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum1")
	if x.MEnum1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum2")
	if x.MEnum2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum3")
	if x.MEnum3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum4")
	if x.MEnum4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum4 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum5")
	if x.MEnum5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum5 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum6")
	if x.MEnum6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum6 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum7")
	if x.MEnum7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum7 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message1")
	if x.MMessage1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message2")
	if x.MMessage2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message3")
	if x.MMessage3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage3 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message4")
	if x.MMessage4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage4 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message5")
	if x.MMessage5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage5 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message6")
	if x.MMessage6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage6 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message7")
	if x.MMessage7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage7 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message BenchModelComplex in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelComplex) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*BenchModelComplex) is nil")
	}

	var (
		err     error
		isNULL  bool
		decoder *jsondecoder.Decoder
	)
	if decoder, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = decoder.BeforeScanJSON(); err != nil {
		return err
	}
	if isNULL {
		return nil
	}
LOOP_SCAN:
	for { // Loop to scan object.
		var (
			jsonKey string
			isEnd   bool
		)
		if isEnd, err = decoder.BeforeReadJSONKey(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}
		if jsonKey, err = decoder.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the JSON key
		case "f_string1":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString1 = vv
		case "f_string2":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString2 = vv
		case "f_string3":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString3 = vv
		case "f_string4":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString4 = vv
		case "f_string5":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString5 = vv
		case "f_string6":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString6 = vv
		case "f_string7":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString7 = vv
		case "f_string8":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString8 = vv
		case "f_string9":
			var vv string
			vv, err = decoder.ReadValueString(jsonKey)
			if err != nil {
				return err
			}
			x.FString9 = vv
		case "f_int32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FInt32 = vv
		case "f_int64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FInt64 = vv
		case "f_uint32":
			var vv uint32
			vv, err = decoder.ReadValueUint32(jsonKey)
			if err != nil {
				return err
			}
			x.FUint32 = vv
		case "f_uint64":
			var vv uint64
			vv, err = decoder.ReadValueUint64(jsonKey)
			if err != nil {
				return err
			}
			x.FUint64 = vv
		case "f_sint32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FSint32 = vv
		case "f_sint64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FSint64 = vv
		case "f_sfixed32":
			var vv int32
			vv, err = decoder.ReadValueInt32(jsonKey)
			if err != nil {
				return err
			}
			x.FSfixed32 = vv
		case "f_sfixed64":
			var vv int64
			vv, err = decoder.ReadValueInt64(jsonKey)
			if err != nil {
				return err
			}
			x.FSfixed64 = vv
		case "f_fixed32":
			var vv uint32
			vv, err = decoder.ReadValueUint32(jsonKey)
			if err != nil {
				return err
			}
			x.FFixed32 = vv
		case "f_fixed64":
			var vv uint64
			vv, err = decoder.ReadValueUint64(jsonKey)
			if err != nil {
				return err
			}
			x.FFixed64 = vv
		case "f_float":
			var vv float32
			vv, err = decoder.ReadValueFloat32(jsonKey)
			if err != nil {
				return err
			}
			x.FFloat = vv
		case "f_double":
			var vv float64
			vv, err = decoder.ReadValueFloat64(jsonKey)
			if err != nil {
				return err
			}
			x.FDouble = vv
		case "f_bool1":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool1 = vv
		case "f_bool2":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool2 = vv
		case "f_bool3":
			var vv bool
			vv, err = decoder.ReadValueBool(jsonKey)
			if err != nil {
				return err
			}
			x.FBool3 = vv
		case "f_bytes1":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.FBytes1 = vv
		case "f_bytes2":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.FBytes2 = vv
		case "f_bytes3":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.FBytes3 = vv
		case "f_enum1":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum1 = vv
		case "f_enum2":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum2 = vv
		case "f_enum3":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum3 = vv
		case "f_enum4":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum4 = vv
		case "f_enum5":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum5 = vv
		case "f_enum6":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum6 = vv
		case "f_enum7":
			var vv Enum1
			var v1 int32
			v1, err = decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv = Enum1(v1)
			if err != nil {
				return err
			}
			x.FEnum7 = vv
		case "f_message1":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage1 != nil {
					vv = x.FMessage1
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage1 = vv
		case "f_message2":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage2 != nil {
					vv = x.FMessage2
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage2 = vv
		case "f_message3":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage3 != nil {
					vv = x.FMessage3
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage3 = vv
		case "f_message4":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage4 != nil {
					vv = x.FMessage4
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage4 = vv
		case "f_message5":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage5 != nil {
					vv = x.FMessage5
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage5 = vv
		case "f_message6":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage6 != nil {
					vv = x.FMessage6
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage6 = vv
		case "f_message7":
			var vv *Message1
			initFN := func() interface{} {
				if x.FMessage7 != nil {
					vv = x.FMessage7
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.FMessage7 = vv
		case "p_string1":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString1 = vv
		case "p_string2":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString2 = vv
		case "p_string3":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString3 = vv
		case "p_string4":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString4 = vv
		case "p_string5":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString5 = vv
		case "p_string6":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString6 = vv
		case "p_string7":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString7 = vv
		case "p_string8":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString8 = vv
		case "p_string9":
			var vv *string
			vv, err = decoder.ReadPointerString(jsonKey)
			if err != nil {
				return err
			}
			x.PString9 = vv
		case "p_int32":
			var vv *int32
			vv, err = decoder.ReadPointerInt32(jsonKey)
			if err != nil {
				return err
			}
			x.PInt32 = vv
		case "p_int64":
			var vv *int64
			vv, err = decoder.ReadPointerInt64(jsonKey)
			if err != nil {
				return err
			}
			x.PInt64 = vv
		case "p_uint32":
			var vv *uint32
			vv, err = decoder.ReadPointerUint32(jsonKey)
			if err != nil {
				return err
			}
			x.PUint32 = vv
		case "p_uint64":
			var vv *uint64
			vv, err = decoder.ReadPointerUint64(jsonKey)
			if err != nil {
				return err
			}
			x.PUint64 = vv
		case "p_sint32":
			var vv *int32
			vv, err = decoder.ReadPointerInt32(jsonKey)
			if err != nil {
				return err
			}
			x.PSint32 = vv
		case "p_sint64":
			var vv *int64
			vv, err = decoder.ReadPointerInt64(jsonKey)
			if err != nil {
				return err
			}
			x.PSint64 = vv
		case "p_sfixed32":
			var vv *int32
			vv, err = decoder.ReadPointerInt32(jsonKey)
			if err != nil {
				return err
			}
			x.PSfixed32 = vv
		case "p_sfixed64":
			var vv *int64
			vv, err = decoder.ReadPointerInt64(jsonKey)
			if err != nil {
				return err
			}
			x.PSfixed64 = vv
		case "p_fixed32":
			var vv *uint32
			vv, err = decoder.ReadPointerUint32(jsonKey)
			if err != nil {
				return err
			}
			x.PFixed32 = vv
		case "p_fixed64":
			var vv *uint64
			vv, err = decoder.ReadPointerUint64(jsonKey)
			if err != nil {
				return err
			}
			x.PFixed64 = vv
		case "p_float":
			var vv *float32
			vv, err = decoder.ReadPointerFloat32(jsonKey)
			if err != nil {
				return err
			}
			x.PFloat = vv
		case "p_double":
			var vv *float64
			vv, err = decoder.ReadPointerFloat64(jsonKey)
			if err != nil {
				return err
			}
			x.PDouble = vv
		case "p_bool1":
			var vv *bool
			vv, err = decoder.ReadPointerBool(jsonKey)
			if err != nil {
				return err
			}
			x.PBool1 = vv
		case "p_bool2":
			var vv *bool
			vv, err = decoder.ReadPointerBool(jsonKey)
			if err != nil {
				return err
			}
			x.PBool2 = vv
		case "p_bool3":
			var vv *bool
			vv, err = decoder.ReadPointerBool(jsonKey)
			if err != nil {
				return err
			}
			x.PBool3 = vv
		case "p_bytes1":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.PBytes1 = vv
		case "p_bytes2":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.PBytes2 = vv
		case "p_bytes3":
			var vv []byte
			vv, err = decoder.ReadValueBytes(jsonKey)
			if err != nil {
				return err
			}
			x.PBytes3 = vv
		case "p_enum1":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum1 = vv
		case "p_enum2":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum2 = vv
		case "p_enum3":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum3 = vv
		case "p_enum4":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum4 = vv
		case "p_enum5":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum5 = vv
		case "p_enum6":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum6 = vv
		case "p_enum7":
			var vv *Enum1
			var v1 *int32
			v1, err = decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				v2 := Enum1(*v1)
				vv = &v2
			}
			if err != nil {
				return err
			}
			x.PEnum7 = vv
		case "p_message1":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage1 != nil {
					vv = x.PMessage1
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage1 = vv
		case "p_message2":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage2 != nil {
					vv = x.PMessage2
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage2 = vv
		case "p_message3":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage3 != nil {
					vv = x.PMessage3
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage3 = vv
		case "p_message4":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage4 != nil {
					vv = x.PMessage4
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage4 = vv
		case "p_message5":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage5 != nil {
					vv = x.PMessage5
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage5 = vv
		case "p_message6":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage6 != nil {
					vv = x.PMessage6
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage6 = vv
		case "p_message7":
			var vv *Message1
			initFN := func() interface{} {
				if x.PMessage7 != nil {
					vv = x.PMessage7
				} else {
					vv = new(Message1)
				}
				return vv
			}
			err = decoder.ReadValueInterface(jsonKey, initFN)
			if err != nil {
				return err
			}
			x.PMessage7 = vv
		case "r_string1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString1 = nil
				continue LOOP_SCAN
			}
			if x.RString1 == nil {
				x.RString1 = make([]string, 0)
			}
			i := 0
			length := len(x.RString1)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString1[i] = vv
				} else {
					x.RString1 = append(x.RString1, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString1 = x.RString1[:i]
			}
		case "r_string2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString2 = nil
				continue LOOP_SCAN
			}
			if x.RString2 == nil {
				x.RString2 = make([]string, 0)
			}
			i := 0
			length := len(x.RString2)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString2[i] = vv
				} else {
					x.RString2 = append(x.RString2, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString2 = x.RString2[:i]
			}
		case "r_string3":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString3 = nil
				continue LOOP_SCAN
			}
			if x.RString3 == nil {
				x.RString3 = make([]string, 0)
			}
			i := 0
			length := len(x.RString3)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString3[i] = vv
				} else {
					x.RString3 = append(x.RString3, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString3 = x.RString3[:i]
			}
		case "r_string4":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString4 = nil
				continue LOOP_SCAN
			}
			if x.RString4 == nil {
				x.RString4 = make([]string, 0)
			}
			i := 0
			length := len(x.RString4)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString4[i] = vv
				} else {
					x.RString4 = append(x.RString4, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString4 = x.RString4[:i]
			}
		case "r_string5":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString5 = nil
				continue LOOP_SCAN
			}
			if x.RString5 == nil {
				x.RString5 = make([]string, 0)
			}
			i := 0
			length := len(x.RString5)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString5[i] = vv
				} else {
					x.RString5 = append(x.RString5, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString5 = x.RString5[:i]
			}
		case "r_string6":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString6 = nil
				continue LOOP_SCAN
			}
			if x.RString6 == nil {
				x.RString6 = make([]string, 0)
			}
			i := 0
			length := len(x.RString6)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString6[i] = vv
				} else {
					x.RString6 = append(x.RString6, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString6 = x.RString6[:i]
			}
		case "r_string7":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString7 = nil
				continue LOOP_SCAN
			}
			if x.RString7 == nil {
				x.RString7 = make([]string, 0)
			}
			i := 0
			length := len(x.RString7)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString7[i] = vv
				} else {
					x.RString7 = append(x.RString7, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString7 = x.RString7[:i]
			}
		case "r_string8":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString8 = nil
				continue LOOP_SCAN
			}
			if x.RString8 == nil {
				x.RString8 = make([]string, 0)
			}
			i := 0
			length := len(x.RString8)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString8[i] = vv
				} else {
					x.RString8 = append(x.RString8, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString8 = x.RString8[:i]
			}
		case "r_string9":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RString9 = nil
				continue LOOP_SCAN
			}
			if x.RString9 == nil {
				x.RString9 = make([]string, 0)
			}
			i := 0
			length := len(x.RString9)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv string
				vv, err = decoder.ReadArrayElemString(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RString9[i] = vv
				} else {
					x.RString9 = append(x.RString9, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RString9 = x.RString9[:i]
			}
		case "r_int32":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt32 = nil
				continue LOOP_SCAN
			}
			if x.RInt32 == nil {
				x.RInt32 = make([]int32, 0)
			}
			i := 0
			length := len(x.RInt32)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				vv, err = decoder.ReadArrayElemInt32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RInt32[i] = vv
				} else {
					x.RInt32 = append(x.RInt32, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RInt32 = x.RInt32[:i]
			}
		case "r_int64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RInt64 = nil
				continue LOOP_SCAN
			}
			if x.RInt64 == nil {
				x.RInt64 = make([]int64, 0)
			}
			i := 0
			length := len(x.RInt64)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				vv, err = decoder.ReadArrayElemInt64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RInt64[i] = vv
				} else {
					x.RInt64 = append(x.RInt64, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RInt64 = x.RInt64[:i]
			}
		case "r_uint32":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RUint32 = nil
				continue LOOP_SCAN
			}
			if x.RUint32 == nil {
				x.RUint32 = make([]uint32, 0)
			}
			i := 0
			length := len(x.RUint32)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				vv, err = decoder.ReadArrayElemUint32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RUint32[i] = vv
				} else {
					x.RUint32 = append(x.RUint32, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RUint32 = x.RUint32[:i]
			}
		case "r_uint64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RUint64 = nil
				continue LOOP_SCAN
			}
			if x.RUint64 == nil {
				x.RUint64 = make([]uint64, 0)
			}
			i := 0
			length := len(x.RUint64)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				vv, err = decoder.ReadArrayElemUint64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RUint64[i] = vv
				} else {
					x.RUint64 = append(x.RUint64, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RUint64 = x.RUint64[:i]
			}
		case "r_sint32":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RSint32 = nil
				continue LOOP_SCAN
			}
			if x.RSint32 == nil {
				x.RSint32 = make([]int32, 0)
			}
			i := 0
			length := len(x.RSint32)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				vv, err = decoder.ReadArrayElemInt32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RSint32[i] = vv
				} else {
					x.RSint32 = append(x.RSint32, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RSint32 = x.RSint32[:i]
			}
		case "r_sint64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RSint64 = nil
				continue LOOP_SCAN
			}
			if x.RSint64 == nil {
				x.RSint64 = make([]int64, 0)
			}
			i := 0
			length := len(x.RSint64)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				vv, err = decoder.ReadArrayElemInt64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RSint64[i] = vv
				} else {
					x.RSint64 = append(x.RSint64, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RSint64 = x.RSint64[:i]
			}
		case "r_sfixed32":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RSfixed32 = nil
				continue LOOP_SCAN
			}
			if x.RSfixed32 == nil {
				x.RSfixed32 = make([]int32, 0)
			}
			i := 0
			length := len(x.RSfixed32)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int32
				vv, err = decoder.ReadArrayElemInt32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RSfixed32[i] = vv
				} else {
					x.RSfixed32 = append(x.RSfixed32, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RSfixed32 = x.RSfixed32[:i]
			}
		case "r_sfixed64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RSfixed64 = nil
				continue LOOP_SCAN
			}
			if x.RSfixed64 == nil {
				x.RSfixed64 = make([]int64, 0)
			}
			i := 0
			length := len(x.RSfixed64)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv int64
				vv, err = decoder.ReadArrayElemInt64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RSfixed64[i] = vv
				} else {
					x.RSfixed64 = append(x.RSfixed64, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RSfixed64 = x.RSfixed64[:i]
			}
		case "r_fixed32":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RFixed32 = nil
				continue LOOP_SCAN
			}
			if x.RFixed32 == nil {
				x.RFixed32 = make([]uint32, 0)
			}
			i := 0
			length := len(x.RFixed32)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint32
				vv, err = decoder.ReadArrayElemUint32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RFixed32[i] = vv
				} else {
					x.RFixed32 = append(x.RFixed32, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RFixed32 = x.RFixed32[:i]
			}
		case "r_fixed64":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RFixed64 = nil
				continue LOOP_SCAN
			}
			if x.RFixed64 == nil {
				x.RFixed64 = make([]uint64, 0)
			}
			i := 0
			length := len(x.RFixed64)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv uint64
				vv, err = decoder.ReadArrayElemUint64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RFixed64[i] = vv
				} else {
					x.RFixed64 = append(x.RFixed64, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RFixed64 = x.RFixed64[:i]
			}
		case "r_float":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RFloat = nil
				continue LOOP_SCAN
			}
			if x.RFloat == nil {
				x.RFloat = make([]float32, 0)
			}
			i := 0
			length := len(x.RFloat)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float32
				vv, err = decoder.ReadArrayElemFloat32(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RFloat[i] = vv
				} else {
					x.RFloat = append(x.RFloat, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RFloat = x.RFloat[:i]
			}
		case "r_double":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RDouble = nil
				continue LOOP_SCAN
			}
			if x.RDouble == nil {
				x.RDouble = make([]float64, 0)
			}
			i := 0
			length := len(x.RDouble)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv float64
				vv, err = decoder.ReadArrayElemFloat64(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RDouble[i] = vv
				} else {
					x.RDouble = append(x.RDouble, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RDouble = x.RDouble[:i]
			}
		case "r_bool1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBool1 = nil
				continue LOOP_SCAN
			}
			if x.RBool1 == nil {
				x.RBool1 = make([]bool, 0)
			}
			i := 0
			length := len(x.RBool1)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv bool
				vv, err = decoder.ReadArrayElemBool(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBool1[i] = vv
				} else {
					x.RBool1 = append(x.RBool1, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBool1 = x.RBool1[:i]
			}
		case "r_bool2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBool2 = nil
				continue LOOP_SCAN
			}
			if x.RBool2 == nil {
				x.RBool2 = make([]bool, 0)
			}
			i := 0
			length := len(x.RBool2)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv bool
				vv, err = decoder.ReadArrayElemBool(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBool2[i] = vv
				} else {
					x.RBool2 = append(x.RBool2, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBool2 = x.RBool2[:i]
			}
		case "r_bool3":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBool3 = nil
				continue LOOP_SCAN
			}
			if x.RBool3 == nil {
				x.RBool3 = make([]bool, 0)
			}
			i := 0
			length := len(x.RBool3)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv bool
				vv, err = decoder.ReadArrayElemBool(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBool3[i] = vv
				} else {
					x.RBool3 = append(x.RBool3, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBool3 = x.RBool3[:i]
			}
		case "r_bytes1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBytes1 = nil
				continue LOOP_SCAN
			}
			if x.RBytes1 == nil {
				x.RBytes1 = make([][]byte, 0)
			}
			i := 0
			length := len(x.RBytes1)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv []byte
				vv, err = decoder.ReadArrayElemBytes(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBytes1[i] = vv
				} else {
					x.RBytes1 = append(x.RBytes1, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBytes1 = x.RBytes1[:i]
			}
		case "r_bytes2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBytes2 = nil
				continue LOOP_SCAN
			}
			if x.RBytes2 == nil {
				x.RBytes2 = make([][]byte, 0)
			}
			i := 0
			length := len(x.RBytes2)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv []byte
				vv, err = decoder.ReadArrayElemBytes(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBytes2[i] = vv
				} else {
					x.RBytes2 = append(x.RBytes2, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBytes2 = x.RBytes2[:i]
			}
		case "r_bytes3":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RBytes3 = nil
				continue LOOP_SCAN
			}
			if x.RBytes3 == nil {
				x.RBytes3 = make([][]byte, 0)
			}
			i := 0
			length := len(x.RBytes3)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv []byte
				vv, err = decoder.ReadArrayElemBytes(jsonKey)
				if err != nil {
					return err
				}
				if i < length {
					x.RBytes3[i] = vv
				} else {
					x.RBytes3 = append(x.RBytes3, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RBytes3 = x.RBytes3[:i]
			}
		case "r_enum1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum1 = nil
				continue LOOP_SCAN
			}
			if x.REnum1 == nil {
				x.REnum1 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum1)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum1[i] = vv
				} else {
					x.REnum1 = append(x.REnum1, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum1 = x.REnum1[:i]
			}
		case "r_enum2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum2 = nil
				continue LOOP_SCAN
			}
			if x.REnum2 == nil {
				x.REnum2 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum2)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum2[i] = vv
				} else {
					x.REnum2 = append(x.REnum2, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum2 = x.REnum2[:i]
			}
		case "r_enum3":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum3 = nil
				continue LOOP_SCAN
			}
			if x.REnum3 == nil {
				x.REnum3 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum3)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum3[i] = vv
				} else {
					x.REnum3 = append(x.REnum3, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum3 = x.REnum3[:i]
			}
		case "r_enum4":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum4 = nil
				continue LOOP_SCAN
			}
			if x.REnum4 == nil {
				x.REnum4 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum4)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum4[i] = vv
				} else {
					x.REnum4 = append(x.REnum4, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum4 = x.REnum4[:i]
			}
		case "r_enum5":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum5 = nil
				continue LOOP_SCAN
			}
			if x.REnum5 == nil {
				x.REnum5 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum5)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum5[i] = vv
				} else {
					x.REnum5 = append(x.REnum5, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum5 = x.REnum5[:i]
			}
		case "r_enum6":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum6 = nil
				continue LOOP_SCAN
			}
			if x.REnum6 == nil {
				x.REnum6 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum6)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum6[i] = vv
				} else {
					x.REnum6 = append(x.REnum6, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum6 = x.REnum6[:i]
			}
		case "r_enum7":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.REnum7 = nil
				continue LOOP_SCAN
			}
			if x.REnum7 == nil {
				x.REnum7 = make([]Enum1, 0)
			}
			i := 0
			length := len(x.REnum7)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv Enum1
				var v1 int32
				v1, err = decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
				vv = Enum1(v1)
				if err != nil {
					return err
				}
				if i < length {
					x.REnum7[i] = vv
				} else {
					x.REnum7 = append(x.REnum7, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.REnum7 = x.REnum7[:i]
			}
		case "r_message1":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage1 = nil
				continue LOOP_SCAN
			}
			if x.RMessage1 == nil {
				x.RMessage1 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage1)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage1[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage1[i] = vv
				} else {
					x.RMessage1 = append(x.RMessage1, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage1 = x.RMessage1[:i]
			}
		case "r_message2":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage2 = nil
				continue LOOP_SCAN
			}
			if x.RMessage2 == nil {
				x.RMessage2 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage2)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage2[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage2[i] = vv
				} else {
					x.RMessage2 = append(x.RMessage2, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage2 = x.RMessage2[:i]
			}
		case "r_message3":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage3 = nil
				continue LOOP_SCAN
			}
			if x.RMessage3 == nil {
				x.RMessage3 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage3)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage3[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage3[i] = vv
				} else {
					x.RMessage3 = append(x.RMessage3, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage3 = x.RMessage3[:i]
			}
		case "r_message4":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage4 = nil
				continue LOOP_SCAN
			}
			if x.RMessage4 == nil {
				x.RMessage4 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage4)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage4[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage4[i] = vv
				} else {
					x.RMessage4 = append(x.RMessage4, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage4 = x.RMessage4[:i]
			}
		case "r_message5":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage5 = nil
				continue LOOP_SCAN
			}
			if x.RMessage5 == nil {
				x.RMessage5 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage5)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage5[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage5[i] = vv
				} else {
					x.RMessage5 = append(x.RMessage5, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage5 = x.RMessage5[:i]
			}
		case "r_message6":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage6 = nil
				continue LOOP_SCAN
			}
			if x.RMessage6 == nil {
				x.RMessage6 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage6)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage6[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage6[i] = vv
				} else {
					x.RMessage6 = append(x.RMessage6, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage6 = x.RMessage6[:i]
			}
		case "r_message7":
			if isNULL, err = decoder.BeforeReadArray(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.RMessage7 = nil
				continue LOOP_SCAN
			}
			if x.RMessage7 == nil {
				x.RMessage7 = make([]*Message1, 0)
			}
			i := 0
			length := len(x.RMessage7)
			for {
				if isEnd, err = decoder.BeforeReadArrayElem(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var vv *Message1
				initFN := func() interface{} {
					if i < length {
						vv = x.RMessage7[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					return vv
				}
				err = decoder.ReadArrayElemInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				if i < length {
					x.RMessage7[i] = vv
				} else {
					x.RMessage7 = append(x.RMessage7, vv)
				}
				i++
			}
			if i < length {
				// truncate the slice to Consistent with standard library json.
				x.RMessage7 = x.RMessage7[:i]
			}
		case "m_string1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString1 = nil
				continue LOOP_SCAN
			}
			if x.MString1 == nil {
				x.MString1 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString1[mapKey] = mapVal
			}
		case "m_string2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString2 = nil
				continue LOOP_SCAN
			}
			if x.MString2 == nil {
				x.MString2 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString2[mapKey] = mapVal
			}
		case "m_string3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString3 = nil
				continue LOOP_SCAN
			}
			if x.MString3 == nil {
				x.MString3 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString3[mapKey] = mapVal
			}
		case "m_string4":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString4 = nil
				continue LOOP_SCAN
			}
			if x.MString4 == nil {
				x.MString4 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString4[mapKey] = mapVal
			}
		case "m_string5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString5 = nil
				continue LOOP_SCAN
			}
			if x.MString5 == nil {
				x.MString5 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString5[mapKey] = mapVal
			}
		case "m_string6":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString6 = nil
				continue LOOP_SCAN
			}
			if x.MString6 == nil {
				x.MString6 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString6[mapKey] = mapVal
			}
		case "m_string7":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString7 = nil
				continue LOOP_SCAN
			}
			if x.MString7 == nil {
				x.MString7 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString7[mapKey] = mapVal
			}
		case "m_string8":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString8 = nil
				continue LOOP_SCAN
			}
			if x.MString8 == nil {
				x.MString8 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString8[mapKey] = mapVal
			}
		case "m_string9":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MString9 = nil
				continue LOOP_SCAN
			}
			if x.MString9 == nil {
				x.MString9 = make(map[string]string)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal string
				mapVal, err = decoder.ReadMapValueString(jsonKey)
				if err != nil {
					return err
				}
				x.MString9[mapKey] = mapVal
			}
		case "m_int32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MInt32 = nil
				continue LOOP_SCAN
			}
			if x.MInt32 == nil {
				x.MInt32 = make(map[string]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.MInt32[mapKey] = mapVal
			}
		case "m_int64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MInt64 = nil
				continue LOOP_SCAN
			}
			if x.MInt64 == nil {
				x.MInt64 = make(map[string]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.MInt64[mapKey] = mapVal
			}
		case "m_uint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MUint32 = nil
				continue LOOP_SCAN
			}
			if x.MUint32 == nil {
				x.MUint32 = make(map[string]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.MUint32[mapKey] = mapVal
			}
		case "m_uint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MUint64 = nil
				continue LOOP_SCAN
			}
			if x.MUint64 == nil {
				x.MUint64 = make(map[string]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.MUint64[mapKey] = mapVal
			}
		case "m_sint32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MSint32 = nil
				continue LOOP_SCAN
			}
			if x.MSint32 == nil {
				x.MSint32 = make(map[string]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.MSint32[mapKey] = mapVal
			}
		case "m_sint64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MSint64 = nil
				continue LOOP_SCAN
			}
			if x.MSint64 == nil {
				x.MSint64 = make(map[string]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.MSint64[mapKey] = mapVal
			}
		case "m_sfixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MSfixed32 = nil
				continue LOOP_SCAN
			}
			if x.MSfixed32 == nil {
				x.MSfixed32 = make(map[string]int32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int32
				mapVal, err = decoder.ReadMapValueInt32(jsonKey)
				if err != nil {
					return err
				}
				x.MSfixed32[mapKey] = mapVal
			}
		case "m_sfixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MSfixed64 = nil
				continue LOOP_SCAN
			}
			if x.MSfixed64 == nil {
				x.MSfixed64 = make(map[string]int64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal int64
				mapVal, err = decoder.ReadMapValueInt64(jsonKey)
				if err != nil {
					return err
				}
				x.MSfixed64[mapKey] = mapVal
			}
		case "m_fixed32":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MFixed32 = nil
				continue LOOP_SCAN
			}
			if x.MFixed32 == nil {
				x.MFixed32 = make(map[string]uint32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint32
				mapVal, err = decoder.ReadMapValueUint32(jsonKey)
				if err != nil {
					return err
				}
				x.MFixed32[mapKey] = mapVal
			}
		case "m_fixed64":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MFixed64 = nil
				continue LOOP_SCAN
			}
			if x.MFixed64 == nil {
				x.MFixed64 = make(map[string]uint64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal uint64
				mapVal, err = decoder.ReadMapValueUint64(jsonKey)
				if err != nil {
					return err
				}
				x.MFixed64[mapKey] = mapVal
			}
		case "m_float":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MFloat = nil
				continue LOOP_SCAN
			}
			if x.MFloat == nil {
				x.MFloat = make(map[string]float32)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal float32
				mapVal, err = decoder.ReadMapValueFloat32(jsonKey)
				if err != nil {
					return err
				}
				x.MFloat[mapKey] = mapVal
			}
		case "m_double":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MDouble = nil
				continue LOOP_SCAN
			}
			if x.MDouble == nil {
				x.MDouble = make(map[string]float64)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal float64
				mapVal, err = decoder.ReadMapValueFloat64(jsonKey)
				if err != nil {
					return err
				}
				x.MDouble[mapKey] = mapVal
			}
		case "m_bool1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBool1 = nil
				continue LOOP_SCAN
			}
			if x.MBool1 == nil {
				x.MBool1 = make(map[string]bool)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal bool
				mapVal, err = decoder.ReadMapValueBool(jsonKey)
				if err != nil {
					return err
				}
				x.MBool1[mapKey] = mapVal
			}
		case "m_bool2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBool2 = nil
				continue LOOP_SCAN
			}
			if x.MBool2 == nil {
				x.MBool2 = make(map[string]bool)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal bool
				mapVal, err = decoder.ReadMapValueBool(jsonKey)
				if err != nil {
					return err
				}
				x.MBool2[mapKey] = mapVal
			}
		case "m_bool3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBool3 = nil
				continue LOOP_SCAN
			}
			if x.MBool3 == nil {
				x.MBool3 = make(map[string]bool)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal bool
				mapVal, err = decoder.ReadMapValueBool(jsonKey)
				if err != nil {
					return err
				}
				x.MBool3[mapKey] = mapVal
			}
		case "m_bytes1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBytes1 = nil
				continue LOOP_SCAN
			}
			if x.MBytes1 == nil {
				x.MBytes1 = make(map[string][]byte)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal []byte
				mapVal, err = decoder.ReadMapValueBytes(jsonKey)
				if err != nil {
					return err
				}
				x.MBytes1[mapKey] = mapVal
			}
		case "m_bytes2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBytes2 = nil
				continue LOOP_SCAN
			}
			if x.MBytes2 == nil {
				x.MBytes2 = make(map[string][]byte)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal []byte
				mapVal, err = decoder.ReadMapValueBytes(jsonKey)
				if err != nil {
					return err
				}
				x.MBytes2[mapKey] = mapVal
			}
		case "m_bytes3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MBytes3 = nil
				continue LOOP_SCAN
			}
			if x.MBytes3 == nil {
				x.MBytes3 = make(map[string][]byte)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal []byte
				mapVal, err = decoder.ReadMapValueBytes(jsonKey)
				if err != nil {
					return err
				}
				x.MBytes3[mapKey] = mapVal
			}
		case "m_enum1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum1 = nil
				continue LOOP_SCAN
			}
			if x.MEnum1 == nil {
				x.MEnum1 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum1[mapKey] = mapVal
			}
		case "m_enum2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum2 = nil
				continue LOOP_SCAN
			}
			if x.MEnum2 == nil {
				x.MEnum2 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum2[mapKey] = mapVal
			}
		case "m_enum3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum3 = nil
				continue LOOP_SCAN
			}
			if x.MEnum3 == nil {
				x.MEnum3 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum3[mapKey] = mapVal
			}
		case "m_enum4":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum4 = nil
				continue LOOP_SCAN
			}
			if x.MEnum4 == nil {
				x.MEnum4 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum4[mapKey] = mapVal
			}
		case "m_enum5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum5 = nil
				continue LOOP_SCAN
			}
			if x.MEnum5 == nil {
				x.MEnum5 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum5[mapKey] = mapVal
			}
		case "m_enum6":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum6 = nil
				continue LOOP_SCAN
			}
			if x.MEnum6 == nil {
				x.MEnum6 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum6[mapKey] = mapVal
			}
		case "m_enum7":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MEnum7 = nil
				continue LOOP_SCAN
			}
			if x.MEnum7 == nil {
				x.MEnum7 = make(map[string]Enum1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal Enum1
				var v1 int32
				v1, err = decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
				mapVal = Enum1(v1)
				if err != nil {
					return err
				}
				x.MEnum7[mapKey] = mapVal
			}
		case "m_message1":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage1 = nil
				continue LOOP_SCAN
			}
			if x.MMessage1 == nil {
				x.MMessage1 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage1[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage1[mapKey] = mapVal
			}
		case "m_message2":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage2 = nil
				continue LOOP_SCAN
			}
			if x.MMessage2 == nil {
				x.MMessage2 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage2[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage2[mapKey] = mapVal
			}
		case "m_message3":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage3 = nil
				continue LOOP_SCAN
			}
			if x.MMessage3 == nil {
				x.MMessage3 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage3[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage3[mapKey] = mapVal
			}
		case "m_message4":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage4 = nil
				continue LOOP_SCAN
			}
			if x.MMessage4 == nil {
				x.MMessage4 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage4[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage4[mapKey] = mapVal
			}
		case "m_message5":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage5 = nil
				continue LOOP_SCAN
			}
			if x.MMessage5 == nil {
				x.MMessage5 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage5[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage5[mapKey] = mapVal
			}
		case "m_message6":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage6 = nil
				continue LOOP_SCAN
			}
			if x.MMessage6 == nil {
				x.MMessage6 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage6[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage6[mapKey] = mapVal
			}
		case "m_message7":
			if isNULL, err = decoder.BeforeReadObject(jsonKey); err != nil {
				return err
			}
			if isNULL {
				x.MMessage7 = nil
				continue LOOP_SCAN
			}
			if x.MMessage7 == nil {
				x.MMessage7 = make(map[string]*Message1)
			}
			for {
				if isEnd, err = decoder.BeforeReadObjectKey(jsonKey); err != nil {
					return err
				}
				if isEnd {
					break
				}
				var mapKey string
				mapKey, err = decoder.ReadMapKeyString(jsonKey)
				if err != nil {
					return err
				}
				var mapVal *Message1
				initFN := func() interface{} {
					mapVal = x.MMessage7[mapKey]
					if mapVal == nil {
						mapVal = new(Message1)
					}
					return mapVal
				}
				err = decoder.ReadMapValueInterface(jsonKey, initFN)
				if err != nil {
					return err
				}
				x.MMessage7[mapKey] = mapVal
			}
		default:
			if err = decoder.DiscardValue(jsonKey); err != nil {
				return err
			}
		}
	}
	return nil
}
