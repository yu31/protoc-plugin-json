// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/benchmark/benchmark.proto

package pbbenchmark

import (
	errors "errors"
	fmt "fmt"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message Message1 in file tests/proto/benchmark/benchmark.proto
func (x *Message1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(68)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message Message1 in file tests/proto/benchmark/benchmark.proto
func (x *Message1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*Message1) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message BenchModelSimple in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelSimple) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(500)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)
	encoder.AppendJSONKey("f_string4")
	encoder.AppendValueString(x.FString4)
	encoder.AppendJSONKey("f_string5")
	encoder.AppendValueString(x.FString5)
	encoder.AppendJSONKey("f_string6")
	encoder.AppendValueString(x.FString6)
	encoder.AppendJSONKey("f_string7")
	encoder.AppendValueString(x.FString7)
	encoder.AppendJSONKey("f_string8")
	encoder.AppendValueString(x.FString8)
	encoder.AppendJSONKey("f_string9")
	encoder.AppendValueString(x.FString9)
	encoder.AppendJSONKey("f_int32")
	encoder.AppendValueInt32(x.FInt32)
	encoder.AppendJSONKey("f_int64")
	encoder.AppendValueInt64(x.FInt64)
	encoder.AppendJSONKey("f_uint32")
	encoder.AppendValueUint32(x.FUint32)
	encoder.AppendJSONKey("f_uint64")
	encoder.AppendValueUint64(x.FUint64)
	encoder.AppendJSONKey("f_sint32")
	encoder.AppendValueInt32(x.FSint32)
	encoder.AppendJSONKey("f_sint64")
	encoder.AppendValueInt64(x.FSint64)
	encoder.AppendJSONKey("f_sfixed32")
	encoder.AppendValueInt32(x.FSfixed32)
	encoder.AppendJSONKey("f_sfixed64")
	encoder.AppendValueInt64(x.FSfixed64)
	encoder.AppendJSONKey("f_fixed32")
	encoder.AppendValueUint32(x.FFixed32)
	encoder.AppendJSONKey("f_fixed64")
	encoder.AppendValueUint64(x.FFixed64)
	encoder.AppendJSONKey("f_float")
	encoder.AppendValueFloat32(x.FFloat)
	encoder.AppendJSONKey("f_double")
	encoder.AppendValueFloat64(x.FDouble)
	encoder.AppendJSONKey("f_bool1")
	encoder.AppendValueBool(x.FBool1)
	encoder.AppendJSONKey("f_bool2")
	encoder.AppendValueBool(x.FBool2)
	encoder.AppendJSONKey("f_bool3")
	encoder.AppendValueBool(x.FBool3)

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message BenchModelSimple in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelSimple) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*BenchModelSimple) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		case jsonKey == "f_string4":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString4 = vv
		case jsonKey == "f_string5":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString5 = vv
		case jsonKey == "f_string6":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString6 = vv
		case jsonKey == "f_string7":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString7 = vv
		case jsonKey == "f_string8":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString8 = vv
		case jsonKey == "f_string9":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString9 = vv
		case jsonKey == "f_int32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FInt32 = vv
		case jsonKey == "f_int64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FInt64 = vv
		case jsonKey == "f_uint32":
			vv, _err := decoder.ReadValueUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FUint32 = vv
		case jsonKey == "f_uint64":
			vv, _err := decoder.ReadValueUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FUint64 = vv
		case jsonKey == "f_sint32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSint32 = vv
		case jsonKey == "f_sint64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSint64 = vv
		case jsonKey == "f_sfixed32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSfixed32 = vv
		case jsonKey == "f_sfixed64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSfixed64 = vv
		case jsonKey == "f_fixed32":
			vv, _err := decoder.ReadValueUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFixed32 = vv
		case jsonKey == "f_fixed64":
			vv, _err := decoder.ReadValueUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFixed64 = vv
		case jsonKey == "f_float":
			vv, _err := decoder.ReadValueFloat32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFloat = vv
		case jsonKey == "f_double":
			vv, _err := decoder.ReadValueFloat64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FDouble = vv
		case jsonKey == "f_bool1":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool1 = vv
		case jsonKey == "f_bool2":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool2 = vv
		case jsonKey == "f_bool3":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool3 = vv
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message BenchModelComplex in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelComplex) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	var err error
	encoder := jsonencoder.New(3492)

	// Add begin JSON identifier
	encoder.AppendObjectBegin()

	encoder.AppendJSONKey("f_string1")
	encoder.AppendValueString(x.FString1)
	encoder.AppendJSONKey("f_string2")
	encoder.AppendValueString(x.FString2)
	encoder.AppendJSONKey("f_string3")
	encoder.AppendValueString(x.FString3)
	encoder.AppendJSONKey("f_string4")
	encoder.AppendValueString(x.FString4)
	encoder.AppendJSONKey("f_string5")
	encoder.AppendValueString(x.FString5)
	encoder.AppendJSONKey("f_string6")
	encoder.AppendValueString(x.FString6)
	encoder.AppendJSONKey("f_string7")
	encoder.AppendValueString(x.FString7)
	encoder.AppendJSONKey("f_string8")
	encoder.AppendValueString(x.FString8)
	encoder.AppendJSONKey("f_string9")
	encoder.AppendValueString(x.FString9)
	encoder.AppendJSONKey("f_int32")
	encoder.AppendValueInt32(x.FInt32)
	encoder.AppendJSONKey("f_int64")
	encoder.AppendValueInt64(x.FInt64)
	encoder.AppendJSONKey("f_uint32")
	encoder.AppendValueUint32(x.FUint32)
	encoder.AppendJSONKey("f_uint64")
	encoder.AppendValueUint64(x.FUint64)
	encoder.AppendJSONKey("f_sint32")
	encoder.AppendValueInt32(x.FSint32)
	encoder.AppendJSONKey("f_sint64")
	encoder.AppendValueInt64(x.FSint64)
	encoder.AppendJSONKey("f_sfixed32")
	encoder.AppendValueInt32(x.FSfixed32)
	encoder.AppendJSONKey("f_sfixed64")
	encoder.AppendValueInt64(x.FSfixed64)
	encoder.AppendJSONKey("f_fixed32")
	encoder.AppendValueUint32(x.FFixed32)
	encoder.AppendJSONKey("f_fixed64")
	encoder.AppendValueUint64(x.FFixed64)
	encoder.AppendJSONKey("f_float")
	encoder.AppendValueFloat32(x.FFloat)
	encoder.AppendJSONKey("f_double")
	encoder.AppendValueFloat64(x.FDouble)
	encoder.AppendJSONKey("f_bool1")
	encoder.AppendValueBool(x.FBool1)
	encoder.AppendJSONKey("f_bool2")
	encoder.AppendValueBool(x.FBool2)
	encoder.AppendJSONKey("f_bool3")
	encoder.AppendValueBool(x.FBool3)
	encoder.AppendJSONKey("f_bytes1")
	encoder.AppendValueBytes(x.FBytes1)
	encoder.AppendJSONKey("f_bytes2")
	encoder.AppendValueBytes(x.FBytes2)
	encoder.AppendJSONKey("f_bytes3")
	encoder.AppendValueBytes(x.FBytes3)
	encoder.AppendJSONKey("f_enum1")
	encoder.AppendValueInt32(int32(x.FEnum1.Number()))
	encoder.AppendJSONKey("f_enum2")
	encoder.AppendValueInt32(int32(x.FEnum2.Number()))
	encoder.AppendJSONKey("f_enum3")
	encoder.AppendValueInt32(int32(x.FEnum3.Number()))
	encoder.AppendJSONKey("f_enum4")
	encoder.AppendValueInt32(int32(x.FEnum4.Number()))
	encoder.AppendJSONKey("f_enum5")
	encoder.AppendValueInt32(int32(x.FEnum5.Number()))
	encoder.AppendJSONKey("f_enum6")
	encoder.AppendValueInt32(int32(x.FEnum6.Number()))
	encoder.AppendJSONKey("f_enum7")
	encoder.AppendValueInt32(int32(x.FEnum7.Number()))
	encoder.AppendJSONKey("f_message1")
	err = encoder.AppendValueInterface(x.FMessage1)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message2")
	err = encoder.AppendValueInterface(x.FMessage2)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message3")
	err = encoder.AppendValueInterface(x.FMessage3)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message4")
	err = encoder.AppendValueInterface(x.FMessage4)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message5")
	err = encoder.AppendValueInterface(x.FMessage5)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message6")
	err = encoder.AppendValueInterface(x.FMessage6)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("f_message7")
	err = encoder.AppendValueInterface(x.FMessage7)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_string1")
	encoder.AppendPointerString(x.PString1)
	encoder.AppendJSONKey("p_string2")
	encoder.AppendPointerString(x.PString2)
	encoder.AppendJSONKey("p_string3")
	encoder.AppendPointerString(x.PString3)
	encoder.AppendJSONKey("p_string4")
	encoder.AppendPointerString(x.PString4)
	encoder.AppendJSONKey("p_string5")
	encoder.AppendPointerString(x.PString5)
	encoder.AppendJSONKey("p_string6")
	encoder.AppendPointerString(x.PString6)
	encoder.AppendJSONKey("p_string7")
	encoder.AppendPointerString(x.PString7)
	encoder.AppendJSONKey("p_string8")
	encoder.AppendPointerString(x.PString8)
	encoder.AppendJSONKey("p_string9")
	encoder.AppendPointerString(x.PString9)
	encoder.AppendJSONKey("p_int32")
	encoder.AppendPointerInt32(x.PInt32)
	encoder.AppendJSONKey("p_int64")
	encoder.AppendPointerInt64(x.PInt64)
	encoder.AppendJSONKey("p_uint32")
	encoder.AppendPointerUint32(x.PUint32)
	encoder.AppendJSONKey("p_uint64")
	encoder.AppendPointerUint64(x.PUint64)
	encoder.AppendJSONKey("p_sint32")
	encoder.AppendPointerInt32(x.PSint32)
	encoder.AppendJSONKey("p_sint64")
	encoder.AppendPointerInt64(x.PSint64)
	encoder.AppendJSONKey("p_sfixed32")
	encoder.AppendPointerInt32(x.PSfixed32)
	encoder.AppendJSONKey("p_sfixed64")
	encoder.AppendPointerInt64(x.PSfixed64)
	encoder.AppendJSONKey("p_fixed32")
	encoder.AppendPointerUint32(x.PFixed32)
	encoder.AppendJSONKey("p_fixed64")
	encoder.AppendPointerUint64(x.PFixed64)
	encoder.AppendJSONKey("p_float")
	encoder.AppendPointerFloat32(x.PFloat)
	encoder.AppendJSONKey("p_double")
	encoder.AppendPointerFloat64(x.PDouble)
	encoder.AppendJSONKey("p_bool1")
	encoder.AppendPointerBool(x.PBool1)
	encoder.AppendJSONKey("p_bool2")
	encoder.AppendPointerBool(x.PBool2)
	encoder.AppendJSONKey("p_bool3")
	encoder.AppendPointerBool(x.PBool3)
	encoder.AppendJSONKey("p_bytes1")
	encoder.AppendValueBytes(x.PBytes1)
	encoder.AppendJSONKey("p_bytes2")
	encoder.AppendValueBytes(x.PBytes2)
	encoder.AppendJSONKey("p_bytes3")
	encoder.AppendValueBytes(x.PBytes3)
	encoder.AppendJSONKey("p_enum1")
	if x.PEnum1 != nil {
		encoder.AppendValueInt32(int32(x.PEnum1.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum2")
	if x.PEnum2 != nil {
		encoder.AppendValueInt32(int32(x.PEnum2.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum3")
	if x.PEnum3 != nil {
		encoder.AppendValueInt32(int32(x.PEnum3.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum4")
	if x.PEnum4 != nil {
		encoder.AppendValueInt32(int32(x.PEnum4.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum5")
	if x.PEnum5 != nil {
		encoder.AppendValueInt32(int32(x.PEnum5.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum6")
	if x.PEnum6 != nil {
		encoder.AppendValueInt32(int32(x.PEnum6.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_enum7")
	if x.PEnum7 != nil {
		encoder.AppendValueInt32(int32(x.PEnum7.Number()))
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("p_message1")
	err = encoder.AppendValueInterface(x.PMessage1)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message2")
	err = encoder.AppendValueInterface(x.PMessage2)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message3")
	err = encoder.AppendValueInterface(x.PMessage3)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message4")
	err = encoder.AppendValueInterface(x.PMessage4)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message5")
	err = encoder.AppendValueInterface(x.PMessage5)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message6")
	err = encoder.AppendValueInterface(x.PMessage6)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("p_message7")
	err = encoder.AppendValueInterface(x.PMessage7)
	if err != nil {
		return nil, err
	}
	encoder.AppendJSONKey("r_string1")
	if x.RString1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString1 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string2")
	if x.RString2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString2 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string3")
	if x.RString3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString3 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string4")
	if x.RString4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString4 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string5")
	if x.RString5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString5 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string6")
	if x.RString6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString6 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string7")
	if x.RString7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString7 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string8")
	if x.RString8 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString8 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_string9")
	if x.RString9 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RString9 {
			encoder.AppendValueString(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_int32")
	if x.RInt32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_int64")
	if x.RInt64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RInt64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_uint32")
	if x.RUint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RUint32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_uint64")
	if x.RUint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RUint64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sint32")
	if x.RSint32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSint32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sint64")
	if x.RSint64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSint64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sfixed32")
	if x.RSfixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSfixed32 {
			encoder.AppendValueInt32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_sfixed64")
	if x.RSfixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RSfixed64 {
			encoder.AppendValueInt64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_fixed32")
	if x.RFixed32 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFixed32 {
			encoder.AppendValueUint32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_fixed64")
	if x.RFixed64 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFixed64 {
			encoder.AppendValueUint64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_float")
	if x.RFloat != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RFloat {
			encoder.AppendValueFloat32(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_double")
	if x.RDouble != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RDouble {
			encoder.AppendValueFloat64(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool1")
	if x.RBool1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool1 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool2")
	if x.RBool2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool2 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bool3")
	if x.RBool3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBool3 {
			encoder.AppendValueBool(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes1")
	if x.RBytes1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes1 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes2")
	if x.RBytes2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes2 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_bytes3")
	if x.RBytes3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RBytes3 {
			encoder.AppendValueBytes(ri)
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum1")
	if x.REnum1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum1 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum2")
	if x.REnum2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum2 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum3")
	if x.REnum3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum3 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum4")
	if x.REnum4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum4 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum5")
	if x.REnum5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum5 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum6")
	if x.REnum6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum6 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_enum7")
	if x.REnum7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.REnum7 {
			encoder.AppendValueInt32(int32(ri.Number()))
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message1")
	if x.RMessage1 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage1 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message2")
	if x.RMessage2 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage2 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message3")
	if x.RMessage3 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage3 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message4")
	if x.RMessage4 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage4 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message5")
	if x.RMessage5 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage5 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message6")
	if x.RMessage6 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage6 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("r_message7")
	if x.RMessage7 != nil {
		encoder.AppendArrayBegin()
		for _, ri := range x.RMessage7 {
			err = encoder.AppendValueInterface(ri)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendArrayEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string1")
	if x.MString1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string2")
	if x.MString2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string3")
	if x.MString3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string4")
	if x.MString4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString4 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string5")
	if x.MString5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString5 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string6")
	if x.MString6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString6 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string7")
	if x.MString7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString7 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string8")
	if x.MString8 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString8 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_string9")
	if x.MString9 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MString9 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueString(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_int32")
	if x.MInt32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_int64")
	if x.MInt64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MInt64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_uint32")
	if x.MUint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MUint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_uint64")
	if x.MUint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MUint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sint32")
	if x.MSint32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSint32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sint64")
	if x.MSint64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSint64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sfixed32")
	if x.MSfixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSfixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_sfixed64")
	if x.MSfixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MSfixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_fixed32")
	if x.MFixed32 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFixed32 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_fixed64")
	if x.MFixed64 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFixed64 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueUint64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_float")
	if x.MFloat != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MFloat {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat32(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_double")
	if x.MDouble != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MDouble {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueFloat64(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool1")
	if x.MBool1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool2")
	if x.MBool2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bool3")
	if x.MBool3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBool3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBool(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes1")
	if x.MBytes1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes2")
	if x.MBytes2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_bytes3")
	if x.MBytes3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MBytes3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueBytes(mv)
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum1")
	if x.MEnum1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum1 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum2")
	if x.MEnum2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum2 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum3")
	if x.MEnum3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum3 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum4")
	if x.MEnum4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum4 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum5")
	if x.MEnum5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum5 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum6")
	if x.MEnum6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum6 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_enum7")
	if x.MEnum7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MEnum7 {
			encoder.AppendMapKeyString(mk)
			encoder.AppendValueInt32(int32(mv.Number()))
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message1")
	if x.MMessage1 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage1 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message2")
	if x.MMessage2 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage2 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message3")
	if x.MMessage3 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage3 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message4")
	if x.MMessage4 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage4 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message5")
	if x.MMessage5 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage5 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message6")
	if x.MMessage6 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage6 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}
	encoder.AppendJSONKey("m_message7")
	if x.MMessage7 != nil {
		encoder.AppendObjectBegin()
		for mk, mv := range x.MMessage7 {
			encoder.AppendMapKeyString(mk)
			err = encoder.AppendValueInterface(mv)
			if err != nil {
				return nil, err
			}
		}
		encoder.AppendObjectEnd()
	} else {
		encoder.AppendValueNULL()
	}

	// Add end JSON identifier
	encoder.AppendObjectEnd()
	return encoder.Bytes(), err
}

// UnmarshalJSON implements json.Unmarshaler for proto message BenchModelComplex in file tests/proto/benchmark/benchmark.proto
func (x *BenchModelComplex) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbbenchmark.(*BenchModelComplex) is nil")
	}
	decoder, err := jsondecoder.New(b)
	if err != nil {
		return err
	}
	if ok, _err := decoder.CheckJSONBegin(); _err != nil || ok {
		return _err
	}
	// Loop to scan object.
LOOP_OBJECT:
	for {
		if err = decoder.ScanError(); err != nil {
			return err
		}
		if decoder.ReadObjectKeyBefore() { // before read object key
			break LOOP_OBJECT
		}
		// Read JSON key.
		jsonKey := decoder.ReadObjectKey()
		decoder.ReadObjectValueBefore() // Before read object value
		// match field with JSON key.
		switch {
		case jsonKey == "f_string1":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString1 = vv
		case jsonKey == "f_string2":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString2 = vv
		case jsonKey == "f_string3":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString3 = vv
		case jsonKey == "f_string4":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString4 = vv
		case jsonKey == "f_string5":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString5 = vv
		case jsonKey == "f_string6":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString6 = vv
		case jsonKey == "f_string7":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString7 = vv
		case jsonKey == "f_string8":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString8 = vv
		case jsonKey == "f_string9":
			vv, _err := decoder.ReadValueString(jsonKey)
			if _err != nil {
				return _err
			}
			x.FString9 = vv
		case jsonKey == "f_int32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FInt32 = vv
		case jsonKey == "f_int64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FInt64 = vv
		case jsonKey == "f_uint32":
			vv, _err := decoder.ReadValueUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FUint32 = vv
		case jsonKey == "f_uint64":
			vv, _err := decoder.ReadValueUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FUint64 = vv
		case jsonKey == "f_sint32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSint32 = vv
		case jsonKey == "f_sint64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSint64 = vv
		case jsonKey == "f_sfixed32":
			vv, _err := decoder.ReadValueInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSfixed32 = vv
		case jsonKey == "f_sfixed64":
			vv, _err := decoder.ReadValueInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FSfixed64 = vv
		case jsonKey == "f_fixed32":
			vv, _err := decoder.ReadValueUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFixed32 = vv
		case jsonKey == "f_fixed64":
			vv, _err := decoder.ReadValueUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFixed64 = vv
		case jsonKey == "f_float":
			vv, _err := decoder.ReadValueFloat32(jsonKey)
			if _err != nil {
				return _err
			}
			x.FFloat = vv
		case jsonKey == "f_double":
			vv, _err := decoder.ReadValueFloat64(jsonKey)
			if _err != nil {
				return _err
			}
			x.FDouble = vv
		case jsonKey == "f_bool1":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool1 = vv
		case jsonKey == "f_bool2":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool2 = vv
		case jsonKey == "f_bool3":
			vv, _err := decoder.ReadValueBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBool3 = vv
		case jsonKey == "f_bytes1":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBytes1 = vv
		case jsonKey == "f_bytes2":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBytes2 = vv
		case jsonKey == "f_bytes3":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.FBytes3 = vv
		case jsonKey == "f_enum1":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum1 = vv
		case jsonKey == "f_enum2":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum2 = vv
		case jsonKey == "f_enum3":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum3 = vv
		case jsonKey == "f_enum4":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum4 = vv
		case jsonKey == "f_enum5":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum5 = vv
		case jsonKey == "f_enum6":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum6 = vv
		case jsonKey == "f_enum7":
			v1, _err := decoder.ReadValueEnumNumber(jsonKey, Enum1_name)
			vv := Enum1(v1)
			if _err != nil {
				return _err
			}
			x.FEnum7 = vv
		case jsonKey == "f_message1":
			var vv *Message1
			if x.FMessage1 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage1
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage1 = vv
		case jsonKey == "f_message2":
			var vv *Message1
			if x.FMessage2 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage2
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage2 = vv
		case jsonKey == "f_message3":
			var vv *Message1
			if x.FMessage3 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage3
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage3 = vv
		case jsonKey == "f_message4":
			var vv *Message1
			if x.FMessage4 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage4
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage4 = vv
		case jsonKey == "f_message5":
			var vv *Message1
			if x.FMessage5 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage5
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage5 = vv
		case jsonKey == "f_message6":
			var vv *Message1
			if x.FMessage6 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage6
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage6 = vv
		case jsonKey == "f_message7":
			var vv *Message1
			if x.FMessage7 == nil {
				vv = new(Message1)
			} else {
				vv = x.FMessage7
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.FMessage7 = vv
		case jsonKey == "p_string1":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString1 = vv
		case jsonKey == "p_string2":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString2 = vv
		case jsonKey == "p_string3":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString3 = vv
		case jsonKey == "p_string4":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString4 = vv
		case jsonKey == "p_string5":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString5 = vv
		case jsonKey == "p_string6":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString6 = vv
		case jsonKey == "p_string7":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString7 = vv
		case jsonKey == "p_string8":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString8 = vv
		case jsonKey == "p_string9":
			vv, _err := decoder.ReadPointerString(jsonKey)
			if _err != nil {
				return _err
			}
			x.PString9 = vv
		case jsonKey == "p_int32":
			vv, _err := decoder.ReadPointerInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PInt32 = vv
		case jsonKey == "p_int64":
			vv, _err := decoder.ReadPointerInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PInt64 = vv
		case jsonKey == "p_uint32":
			vv, _err := decoder.ReadPointerUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PUint32 = vv
		case jsonKey == "p_uint64":
			vv, _err := decoder.ReadPointerUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PUint64 = vv
		case jsonKey == "p_sint32":
			vv, _err := decoder.ReadPointerInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PSint32 = vv
		case jsonKey == "p_sint64":
			vv, _err := decoder.ReadPointerInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PSint64 = vv
		case jsonKey == "p_sfixed32":
			vv, _err := decoder.ReadPointerInt32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PSfixed32 = vv
		case jsonKey == "p_sfixed64":
			vv, _err := decoder.ReadPointerInt64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PSfixed64 = vv
		case jsonKey == "p_fixed32":
			vv, _err := decoder.ReadPointerUint32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PFixed32 = vv
		case jsonKey == "p_fixed64":
			vv, _err := decoder.ReadPointerUint64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PFixed64 = vv
		case jsonKey == "p_float":
			vv, _err := decoder.ReadPointerFloat32(jsonKey)
			if _err != nil {
				return _err
			}
			x.PFloat = vv
		case jsonKey == "p_double":
			vv, _err := decoder.ReadPointerFloat64(jsonKey)
			if _err != nil {
				return _err
			}
			x.PDouble = vv
		case jsonKey == "p_bool1":
			vv, _err := decoder.ReadPointerBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBool1 = vv
		case jsonKey == "p_bool2":
			vv, _err := decoder.ReadPointerBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBool2 = vv
		case jsonKey == "p_bool3":
			vv, _err := decoder.ReadPointerBool(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBool3 = vv
		case jsonKey == "p_bytes1":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBytes1 = vv
		case jsonKey == "p_bytes2":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBytes2 = vv
		case jsonKey == "p_bytes3":
			vv, _err := decoder.ReadValueBytes(jsonKey)
			if _err != nil {
				return _err
			}
			x.PBytes3 = vv
		case jsonKey == "p_enum1":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum1 = vv
		case jsonKey == "p_enum2":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum2 = vv
		case jsonKey == "p_enum3":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum3 = vv
		case jsonKey == "p_enum4":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum4 = vv
		case jsonKey == "p_enum5":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum5 = vv
		case jsonKey == "p_enum6":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum6 = vv
		case jsonKey == "p_enum7":
			var vv *Enum1
			v1, _err := decoder.ReadPointerEnumNumber(jsonKey, Enum1_name)
			if v1 != nil {
				_vv := Enum1(*v1)
				vv = &_vv
			}
			if _err != nil {
				return _err
			}
			x.PEnum7 = vv
		case jsonKey == "p_message1":
			var vv *Message1
			if x.PMessage1 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage1
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage1 = vv
		case jsonKey == "p_message2":
			var vv *Message1
			if x.PMessage2 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage2
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage2 = vv
		case jsonKey == "p_message3":
			var vv *Message1
			if x.PMessage3 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage3
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage3 = vv
		case jsonKey == "p_message4":
			var vv *Message1
			if x.PMessage4 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage4
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage4 = vv
		case jsonKey == "p_message5":
			var vv *Message1
			if x.PMessage5 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage5
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage5 = vv
		case jsonKey == "p_message6":
			var vv *Message1
			if x.PMessage6 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage6
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage6 = vv
		case jsonKey == "p_message7":
			var vv *Message1
			if x.PMessage7 == nil {
				vv = new(Message1)
			} else {
				vv = x.PMessage7
			}
			ok, _err := decoder.ReadValueInterface(jsonKey, vv)
			if !ok { // The field is null
				vv = nil
			}
			if _err != nil {
				return _err
			}
			x.PMessage7 = vv
		case jsonKey == "r_string1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString1 == nil {
					x.RString1 = make([]string, 0)
				}
				i := 0
				length := len(x.RString1)
			LOOP_LIST_r_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string1
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString1[i] = vv
					} else {
						x.RString1 = append(x.RString1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string1
					}
				}
				if i < length {
					x.RString1 = x.RString1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString2 == nil {
					x.RString2 = make([]string, 0)
				}
				i := 0
				length := len(x.RString2)
			LOOP_LIST_r_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string2
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString2[i] = vv
					} else {
						x.RString2 = append(x.RString2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string2
					}
				}
				if i < length {
					x.RString2 = x.RString2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString3 == nil {
					x.RString3 = make([]string, 0)
				}
				i := 0
				length := len(x.RString3)
			LOOP_LIST_r_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string3
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString3[i] = vv
					} else {
						x.RString3 = append(x.RString3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string3
					}
				}
				if i < length {
					x.RString3 = x.RString3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString4 == nil {
					x.RString4 = make([]string, 0)
				}
				i := 0
				length := len(x.RString4)
			LOOP_LIST_r_string4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string4
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString4[i] = vv
					} else {
						x.RString4 = append(x.RString4, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string4
					}
				}
				if i < length {
					x.RString4 = x.RString4[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString5 == nil {
					x.RString5 = make([]string, 0)
				}
				i := 0
				length := len(x.RString5)
			LOOP_LIST_r_string5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string5
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString5[i] = vv
					} else {
						x.RString5 = append(x.RString5, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string5
					}
				}
				if i < length {
					x.RString5 = x.RString5[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString6 == nil {
					x.RString6 = make([]string, 0)
				}
				i := 0
				length := len(x.RString6)
			LOOP_LIST_r_string6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string6
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString6[i] = vv
					} else {
						x.RString6 = append(x.RString6, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string6
					}
				}
				if i < length {
					x.RString6 = x.RString6[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString7 == nil {
					x.RString7 = make([]string, 0)
				}
				i := 0
				length := len(x.RString7)
			LOOP_LIST_r_string7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string7
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString7[i] = vv
					} else {
						x.RString7 = append(x.RString7, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string7
					}
				}
				if i < length {
					x.RString7 = x.RString7[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string8":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString8 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString8 == nil {
					x.RString8 = make([]string, 0)
				}
				i := 0
				length := len(x.RString8)
			LOOP_LIST_r_string8:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string8
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString8[i] = vv
					} else {
						x.RString8 = append(x.RString8, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string8
					}
				}
				if i < length {
					x.RString8 = x.RString8[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_string9":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				} else {
					x.RString9 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []string", string(value), jsonKey)
				}
				if x.RString9 == nil {
					x.RString9 = make([]string, 0)
				}
				i := 0
				length := len(x.RString9)
			LOOP_LIST_r_string9:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_string9
					}
					vv, _err := decoder.ReadArrayElemString(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RString9[i] = vv
					} else {
						x.RString9 = append(x.RString9, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_string9
					}
				}
				if i < length {
					x.RString9 = x.RString9[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_int32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.RInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.RInt32 == nil {
					x.RInt32 = make([]int32, 0)
				}
				i := 0
				length := len(x.RInt32)
			LOOP_LIST_r_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_int32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RInt32[i] = vv
					} else {
						x.RInt32 = append(x.RInt32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_int32
					}
				}
				if i < length {
					x.RInt32 = x.RInt32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_int64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.RInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.RInt64 == nil {
					x.RInt64 = make([]int64, 0)
				}
				i := 0
				length := len(x.RInt64)
			LOOP_LIST_r_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_int64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RInt64[i] = vv
					} else {
						x.RInt64 = append(x.RInt64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_int64
					}
				}
				if i < length {
					x.RInt64 = x.RInt64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_uint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				} else {
					x.RUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				}
				if x.RUint32 == nil {
					x.RUint32 = make([]uint32, 0)
				}
				i := 0
				length := len(x.RUint32)
			LOOP_LIST_r_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_uint32
					}
					vv, _err := decoder.ReadArrayElemUint32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RUint32[i] = vv
					} else {
						x.RUint32 = append(x.RUint32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_uint32
					}
				}
				if i < length {
					x.RUint32 = x.RUint32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_uint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				} else {
					x.RUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				}
				if x.RUint64 == nil {
					x.RUint64 = make([]uint64, 0)
				}
				i := 0
				length := len(x.RUint64)
			LOOP_LIST_r_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_uint64
					}
					vv, _err := decoder.ReadArrayElemUint64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RUint64[i] = vv
					} else {
						x.RUint64 = append(x.RUint64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_uint64
					}
				}
				if i < length {
					x.RUint64 = x.RUint64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_sint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.RSint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.RSint32 == nil {
					x.RSint32 = make([]int32, 0)
				}
				i := 0
				length := len(x.RSint32)
			LOOP_LIST_r_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_sint32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RSint32[i] = vv
					} else {
						x.RSint32 = append(x.RSint32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_sint32
					}
				}
				if i < length {
					x.RSint32 = x.RSint32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_sint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.RSint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.RSint64 == nil {
					x.RSint64 = make([]int64, 0)
				}
				i := 0
				length := len(x.RSint64)
			LOOP_LIST_r_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_sint64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RSint64[i] = vv
					} else {
						x.RSint64 = append(x.RSint64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_sint64
					}
				}
				if i < length {
					x.RSint64 = x.RSint64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_sfixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				} else {
					x.RSfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int32", string(value), jsonKey)
				}
				if x.RSfixed32 == nil {
					x.RSfixed32 = make([]int32, 0)
				}
				i := 0
				length := len(x.RSfixed32)
			LOOP_LIST_r_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_sfixed32
					}
					vv, _err := decoder.ReadArrayElemInt32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RSfixed32[i] = vv
					} else {
						x.RSfixed32 = append(x.RSfixed32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_sfixed32
					}
				}
				if i < length {
					x.RSfixed32 = x.RSfixed32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_sfixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				} else {
					x.RSfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []int64", string(value), jsonKey)
				}
				if x.RSfixed64 == nil {
					x.RSfixed64 = make([]int64, 0)
				}
				i := 0
				length := len(x.RSfixed64)
			LOOP_LIST_r_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_sfixed64
					}
					vv, _err := decoder.ReadArrayElemInt64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RSfixed64[i] = vv
					} else {
						x.RSfixed64 = append(x.RSfixed64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_sfixed64
					}
				}
				if i < length {
					x.RSfixed64 = x.RSfixed64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_fixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				} else {
					x.RFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint32", string(value), jsonKey)
				}
				if x.RFixed32 == nil {
					x.RFixed32 = make([]uint32, 0)
				}
				i := 0
				length := len(x.RFixed32)
			LOOP_LIST_r_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_fixed32
					}
					vv, _err := decoder.ReadArrayElemUint32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RFixed32[i] = vv
					} else {
						x.RFixed32 = append(x.RFixed32, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_fixed32
					}
				}
				if i < length {
					x.RFixed32 = x.RFixed32[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_fixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				} else {
					x.RFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []uint64", string(value), jsonKey)
				}
				if x.RFixed64 == nil {
					x.RFixed64 = make([]uint64, 0)
				}
				i := 0
				length := len(x.RFixed64)
			LOOP_LIST_r_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_fixed64
					}
					vv, _err := decoder.ReadArrayElemUint64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RFixed64[i] = vv
					} else {
						x.RFixed64 = append(x.RFixed64, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_fixed64
					}
				}
				if i < length {
					x.RFixed64 = x.RFixed64[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_float":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), jsonKey)
				} else {
					x.RFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float32", string(value), jsonKey)
				}
				if x.RFloat == nil {
					x.RFloat = make([]float32, 0)
				}
				i := 0
				length := len(x.RFloat)
			LOOP_LIST_r_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_float
					}
					vv, _err := decoder.ReadArrayElemFloat32(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RFloat[i] = vv
					} else {
						x.RFloat = append(x.RFloat, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_float
					}
				}
				if i < length {
					x.RFloat = x.RFloat[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_double":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), jsonKey)
				} else {
					x.RDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []float64", string(value), jsonKey)
				}
				if x.RDouble == nil {
					x.RDouble = make([]float64, 0)
				}
				i := 0
				length := len(x.RDouble)
			LOOP_LIST_r_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_double
					}
					vv, _err := decoder.ReadArrayElemFloat64(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RDouble[i] = vv
					} else {
						x.RDouble = append(x.RDouble, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_double
					}
				}
				if i < length {
					x.RDouble = x.RDouble[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bool1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				} else {
					x.RBool1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				}
				if x.RBool1 == nil {
					x.RBool1 = make([]bool, 0)
				}
				i := 0
				length := len(x.RBool1)
			LOOP_LIST_r_bool1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bool1
					}
					vv, _err := decoder.ReadArrayElemBool(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBool1[i] = vv
					} else {
						x.RBool1 = append(x.RBool1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bool1
					}
				}
				if i < length {
					x.RBool1 = x.RBool1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bool2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				} else {
					x.RBool2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				}
				if x.RBool2 == nil {
					x.RBool2 = make([]bool, 0)
				}
				i := 0
				length := len(x.RBool2)
			LOOP_LIST_r_bool2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bool2
					}
					vv, _err := decoder.ReadArrayElemBool(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBool2[i] = vv
					} else {
						x.RBool2 = append(x.RBool2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bool2
					}
				}
				if i < length {
					x.RBool2 = x.RBool2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bool3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				} else {
					x.RBool3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []bool", string(value), jsonKey)
				}
				if x.RBool3 == nil {
					x.RBool3 = make([]bool, 0)
				}
				i := 0
				length := len(x.RBool3)
			LOOP_LIST_r_bool3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bool3
					}
					vv, _err := decoder.ReadArrayElemBool(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBool3[i] = vv
					} else {
						x.RBool3 = append(x.RBool3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bool3
					}
				}
				if i < length {
					x.RBool3 = x.RBool3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bytes1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				} else {
					x.RBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				}
				if x.RBytes1 == nil {
					x.RBytes1 = make([][]byte, 0)
				}
				i := 0
				length := len(x.RBytes1)
			LOOP_LIST_r_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bytes1
					}
					vv, _err := decoder.ReadArrayElemBytes(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBytes1[i] = vv
					} else {
						x.RBytes1 = append(x.RBytes1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bytes1
					}
				}
				if i < length {
					x.RBytes1 = x.RBytes1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bytes2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				} else {
					x.RBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				}
				if x.RBytes2 == nil {
					x.RBytes2 = make([][]byte, 0)
				}
				i := 0
				length := len(x.RBytes2)
			LOOP_LIST_r_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bytes2
					}
					vv, _err := decoder.ReadArrayElemBytes(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBytes2[i] = vv
					} else {
						x.RBytes2 = append(x.RBytes2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bytes2
					}
				}
				if i < length {
					x.RBytes2 = x.RBytes2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_bytes3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				} else {
					x.RBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type [][]byte", string(value), jsonKey)
				}
				if x.RBytes3 == nil {
					x.RBytes3 = make([][]byte, 0)
				}
				i := 0
				length := len(x.RBytes3)
			LOOP_LIST_r_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_bytes3
					}
					vv, _err := decoder.ReadArrayElemBytes(jsonKey)
					if _err != nil {
						return _err
					}
					if i < length {
						x.RBytes3[i] = vv
					} else {
						x.RBytes3 = append(x.RBytes3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_bytes3
					}
				}
				if i < length {
					x.RBytes3 = x.RBytes3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum1 == nil {
					x.REnum1 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum1)
			LOOP_LIST_r_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum1
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum1[i] = vv
					} else {
						x.REnum1 = append(x.REnum1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum1
					}
				}
				if i < length {
					x.REnum1 = x.REnum1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum2 == nil {
					x.REnum2 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum2)
			LOOP_LIST_r_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum2
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum2[i] = vv
					} else {
						x.REnum2 = append(x.REnum2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum2
					}
				}
				if i < length {
					x.REnum2 = x.REnum2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum3 == nil {
					x.REnum3 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum3)
			LOOP_LIST_r_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum3
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum3[i] = vv
					} else {
						x.REnum3 = append(x.REnum3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum3
					}
				}
				if i < length {
					x.REnum3 = x.REnum3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum4 == nil {
					x.REnum4 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum4)
			LOOP_LIST_r_enum4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum4
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum4[i] = vv
					} else {
						x.REnum4 = append(x.REnum4, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum4
					}
				}
				if i < length {
					x.REnum4 = x.REnum4[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum5 == nil {
					x.REnum5 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum5)
			LOOP_LIST_r_enum5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum5
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum5[i] = vv
					} else {
						x.REnum5 = append(x.REnum5, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum5
					}
				}
				if i < length {
					x.REnum5 = x.REnum5[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum6 == nil {
					x.REnum6 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum6)
			LOOP_LIST_r_enum6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum6
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum6[i] = vv
					} else {
						x.REnum6 = append(x.REnum6, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum6
					}
				}
				if i < length {
					x.REnum6 = x.REnum6[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_enum7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				} else {
					x.REnum7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []Enum1", string(value), jsonKey)
				}
				if x.REnum7 == nil {
					x.REnum7 = make([]Enum1, 0)
				}
				i := 0
				length := len(x.REnum7)
			LOOP_LIST_r_enum7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_enum7
					}
					v1, _err := decoder.ReadArrayElemEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					if i < length {
						x.REnum7[i] = vv
					} else {
						x.REnum7 = append(x.REnum7, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_enum7
					}
				}
				if i < length {
					x.REnum7 = x.REnum7[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage1 == nil {
					x.RMessage1 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage1)
			LOOP_LIST_r_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message1
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage1[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage1[i] = vv
					} else {
						x.RMessage1 = append(x.RMessage1, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message1
					}
				}
				if i < length {
					x.RMessage1 = x.RMessage1[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage2 == nil {
					x.RMessage2 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage2)
			LOOP_LIST_r_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message2
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage2[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage2[i] = vv
					} else {
						x.RMessage2 = append(x.RMessage2, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message2
					}
				}
				if i < length {
					x.RMessage2 = x.RMessage2[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage3 == nil {
					x.RMessage3 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage3)
			LOOP_LIST_r_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message3
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage3[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage3[i] = vv
					} else {
						x.RMessage3 = append(x.RMessage3, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message3
					}
				}
				if i < length {
					x.RMessage3 = x.RMessage3[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage4 == nil {
					x.RMessage4 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage4)
			LOOP_LIST_r_message4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message4
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage4[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage4[i] = vv
					} else {
						x.RMessage4 = append(x.RMessage4, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message4
					}
				}
				if i < length {
					x.RMessage4 = x.RMessage4[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage5 == nil {
					x.RMessage5 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage5)
			LOOP_LIST_r_message5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message5
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage5[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage5[i] = vv
					} else {
						x.RMessage5 = append(x.RMessage5, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message5
					}
				}
				if i < length {
					x.RMessage5 = x.RMessage5[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage6 == nil {
					x.RMessage6 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage6)
			LOOP_LIST_r_message6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message6
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage6[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage6[i] = vv
					} else {
						x.RMessage6 = append(x.RMessage6, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message6
					}
				}
				if i < length {
					x.RMessage6 = x.RMessage6[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "r_message7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				} else {
					x.RMessage7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanArrayBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as array into field %s of type []*Message1", string(value), jsonKey)
				}
				if x.RMessage7 == nil {
					x.RMessage7 = make([]*Message1, 0)
				}
				i := 0
				length := len(x.RMessage7)
			LOOP_LIST_r_message7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadArrayValueBefore() { // Before read array value.
						break LOOP_LIST_r_message7
					}
					var vv *Message1
					if i < length {
						vv = x.RMessage7[i]
					}
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadArrayElemInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					if i < length {
						x.RMessage7[i] = vv
					} else {
						x.RMessage7 = append(x.RMessage7, vv)
					}
					i++
					if decoder.AfterReadArrayValueAfter() { // After read array value.
						break LOOP_LIST_r_message7
					}
				}
				if i < length {
					x.RMessage7 = x.RMessage7[:i]
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString1 == nil {
					x.MString1 = make(map[string]string)
				}
			LOOP_MAP_m_string1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string1
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString1[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string1
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString2 == nil {
					x.MString2 = make(map[string]string)
				}
			LOOP_MAP_m_string2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string2
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString2[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string2
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString3 == nil {
					x.MString3 = make(map[string]string)
				}
			LOOP_MAP_m_string3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string3
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString3[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string3
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString4 == nil {
					x.MString4 = make(map[string]string)
				}
			LOOP_MAP_m_string4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string4
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString4[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string4
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString5 == nil {
					x.MString5 = make(map[string]string)
				}
			LOOP_MAP_m_string5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string5
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString5[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string5
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString6 == nil {
					x.MString6 = make(map[string]string)
				}
			LOOP_MAP_m_string6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string6
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString6[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string6
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString7 == nil {
					x.MString7 = make(map[string]string)
				}
			LOOP_MAP_m_string7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string7
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString7[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string7
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string8":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString8 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString8 == nil {
					x.MString8 = make(map[string]string)
				}
			LOOP_MAP_m_string8:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string8
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString8[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string8
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_string9":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				} else {
					x.MString9 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]string", string(value), jsonKey)
				}
				if x.MString9 == nil {
					x.MString9 = make(map[string]string)
				}
			LOOP_MAP_m_string9:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_string9
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueString(jsonKey)
					if _err != nil {
						return _err
					}
					x.MString9[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_string9
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_int32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				} else {
					x.MInt32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				}
				if x.MInt32 == nil {
					x.MInt32 = make(map[string]int32)
				}
			LOOP_MAP_m_int32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_int32
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MInt32[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_int32
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_int64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				} else {
					x.MInt64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				}
				if x.MInt64 == nil {
					x.MInt64 = make(map[string]int64)
				}
			LOOP_MAP_m_int64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_int64
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MInt64[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_int64
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_uint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint32", string(value), jsonKey)
				} else {
					x.MUint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint32", string(value), jsonKey)
				}
				if x.MUint32 == nil {
					x.MUint32 = make(map[string]uint32)
				}
			LOOP_MAP_m_uint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_uint32
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueUint32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MUint32[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_uint32
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_uint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint64", string(value), jsonKey)
				} else {
					x.MUint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint64", string(value), jsonKey)
				}
				if x.MUint64 == nil {
					x.MUint64 = make(map[string]uint64)
				}
			LOOP_MAP_m_uint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_uint64
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueUint64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MUint64[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_uint64
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_sint32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				} else {
					x.MSint32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				}
				if x.MSint32 == nil {
					x.MSint32 = make(map[string]int32)
				}
			LOOP_MAP_m_sint32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_sint32
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MSint32[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_sint32
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_sint64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				} else {
					x.MSint64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				}
				if x.MSint64 == nil {
					x.MSint64 = make(map[string]int64)
				}
			LOOP_MAP_m_sint64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_sint64
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MSint64[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_sint64
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_sfixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				} else {
					x.MSfixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int32", string(value), jsonKey)
				}
				if x.MSfixed32 == nil {
					x.MSfixed32 = make(map[string]int32)
				}
			LOOP_MAP_m_sfixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_sfixed32
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MSfixed32[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_sfixed32
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_sfixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				} else {
					x.MSfixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]int64", string(value), jsonKey)
				}
				if x.MSfixed64 == nil {
					x.MSfixed64 = make(map[string]int64)
				}
			LOOP_MAP_m_sfixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_sfixed64
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueInt64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MSfixed64[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_sfixed64
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_fixed32":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint32", string(value), jsonKey)
				} else {
					x.MFixed32 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint32", string(value), jsonKey)
				}
				if x.MFixed32 == nil {
					x.MFixed32 = make(map[string]uint32)
				}
			LOOP_MAP_m_fixed32:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_fixed32
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueUint32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MFixed32[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_fixed32
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_fixed64":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint64", string(value), jsonKey)
				} else {
					x.MFixed64 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]uint64", string(value), jsonKey)
				}
				if x.MFixed64 == nil {
					x.MFixed64 = make(map[string]uint64)
				}
			LOOP_MAP_m_fixed64:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_fixed64
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueUint64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MFixed64[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_fixed64
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_float":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]float32", string(value), jsonKey)
				} else {
					x.MFloat = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]float32", string(value), jsonKey)
				}
				if x.MFloat == nil {
					x.MFloat = make(map[string]float32)
				}
			LOOP_MAP_m_float:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_float
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueFloat32(jsonKey)
					if _err != nil {
						return _err
					}
					x.MFloat[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_float
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_double":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]float64", string(value), jsonKey)
				} else {
					x.MDouble = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]float64", string(value), jsonKey)
				}
				if x.MDouble == nil {
					x.MDouble = make(map[string]float64)
				}
			LOOP_MAP_m_double:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_double
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueFloat64(jsonKey)
					if _err != nil {
						return _err
					}
					x.MDouble[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_double
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bool1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				} else {
					x.MBool1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				}
				if x.MBool1 == nil {
					x.MBool1 = make(map[string]bool)
				}
			LOOP_MAP_m_bool1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bool1
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBool(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBool1[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bool1
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bool2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				} else {
					x.MBool2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				}
				if x.MBool2 == nil {
					x.MBool2 = make(map[string]bool)
				}
			LOOP_MAP_m_bool2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bool2
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBool(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBool2[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bool2
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bool3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				} else {
					x.MBool3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]bool", string(value), jsonKey)
				}
				if x.MBool3 == nil {
					x.MBool3 = make(map[string]bool)
				}
			LOOP_MAP_m_bool3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bool3
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBool(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBool3[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bool3
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bytes1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				} else {
					x.MBytes1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				}
				if x.MBytes1 == nil {
					x.MBytes1 = make(map[string][]byte)
				}
			LOOP_MAP_m_bytes1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bytes1
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBytes(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBytes1[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bytes1
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bytes2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				} else {
					x.MBytes2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				}
				if x.MBytes2 == nil {
					x.MBytes2 = make(map[string][]byte)
				}
			LOOP_MAP_m_bytes2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bytes2
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBytes(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBytes2[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bytes2
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_bytes3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				} else {
					x.MBytes3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string][]byte", string(value), jsonKey)
				}
				if x.MBytes3 == nil {
					x.MBytes3 = make(map[string][]byte)
				}
			LOOP_MAP_m_bytes3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_bytes3
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv, _err := decoder.ReadMapValueBytes(jsonKey)
					if _err != nil {
						return _err
					}
					x.MBytes3[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_bytes3
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum1 == nil {
					x.MEnum1 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum1
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum1[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum1
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum2 == nil {
					x.MEnum2 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum2
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum2[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum2
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum3 == nil {
					x.MEnum3 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum3
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum3[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum3
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum4 == nil {
					x.MEnum4 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum4
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum4[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum4
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum5 == nil {
					x.MEnum5 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum5
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum5[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum5
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum6 == nil {
					x.MEnum6 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum6
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum6[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum6
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_enum7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				} else {
					x.MEnum7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]Enum1", string(value), jsonKey)
				}
				if x.MEnum7 == nil {
					x.MEnum7 = make(map[string]Enum1)
				}
			LOOP_MAP_m_enum7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_enum7
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					v1, _err := decoder.ReadMapValueEnumNumber(jsonKey, Enum1_name)
					vv := Enum1(v1)
					if _err != nil {
						return _err
					}
					x.MEnum7[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_enum7
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message1":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage1 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage1 == nil {
					x.MMessage1 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message1:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message1
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage1[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage1[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message1
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message2":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage2 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage2 == nil {
					x.MMessage2 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message2:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message2
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage2[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage2[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message2
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message3":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage3 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage3 == nil {
					x.MMessage3 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message3:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message3
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage3[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage3[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message3
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message4":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage4 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage4 == nil {
					x.MMessage4 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message4:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message4
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage4[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage4[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message4
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message5":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage5 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage5 == nil {
					x.MMessage5 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message5:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message5
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage5[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage5[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message5
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message6":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage6 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage6 == nil {
					x.MMessage6 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message6:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message6
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage6[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage6[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message6
					}
				}
				decoder.ScanNext()
			}
		case jsonKey == "m_message7":
			if decoder.OpCode == jsondecoder.ScanLiteralBegin {
				value := decoder.ReadItem()
				if value[0] != 'n' {
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				} else {
					x.MMessage7 = nil
				}
			} else {
				if decoder.OpCode != jsondecoder.ScanObjectBegin {
					value := decoder.ReadItem()
					return fmt.Errorf("json: cannot unmarshal %s as map into field %s of type map[string]*Message1", string(value), jsonKey)
				}
				if x.MMessage7 == nil {
					x.MMessage7 = make(map[string]*Message1)
				}
			LOOP_MAP_m_message7:
				for {
					if err = decoder.ScanError(); err != nil {
						return err
					}
					if decoder.ReadObjectKeyBefore() { // before read object key
						break LOOP_MAP_m_message7
					}
					mapKey, _err := decoder.ReadMapKeyString(jsonKey)
					if _err != nil {
						return _err
					}
					decoder.ReadObjectValueBefore() // Before read object value
					vv := x.MMessage7[mapKey]
					if vv == nil {
						vv = new(Message1)
					}
					ok, _err := decoder.ReadMapValueInterface(jsonKey, vv)
					if !ok { // The field is null
						vv = nil
					}
					if _err != nil {
						return _err
					}
					x.MMessage7[mapKey] = vv
					if decoder.ReadObjectValueAfter() { // After read object value
						break LOOP_MAP_m_message7
					}
				}
				decoder.ScanNext()
			}
		default:
			_ = decoder.ReadItem() // discard unknown field
		}
		if decoder.ReadObjectValueAfter() { // After read object value
			break LOOP_OBJECT
		}
	}
	// Check error in decoder
	if err = decoder.ScanError(); err != nil {
		return err
	}
	return nil
}
