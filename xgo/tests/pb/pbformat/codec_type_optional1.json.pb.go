// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/format/codec_type_optional1.proto

package pbformat

import (
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	_ "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	_ "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message CodecTypeOptional1 in file tests/proto/cases/format/codec_type_optional1.proto
func (x *CodecTypeOptional1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(2960)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendPtrI32(enc, "f_int32_numeric", x.FInt32Numeric, false, false)
	jsonencoder.AppendPtrI32(enc, "f_int32_string", x.FInt32String, false, true)
	jsonencoder.AppendPtrI64(enc, "f_int64_numeric", x.FInt64Numeric, false, false)
	jsonencoder.AppendPtrI64(enc, "f_int64_string", x.FInt64String, false, true)
	jsonencoder.AppendPtrU32(enc, "f_uint32_numeric", x.FUint32Numeric, false, false)
	jsonencoder.AppendPtrU32(enc, "f_uint32_string", x.FUint32String, false, true)
	jsonencoder.AppendPtrU64(enc, "f_uint64_numeric", x.FUint64Numeric, false, false)
	jsonencoder.AppendPtrU64(enc, "f_uint64_string", x.FUint64String, false, true)
	jsonencoder.AppendPtrI32(enc, "f_sint32_numeric", x.FSint32Numeric, false, false)
	jsonencoder.AppendPtrI32(enc, "f_sint32_string", x.FSint32String, false, true)
	jsonencoder.AppendPtrI64(enc, "f_sint64_numeric", x.FSint64Numeric, false, false)
	jsonencoder.AppendPtrI64(enc, "f_sint64_string", x.FSint64String, false, true)
	jsonencoder.AppendPtrI32(enc, "f_sfixed32_numeric", x.FSfixed32Numeric, false, false)
	jsonencoder.AppendPtrI32(enc, "f_sfixed32_string", x.FSfixed32String, false, true)
	jsonencoder.AppendPtrI64(enc, "f_sfixed64_numeric", x.FSfixed64Numeric, false, false)
	jsonencoder.AppendPtrI64(enc, "f_sfixed64_string", x.FSfixed64String, false, true)
	jsonencoder.AppendPtrU32(enc, "f_fixed32_numeric", x.FFixed32Numeric, false, false)
	jsonencoder.AppendPtrU32(enc, "f_fixed32_string", x.FFixed32String, false, true)
	jsonencoder.AppendPtrU64(enc, "f_fixed64_numeric", x.FFixed64Numeric, false, false)
	jsonencoder.AppendPtrU64(enc, "f_fixed64_string", x.FFixed64String, false, true)
	jsonencoder.AppendPtrF32(enc, "f_float_numeric", x.FFloatNumeric, false, false)
	jsonencoder.AppendPtrF32(enc, "f_float_string", x.FFloatString, false, true)
	jsonencoder.AppendPtrF64(enc, "f_double_numeric", x.FDoubleNumeric, false, false)
	jsonencoder.AppendPtrF64(enc, "f_double_string", x.FDoubleString, false, true)
	jsonencoder.AppendPtrBool(enc, "f_bool_bool", x.FBoolBool, false, false)
	jsonencoder.AppendPtrBool(enc, "f_bool_string", x.FBoolString, false, true)
	jsonencoder.AppendPtrEnumNum(enc, "f_enum_numeric", x.FEnumNumeric, false, false)
	jsonencoder.AppendPtrEnumNum(enc, "f_enum_numeric_string", x.FEnumNumericString, false, true)
	jsonencoder.AppendPtrEnumStr(enc, "f_enum_string", x.FEnumString, false)
	if err := jsonencoder.AppendValWKTAnyObject(enc, "f_any_native", x.FAnyNative, false); err != nil {
		return nil, err
	}
	if err := jsonencoder.AppendValWKTAnyProto(enc, "f_any_proto", x.FAnyProto, false); err != nil {
		return nil, err
	}
	if err := jsonencoder.AppendValWKTDurObject(enc, "f_duration_native", x.FDurationNative, false); err != nil {
		return nil, err
	}
	jsonencoder.AppendValWKTDurTimeStr(enc, "f_duration_string", x.FDurationString, false)
	jsonencoder.AppendValWKTDurNano(enc, "f_duration_nanosecond", x.FDurationNanosecond, false, false)
	jsonencoder.AppendValWKTDurNano(enc, "f_duration_nanosecond_string", x.FDurationNanosecondString, false, true)
	jsonencoder.AppendValWKTDurMicro(enc, "f_duration_microsecond", x.FDurationMicrosecond, false, false)
	jsonencoder.AppendValWKTDurMicro(enc, "f_duration_microsecond_string", x.FDurationMicrosecondString, false, true)
	jsonencoder.AppendValWKTDurMilli(enc, "f_duration_millisecond", x.FDurationMillisecond, false, false)
	jsonencoder.AppendValWKTDurMilli(enc, "f_duration_millisecond_string", x.FDurationMillisecondString, false, true)
	jsonencoder.AppendValWKTDurSecond(enc, "f_duration_second", x.FDurationSecond, false, false)
	jsonencoder.AppendValWKTDurSecond(enc, "f_duration_second_string", x.FDurationSecondString, false, true)
	jsonencoder.AppendValWKTDurMinute(enc, "f_duration_minute", x.FDurationMinute, false, false)
	jsonencoder.AppendValWKTDurMinute(enc, "f_duration_minute_string", x.FDurationMinuteString, false, true)
	jsonencoder.AppendValWKTDurHour(enc, "f_duration_hour", x.FDurationHour, false, false)
	jsonencoder.AppendValWKTDurHour(enc, "f_duration_hour_string", x.FDurationHourString, false, true)
	if err := jsonencoder.AppendValWKTTsObject(enc, "f_timestamp_native", x.FTimestampNative, false); err != nil {
		return nil, err
	}
	jsonencoder.AppendValWKTTsLayout(enc, "f_timestamp_time_layout", x.FTimestampTimeLayout, false, "2006-01-02T15:04:05Z07:00")
	jsonencoder.AppendValWKTTsUnixNano(enc, "f_timestamp_unix_nano", x.FTimestampUnixNano, false, false)
	jsonencoder.AppendValWKTTsUnixNano(enc, "f_timestamp_unix_nano_string", x.FTimestampUnixNanoString, false, true)
	jsonencoder.AppendValWKTTsUnixMicro(enc, "f_timestamp_unix_micro", x.FTimestampUnixMicro, false, false)
	jsonencoder.AppendValWKTTsUnixMicro(enc, "f_timestamp_unix_micro_string", x.FTimestampUnixMicroString, false, true)
	jsonencoder.AppendValWKTTsUnixMilli(enc, "f_timestamp_unix_milli", x.FTimestampUnixMilli, false, false)
	jsonencoder.AppendValWKTTsUnixMilli(enc, "f_timestamp_unix_milli_string", x.FTimestampUnixMilliString, false, true)
	jsonencoder.AppendValWKTTsUnixSec(enc, "f_timestamp_unix_sec", x.FTimestampUnixSec, false, false)
	jsonencoder.AppendValWKTTsUnixSec(enc, "f_timestamp_unix_sec_string", x.FTimestampUnixSecString, false, true)
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message CodecTypeOptional1 in file tests/proto/cases/format/codec_type_optional1.proto
func (x *CodecTypeOptional1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return jsondecoder.ErrStructIsNIL("xgo/tests/pb/pbformat", "CodecTypeOptional1")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32_numeric":
			if x.FInt32Numeric, err = jsondecoder.ReadPtrI32(dec, x.FInt32Numeric, false); err != nil {
				return err
			}
		case "f_int32_string":
			if x.FInt32String, err = jsondecoder.ReadPtrI32(dec, x.FInt32String, true); err != nil {
				return err
			}
		case "f_int64_numeric":
			if x.FInt64Numeric, err = jsondecoder.ReadPtrI64(dec, x.FInt64Numeric, false); err != nil {
				return err
			}
		case "f_int64_string":
			if x.FInt64String, err = jsondecoder.ReadPtrI64(dec, x.FInt64String, true); err != nil {
				return err
			}
		case "f_uint32_numeric":
			if x.FUint32Numeric, err = jsondecoder.ReadPtrU32(dec, x.FUint32Numeric, false); err != nil {
				return err
			}
		case "f_uint32_string":
			if x.FUint32String, err = jsondecoder.ReadPtrU32(dec, x.FUint32String, true); err != nil {
				return err
			}
		case "f_uint64_numeric":
			if x.FUint64Numeric, err = jsondecoder.ReadPtrU64(dec, x.FUint64Numeric, false); err != nil {
				return err
			}
		case "f_uint64_string":
			if x.FUint64String, err = jsondecoder.ReadPtrU64(dec, x.FUint64String, true); err != nil {
				return err
			}
		case "f_sint32_numeric":
			if x.FSint32Numeric, err = jsondecoder.ReadPtrI32(dec, x.FSint32Numeric, false); err != nil {
				return err
			}
		case "f_sint32_string":
			if x.FSint32String, err = jsondecoder.ReadPtrI32(dec, x.FSint32String, true); err != nil {
				return err
			}
		case "f_sint64_numeric":
			if x.FSint64Numeric, err = jsondecoder.ReadPtrI64(dec, x.FSint64Numeric, false); err != nil {
				return err
			}
		case "f_sint64_string":
			if x.FSint64String, err = jsondecoder.ReadPtrI64(dec, x.FSint64String, true); err != nil {
				return err
			}
		case "f_sfixed32_numeric":
			if x.FSfixed32Numeric, err = jsondecoder.ReadPtrI32(dec, x.FSfixed32Numeric, false); err != nil {
				return err
			}
		case "f_sfixed32_string":
			if x.FSfixed32String, err = jsondecoder.ReadPtrI32(dec, x.FSfixed32String, true); err != nil {
				return err
			}
		case "f_sfixed64_numeric":
			if x.FSfixed64Numeric, err = jsondecoder.ReadPtrI64(dec, x.FSfixed64Numeric, false); err != nil {
				return err
			}
		case "f_sfixed64_string":
			if x.FSfixed64String, err = jsondecoder.ReadPtrI64(dec, x.FSfixed64String, true); err != nil {
				return err
			}
		case "f_fixed32_numeric":
			if x.FFixed32Numeric, err = jsondecoder.ReadPtrU32(dec, x.FFixed32Numeric, false); err != nil {
				return err
			}
		case "f_fixed32_string":
			if x.FFixed32String, err = jsondecoder.ReadPtrU32(dec, x.FFixed32String, true); err != nil {
				return err
			}
		case "f_fixed64_numeric":
			if x.FFixed64Numeric, err = jsondecoder.ReadPtrU64(dec, x.FFixed64Numeric, false); err != nil {
				return err
			}
		case "f_fixed64_string":
			if x.FFixed64String, err = jsondecoder.ReadPtrU64(dec, x.FFixed64String, true); err != nil {
				return err
			}
		case "f_float_numeric":
			if x.FFloatNumeric, err = jsondecoder.ReadPtrF32(dec, x.FFloatNumeric, false); err != nil {
				return err
			}
		case "f_float_string":
			if x.FFloatString, err = jsondecoder.ReadPtrF32(dec, x.FFloatString, true); err != nil {
				return err
			}
		case "f_double_numeric":
			if x.FDoubleNumeric, err = jsondecoder.ReadPtrF64(dec, x.FDoubleNumeric, false); err != nil {
				return err
			}
		case "f_double_string":
			if x.FDoubleString, err = jsondecoder.ReadPtrF64(dec, x.FDoubleString, true); err != nil {
				return err
			}
		case "f_bool_bool":
			if x.FBoolBool, err = jsondecoder.ReadPtrBool(dec, x.FBoolBool, false); err != nil {
				return err
			}
		case "f_bool_string":
			if x.FBoolString, err = jsondecoder.ReadPtrBool(dec, x.FBoolString, true); err != nil {
				return err
			}
		case "f_enum_numeric":
			if x.FEnumNumeric, err = jsondecoder.ReadPtrEnumNum(dec, x.FEnumNumeric, false); err != nil {
				return err
			}
		case "f_enum_numeric_string":
			if x.FEnumNumericString, err = jsondecoder.ReadPtrEnumNum(dec, x.FEnumNumericString, true); err != nil {
				return err
			}
		case "f_enum_string":
			if x.FEnumString, err = jsondecoder.ReadPtrEnumStr(dec, x.FEnumString); err != nil {
				return err
			}
		case "f_any_native":
			if x.FAnyNative, err = jsondecoder.ReadValWKTAnyObject(dec, x.FAnyNative); err != nil {
				return err
			}
		case "f_any_proto":
			if x.FAnyProto, err = jsondecoder.ReadValWKTAnyProto(dec, x.FAnyProto); err != nil {
				return err
			}
		case "f_duration_native":
			if x.FDurationNative, err = jsondecoder.ReadValWKTDurObject(dec, x.FDurationNative); err != nil {
				return err
			}
		case "f_duration_string":
			if x.FDurationString, err = jsondecoder.ReadValWKTDurTimeStr(dec, x.FDurationString); err != nil {
				return err
			}
		case "f_duration_nanosecond":
			if x.FDurationNanosecond, err = jsondecoder.ReadValWKTDurNano(dec, x.FDurationNanosecond, false); err != nil {
				return err
			}
		case "f_duration_nanosecond_string":
			if x.FDurationNanosecondString, err = jsondecoder.ReadValWKTDurNano(dec, x.FDurationNanosecondString, true); err != nil {
				return err
			}
		case "f_duration_microsecond":
			if x.FDurationMicrosecond, err = jsondecoder.ReadValWKTDurMicro(dec, x.FDurationMicrosecond, false); err != nil {
				return err
			}
		case "f_duration_microsecond_string":
			if x.FDurationMicrosecondString, err = jsondecoder.ReadValWKTDurMicro(dec, x.FDurationMicrosecondString, true); err != nil {
				return err
			}
		case "f_duration_millisecond":
			if x.FDurationMillisecond, err = jsondecoder.ReadValWKTDurMilli(dec, x.FDurationMillisecond, false); err != nil {
				return err
			}
		case "f_duration_millisecond_string":
			if x.FDurationMillisecondString, err = jsondecoder.ReadValWKTDurMilli(dec, x.FDurationMillisecondString, true); err != nil {
				return err
			}
		case "f_duration_second":
			if x.FDurationSecond, err = jsondecoder.ReadValWKTDurSecond(dec, x.FDurationSecond, false); err != nil {
				return err
			}
		case "f_duration_second_string":
			if x.FDurationSecondString, err = jsondecoder.ReadValWKTDurSecond(dec, x.FDurationSecondString, true); err != nil {
				return err
			}
		case "f_duration_minute":
			if x.FDurationMinute, err = jsondecoder.ReadValWKTDurMinute(dec, x.FDurationMinute, false); err != nil {
				return err
			}
		case "f_duration_minute_string":
			if x.FDurationMinuteString, err = jsondecoder.ReadValWKTDurMinute(dec, x.FDurationMinuteString, true); err != nil {
				return err
			}
		case "f_duration_hour":
			if x.FDurationHour, err = jsondecoder.ReadValWKTDurHour(dec, x.FDurationHour, false); err != nil {
				return err
			}
		case "f_duration_hour_string":
			if x.FDurationHourString, err = jsondecoder.ReadValWKTDurHour(dec, x.FDurationHourString, true); err != nil {
				return err
			}
		case "f_timestamp_native":
			if x.FTimestampNative, err = jsondecoder.ReadValWKTTsObject(dec, x.FTimestampNative); err != nil {
				return err
			}
		case "f_timestamp_time_layout":
			if x.FTimestampTimeLayout, err = jsondecoder.ReadValWKTTsLayout(dec, x.FTimestampTimeLayout, "2006-01-02T15:04:05Z07:00"); err != nil {
				return err
			}
		case "f_timestamp_unix_nano":
			if x.FTimestampUnixNano, err = jsondecoder.ReadValWKTTsUnixNano(dec, x.FTimestampUnixNano, false); err != nil {
				return err
			}
		case "f_timestamp_unix_nano_string":
			if x.FTimestampUnixNanoString, err = jsondecoder.ReadValWKTTsUnixNano(dec, x.FTimestampUnixNanoString, true); err != nil {
				return err
			}
		case "f_timestamp_unix_micro":
			if x.FTimestampUnixMicro, err = jsondecoder.ReadValWKTTsUnixMicro(dec, x.FTimestampUnixMicro, false); err != nil {
				return err
			}
		case "f_timestamp_unix_micro_string":
			if x.FTimestampUnixMicroString, err = jsondecoder.ReadValWKTTsUnixMicro(dec, x.FTimestampUnixMicroString, true); err != nil {
				return err
			}
		case "f_timestamp_unix_milli":
			if x.FTimestampUnixMilli, err = jsondecoder.ReadValWKTTsUnixMilli(dec, x.FTimestampUnixMilli, false); err != nil {
				return err
			}
		case "f_timestamp_unix_milli_string":
			if x.FTimestampUnixMilliString, err = jsondecoder.ReadValWKTTsUnixMilli(dec, x.FTimestampUnixMilliString, true); err != nil {
				return err
			}
		case "f_timestamp_unix_sec":
			if x.FTimestampUnixSec, err = jsondecoder.ReadValWKTTsUnixSec(dec, x.FTimestampUnixSec, false); err != nil {
				return err
			}
		case "f_timestamp_unix_sec_string":
			if x.FTimestampUnixSecString, err = jsondecoder.ReadValWKTTsUnixSec(dec, x.FTimestampUnixSecString, true); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
