// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/format/wkt_map.proto

package pbformat

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	_ "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message WKTMap1 in file tests/proto/cases/format/wkt_map.proto
func (x *WKTMap1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(1408)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendMapStrEnumNum(enc, "f_enum_number1", x.FEnumNumber1, false, false)
	jsonencoder.AppendMapStrEnumNum(enc, "f_enum_number_string1", x.FEnumNumberString1, false, true)
	jsonencoder.AppendMapStrEnumStr(enc, "f_enum_string1", x.FEnumString1, false)
	if err := jsonencoder.AppendMapStrWKTAnyObject(enc, "f_any_native1", x.FAnyNative1, false); err != nil {
		return nil, err
	}
	if err := jsonencoder.AppendMapStrWKTAnyProto(enc, "f_any_proto1", x.FAnyProto1, false); err != nil {
		return nil, err
	}
	if err := jsonencoder.AppendMapStrWKTDurObject(enc, "f_duration_native1", x.FDurationNative1, false); err != nil {
		return nil, err
	}
	jsonencoder.AppendMapStrWKTDurTimeStr(enc, "f_duration_string1", x.FDurationString1, false)
	jsonencoder.AppendMapStrWKTDurNano(enc, "f_duration_nanosecond1", x.FDurationNanosecond1, false, false)
	jsonencoder.AppendMapStrWKTDurNano(enc, "f_duration_nanosecond_string1", x.FDurationNanosecondString1, false, true)
	jsonencoder.AppendMapStrWKTDurMicro(enc, "f_duration_microsecond1", x.FDurationMicrosecond1, false, false)
	jsonencoder.AppendMapStrWKTDurMicro(enc, "f_duration_microsecond_string1", x.FDurationMicrosecondString1, false, true)
	jsonencoder.AppendMapStrWKTDurMilli(enc, "f_duration_millisecond1", x.FDurationMillisecond1, false, false)
	jsonencoder.AppendMapStrWKTDurMilli(enc, "f_duration_millisecond_string1", x.FDurationMillisecondString1, false, true)
	jsonencoder.AppendMapStrWKTDurSecond(enc, "f_duration_second1", x.FDurationSecond1, false, false)
	jsonencoder.AppendMapStrWKTDurSecond(enc, "f_duration_second_string1", x.FDurationSecondString1, false, true)
	jsonencoder.AppendMapStrWKTDurMinute(enc, "f_duration_minute1", x.FDurationMinute1, false, false)
	jsonencoder.AppendMapStrWKTDurMinute(enc, "f_duration_minute_string1", x.FDurationMinuteString1, false, true)
	jsonencoder.AppendMapStrWKTDurHour(enc, "f_duration_hour1", x.FDurationHour1, false, false)
	jsonencoder.AppendMapStrWKTDurHour(enc, "f_duration_hour_string1", x.FDurationHourString1, false, true)
	if err := jsonencoder.AppendMapStrWKTTsObject(enc, "f_timestamp_native1", x.FTimestampNative1, false); err != nil {
		return nil, err
	}
	jsonencoder.AppendMapStrWKTTsLayout(enc, "f_timestamp_time_layout1", x.FTimestampTimeLayout1, false, "2006-01-02T15:04:05Z07:00")
	jsonencoder.AppendMapStrWKTTsUnixNano(enc, "f_timestamp_unix_nano1", x.FTimestampUnixNano1, false, false)
	jsonencoder.AppendMapStrWKTTsUnixNano(enc, "f_timestamp_unix_nano_string1", x.FTimestampUnixNanoString1, false, true)
	jsonencoder.AppendMapStrWKTTsUnixMicro(enc, "f_timestamp_unix_micro1", x.FTimestampUnixMicro1, false, false)
	jsonencoder.AppendMapStrWKTTsUnixMicro(enc, "f_timestamp_unix_micro_string1", x.FTimestampUnixMicroString1, false, true)
	jsonencoder.AppendMapStrWKTTsUnixMilli(enc, "f_timestamp_unix_milli1", x.FTimestampUnixMilli1, false, false)
	jsonencoder.AppendMapStrWKTTsUnixMilli(enc, "f_timestamp_unix_milli_string1", x.FTimestampUnixMilliString1, false, true)
	jsonencoder.AppendMapStrWKTTsUnixSec(enc, "f_timestamp_unix_sec1", x.FTimestampUnixSec1, false, false)
	jsonencoder.AppendMapStrWKTTsUnixSec(enc, "f_timestamp_unix_sec_string1", x.FTimestampUnixSecString1, false, true)
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message WKTMap1 in file tests/proto/cases/format/wkt_map.proto
func (x *WKTMap1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbformat.(*WKTMap1) is nil")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_enum_number1":
			if x.FEnumNumber1, err = jsondecoder.ReadMapStrEnumNum(dec, x.FEnumNumber1, false); err != nil {
				return err
			}
		case "f_enum_number_string1":
			if x.FEnumNumberString1, err = jsondecoder.ReadMapStrEnumNum(dec, x.FEnumNumberString1, true); err != nil {
				return err
			}
		case "f_enum_string1":
			if x.FEnumString1, err = jsondecoder.ReadMapStrEnumStr(dec, x.FEnumString1, Enum1_value); err != nil {
				return err
			}
		case "f_any_native1":
			if x.FAnyNative1, err = jsondecoder.ReadMapStrWKTAnyObject(dec, x.FAnyNative1); err != nil {
				return err
			}
		case "f_any_proto1":
			if x.FAnyProto1, err = jsondecoder.ReadMapStrWKTAnyProto(dec, x.FAnyProto1); err != nil {
				return err
			}
		case "f_duration_native1":
			if x.FDurationNative1, err = jsondecoder.ReadMapStrWKTDurObject(dec, x.FDurationNative1); err != nil {
				return err
			}
		case "f_duration_string1":
			if x.FDurationString1, err = jsondecoder.ReadMapStrWKTDurTimeStr(dec, x.FDurationString1); err != nil {
				return err
			}
		case "f_duration_nanosecond1":
			if x.FDurationNanosecond1, err = jsondecoder.ReadMapStrWKTDurNano(dec, x.FDurationNanosecond1, false); err != nil {
				return err
			}
		case "f_duration_nanosecond_string1":
			if x.FDurationNanosecondString1, err = jsondecoder.ReadMapStrWKTDurNano(dec, x.FDurationNanosecondString1, true); err != nil {
				return err
			}
		case "f_duration_microsecond1":
			if x.FDurationMicrosecond1, err = jsondecoder.ReadMapStrWKTDurMicro(dec, x.FDurationMicrosecond1, false); err != nil {
				return err
			}
		case "f_duration_microsecond_string1":
			if x.FDurationMicrosecondString1, err = jsondecoder.ReadMapStrWKTDurMicro(dec, x.FDurationMicrosecondString1, true); err != nil {
				return err
			}
		case "f_duration_millisecond1":
			if x.FDurationMillisecond1, err = jsondecoder.ReadMapStrWKTDurMilli(dec, x.FDurationMillisecond1, false); err != nil {
				return err
			}
		case "f_duration_millisecond_string1":
			if x.FDurationMillisecondString1, err = jsondecoder.ReadMapStrWKTDurMilli(dec, x.FDurationMillisecondString1, true); err != nil {
				return err
			}
		case "f_duration_second1":
			if x.FDurationSecond1, err = jsondecoder.ReadMapStrWKTDurSecond(dec, x.FDurationSecond1, false); err != nil {
				return err
			}
		case "f_duration_second_string1":
			if x.FDurationSecondString1, err = jsondecoder.ReadMapStrWKTDurSecond(dec, x.FDurationSecondString1, true); err != nil {
				return err
			}
		case "f_duration_minute1":
			if x.FDurationMinute1, err = jsondecoder.ReadMapStrWKTDurMinute(dec, x.FDurationMinute1, false); err != nil {
				return err
			}
		case "f_duration_minute_string1":
			if x.FDurationMinuteString1, err = jsondecoder.ReadMapStrWKTDurMinute(dec, x.FDurationMinuteString1, true); err != nil {
				return err
			}
		case "f_duration_hour1":
			if x.FDurationHour1, err = jsondecoder.ReadMapStrWKTDurHour(dec, x.FDurationHour1, false); err != nil {
				return err
			}
		case "f_duration_hour_string1":
			if x.FDurationHourString1, err = jsondecoder.ReadMapStrWKTDurHour(dec, x.FDurationHourString1, true); err != nil {
				return err
			}
		case "f_timestamp_native1":
			if x.FTimestampNative1, err = jsondecoder.ReadMapStrWKTTsObject(dec, x.FTimestampNative1); err != nil {
				return err
			}
		case "f_timestamp_time_layout1":
			if x.FTimestampTimeLayout1, err = jsondecoder.ReadMapStrWKTTsLayout(dec, x.FTimestampTimeLayout1, "2006-01-02T15:04:05Z07:00"); err != nil {
				return err
			}
		case "f_timestamp_unix_nano1":
			if x.FTimestampUnixNano1, err = jsondecoder.ReadMapStrWKTTsUnixNano(dec, x.FTimestampUnixNano1, false); err != nil {
				return err
			}
		case "f_timestamp_unix_nano_string1":
			if x.FTimestampUnixNanoString1, err = jsondecoder.ReadMapStrWKTTsUnixNano(dec, x.FTimestampUnixNanoString1, true); err != nil {
				return err
			}
		case "f_timestamp_unix_micro1":
			if x.FTimestampUnixMicro1, err = jsondecoder.ReadMapStrWKTTsUnixMicro(dec, x.FTimestampUnixMicro1, false); err != nil {
				return err
			}
		case "f_timestamp_unix_micro_string1":
			if x.FTimestampUnixMicroString1, err = jsondecoder.ReadMapStrWKTTsUnixMicro(dec, x.FTimestampUnixMicroString1, true); err != nil {
				return err
			}
		case "f_timestamp_unix_milli1":
			if x.FTimestampUnixMilli1, err = jsondecoder.ReadMapStrWKTTsUnixMilli(dec, x.FTimestampUnixMilli1, false); err != nil {
				return err
			}
		case "f_timestamp_unix_milli_string1":
			if x.FTimestampUnixMilliString1, err = jsondecoder.ReadMapStrWKTTsUnixMilli(dec, x.FTimestampUnixMilliString1, true); err != nil {
				return err
			}
		case "f_timestamp_unix_sec1":
			if x.FTimestampUnixSec1, err = jsondecoder.ReadMapStrWKTTsUnixSec(dec, x.FTimestampUnixSec1, false); err != nil {
				return err
			}
		case "f_timestamp_unix_sec_string1":
			if x.FTimestampUnixSecString1, err = jsondecoder.ReadMapStrWKTTsUnixSec(dec, x.FTimestampUnixSecString1, true); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
