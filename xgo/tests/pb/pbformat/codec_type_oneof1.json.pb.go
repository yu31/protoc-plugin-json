// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/format/codec_type_oneof1.proto

package pbformat

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
	_ "github.com/yu31/protoc-plugin-json/xgo/tests/pb/pbexternal"
	_ "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

// MarshalJSON implements interface json.Marshaler for proto message CodecTypeOneOf1 in file tests/proto/cases/format/codec_type_oneof1.proto
func (x *CodecTypeOneOf1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(3368)
	enc.AppendObjectBegin() // Add begin JSON identifier

	switch o1_1 := x.OneInt32.(type) {
	case *CodecTypeOneOf1_FInt32Numeric:
		jsonencoder.AppendValI32(enc, "f_int32_numeric", o1_1.FInt32Numeric, false, false)
	case *CodecTypeOneOf1_FInt32String:
		jsonencoder.AppendValI32(enc, "f_int32_string", o1_1.FInt32String, false, true)
	}
	enc.AppendObjectKey("one_int64")
	if x.OneInt64 != nil {
		enc.AppendObjectBegin()
		switch o1_4 := x.OneInt64.(type) {
		case *CodecTypeOneOf1_FInt64Numeric:
			jsonencoder.AppendValI64(enc, "f_int64_numeric", o1_4.FInt64Numeric, false, false)
		case *CodecTypeOneOf1_FInt64String:
			jsonencoder.AppendValI64(enc, "f_int64_string", o1_4.FInt64String, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_7 := x.OneUint32.(type) {
	case *CodecTypeOneOf1_FUint32Numeric:
		jsonencoder.AppendValU32(enc, "f_uint32_numeric", o1_7.FUint32Numeric, false, false)
	case *CodecTypeOneOf1_FUint32String:
		jsonencoder.AppendValU32(enc, "f_uint32_string", o1_7.FUint32String, false, true)
	}
	enc.AppendObjectKey("one_uint64")
	if x.OneUint64 != nil {
		enc.AppendObjectBegin()
		switch o1_10 := x.OneUint64.(type) {
		case *CodecTypeOneOf1_FUint64Numeric:
			jsonencoder.AppendValU64(enc, "f_uint64_numeric", o1_10.FUint64Numeric, false, false)
		case *CodecTypeOneOf1_FUint64String:
			jsonencoder.AppendValU64(enc, "f_uint64_string", o1_10.FUint64String, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_13 := x.OneSInt32.(type) {
	case *CodecTypeOneOf1_FSint32Numeric:
		jsonencoder.AppendValI32(enc, "f_sint32_numeric", o1_13.FSint32Numeric, false, false)
	case *CodecTypeOneOf1_FSint32String:
		jsonencoder.AppendValI32(enc, "f_sint32_string", o1_13.FSint32String, false, true)
	}
	enc.AppendObjectKey("one_sint64")
	if x.OneSInt64 != nil {
		enc.AppendObjectBegin()
		switch o1_16 := x.OneSInt64.(type) {
		case *CodecTypeOneOf1_FSint64Numeric:
			jsonencoder.AppendValI64(enc, "f_sint64_numeric", o1_16.FSint64Numeric, false, false)
		case *CodecTypeOneOf1_FSint64String:
			jsonencoder.AppendValI64(enc, "f_sint64_string", o1_16.FSint64String, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_19 := x.OneSFixed32.(type) {
	case *CodecTypeOneOf1_FSfixed32Numeric:
		jsonencoder.AppendValI32(enc, "f_sfixed32_numeric", o1_19.FSfixed32Numeric, false, false)
	case *CodecTypeOneOf1_FSfixed32String:
		jsonencoder.AppendValI32(enc, "f_sfixed32_string", o1_19.FSfixed32String, false, true)
	}
	enc.AppendObjectKey("one_sfixed64")
	if x.OneSFixed64 != nil {
		enc.AppendObjectBegin()
		switch o1_22 := x.OneSFixed64.(type) {
		case *CodecTypeOneOf1_FSfixed64Numeric:
			jsonencoder.AppendValI64(enc, "f_sfixed64_numeric", o1_22.FSfixed64Numeric, false, false)
		case *CodecTypeOneOf1_FSfixed64String:
			jsonencoder.AppendValI64(enc, "f_sfixed64_string", o1_22.FSfixed64String, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_25 := x.OneFixed32.(type) {
	case *CodecTypeOneOf1_FFixed32Numeric:
		jsonencoder.AppendValU32(enc, "f_fixed32_numeric", o1_25.FFixed32Numeric, false, false)
	case *CodecTypeOneOf1_FFixed32String:
		jsonencoder.AppendValU32(enc, "f_fixed32_string", o1_25.FFixed32String, false, true)
	}
	enc.AppendObjectKey("one_fixed64")
	if x.OneFixed64 != nil {
		enc.AppendObjectBegin()
		switch o1_28 := x.OneFixed64.(type) {
		case *CodecTypeOneOf1_FFixed64Numeric:
			jsonencoder.AppendValU64(enc, "f_fixed64_numeric", o1_28.FFixed64Numeric, false, false)
		case *CodecTypeOneOf1_FFixed64String:
			jsonencoder.AppendValU64(enc, "f_fixed64_string", o1_28.FFixed64String, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_31 := x.OneFloat.(type) {
	case *CodecTypeOneOf1_FFloatNumeric:
		jsonencoder.AppendValF32(enc, "f_float_numeric", o1_31.FFloatNumeric, false, false)
	case *CodecTypeOneOf1_FFloatString:
		jsonencoder.AppendValF32(enc, "f_float_string", o1_31.FFloatString, false, true)
	}
	enc.AppendObjectKey("one_double")
	if x.OneDouble != nil {
		enc.AppendObjectBegin()
		switch o1_34 := x.OneDouble.(type) {
		case *CodecTypeOneOf1_FDoubleNumeric:
			jsonencoder.AppendValF64(enc, "f_double_numeric", o1_34.FDoubleNumeric, false, false)
		case *CodecTypeOneOf1_FDoubleString:
			jsonencoder.AppendValF64(enc, "f_double_string", o1_34.FDoubleString, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_37 := x.OneBool.(type) {
	case *CodecTypeOneOf1_FBoolBool:
		jsonencoder.AppendValBool(enc, "f_bool_bool", o1_37.FBoolBool, false, false)
	case *CodecTypeOneOf1_FBoolString:
		jsonencoder.AppendValBool(enc, "f_bool_string", o1_37.FBoolString, false, true)
	}
	enc.AppendObjectKey("one_enum1")
	if x.OneEnum1 != nil {
		enc.AppendObjectBegin()
		switch o1_40 := x.OneEnum1.(type) {
		case *CodecTypeOneOf1_FEnumNumeric:
			jsonencoder.AppendValEnumNum(enc, "f_enum_numeric", o1_40.FEnumNumeric, false, false)
		case *CodecTypeOneOf1_FEnumString:
			jsonencoder.AppendValEnumStr(enc, "f_enum_string", o1_40.FEnumString, false)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_43 := x.OneEnum2.(type) {
	case *CodecTypeOneOf1_FEnumNumericString1:
		jsonencoder.AppendValEnumNum(enc, "f_enum_numeric_string1", o1_43.FEnumNumericString1, false, true)
	case *CodecTypeOneOf1_FEnumNumericString2:
		jsonencoder.AppendValEnumNum(enc, "f_enum_numeric_string2", o1_43.FEnumNumericString2, false, true)
	}
	switch o1_46 := x.OneAny1.(type) {
	case *CodecTypeOneOf1_FAnyNative:
		if err := jsonencoder.AppendValWKTAnyObject(enc, "f_any_native", o1_46.FAnyNative, false); err != nil {
			return nil, err
		}
	case *CodecTypeOneOf1_FAnyProto:
		if err := jsonencoder.AppendValWKTAnyProto(enc, "f_any_proto", o1_46.FAnyProto, false); err != nil {
			return nil, err
		}
	}
	enc.AppendObjectKey("one_duration1")
	if x.OneDuration1 != nil {
		enc.AppendObjectBegin()
		switch o1_49 := x.OneDuration1.(type) {
		case *CodecTypeOneOf1_FDurationNative:
			if err := jsonencoder.AppendValWKTDurObject(enc, "f_duration_native", o1_49.FDurationNative, false); err != nil {
				return nil, err
			}
		case *CodecTypeOneOf1_FDurationString:
			jsonencoder.AppendValWKTDurTimeStr(enc, "f_duration_string", o1_49.FDurationString, false)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_52 := x.OneDuration2.(type) {
	case *CodecTypeOneOf1_FDurationNanosecond:
		jsonencoder.AppendValWKTDurNano(enc, "f_duration_nanosecond", o1_52.FDurationNanosecond, false, false)
	case *CodecTypeOneOf1_FDurationMicrosecond:
		jsonencoder.AppendValWKTDurMicro(enc, "f_duration_microsecond", o1_52.FDurationMicrosecond, false, false)
	}
	enc.AppendObjectKey("one_duration3")
	if x.OneDuration3 != nil {
		enc.AppendObjectBegin()
		switch o1_55 := x.OneDuration3.(type) {
		case *CodecTypeOneOf1_FDurationMillisecond:
			jsonencoder.AppendValWKTDurMilli(enc, "f_duration_millisecond", o1_55.FDurationMillisecond, false, false)
		case *CodecTypeOneOf1_FDurationSecond:
			jsonencoder.AppendValWKTDurSecond(enc, "f_duration_second", o1_55.FDurationSecond, false, false)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_58 := x.OneDuration4.(type) {
	case *CodecTypeOneOf1_FDurationMinute:
		jsonencoder.AppendValWKTDurMinute(enc, "f_duration_minute", o1_58.FDurationMinute, false, false)
	case *CodecTypeOneOf1_FDurationHour:
		jsonencoder.AppendValWKTDurHour(enc, "f_duration_hour", o1_58.FDurationHour, false, false)
	}
	enc.AppendObjectKey("one_duration5")
	if x.OneDuration5 != nil {
		enc.AppendObjectBegin()
		switch o1_61 := x.OneDuration5.(type) {
		case *CodecTypeOneOf1_FDurationNanosecondString:
			jsonencoder.AppendValWKTDurNano(enc, "f_duration_nanosecond_string", o1_61.FDurationNanosecondString, false, true)
		case *CodecTypeOneOf1_FDurationMicrosecondString:
			jsonencoder.AppendValWKTDurMicro(enc, "f_duration_microsecond_string", o1_61.FDurationMicrosecondString, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_64 := x.OneDuration6.(type) {
	case *CodecTypeOneOf1_FDurationMillisecondString:
		jsonencoder.AppendValWKTDurMilli(enc, "f_duration_millisecond_string", o1_64.FDurationMillisecondString, false, true)
	case *CodecTypeOneOf1_FDurationSecondString:
		jsonencoder.AppendValWKTDurSecond(enc, "f_duration_second_string", o1_64.FDurationSecondString, false, true)
	}
	enc.AppendObjectKey("one_duration7")
	if x.OneDuration7 != nil {
		enc.AppendObjectBegin()
		switch o1_67 := x.OneDuration7.(type) {
		case *CodecTypeOneOf1_FDurationMinuteString:
			jsonencoder.AppendValWKTDurMinute(enc, "f_duration_minute_string", o1_67.FDurationMinuteString, false, true)
		case *CodecTypeOneOf1_FDurationHourString:
			jsonencoder.AppendValWKTDurHour(enc, "f_duration_hour_string", o1_67.FDurationHourString, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	enc.AppendObjectKey("one_timestamp1")
	if x.OneTimestamp1 != nil {
		enc.AppendObjectBegin()
		switch o1_70 := x.OneTimestamp1.(type) {
		case *CodecTypeOneOf1_FTimestampNative:
			if err := jsonencoder.AppendValWKTTsObject(enc, "f_timestamp_native", o1_70.FTimestampNative, false); err != nil {
				return nil, err
			}
		case *CodecTypeOneOf1_FTimestampTimeLayout:
			jsonencoder.AppendValWKTTsLayout(enc, "f_timestamp_time_layout", o1_70.FTimestampTimeLayout, false, "2006-01-02T15:04:05Z07:00")
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_73 := x.OneTimestamp2.(type) {
	case *CodecTypeOneOf1_FTimestampUnixNano:
		jsonencoder.AppendValWKTTsUnixNano(enc, "f_timestamp_unix_nano", o1_73.FTimestampUnixNano, false, false)
	case *CodecTypeOneOf1_FTimestampUnixMicro:
		jsonencoder.AppendValWKTTsUnixMicro(enc, "f_timestamp_unix_micro", o1_73.FTimestampUnixMicro, false, false)
	}
	enc.AppendObjectKey("one_timestamp3")
	if x.OneTimestamp3 != nil {
		enc.AppendObjectBegin()
		switch o1_76 := x.OneTimestamp3.(type) {
		case *CodecTypeOneOf1_FTimestampUnixMilli:
			jsonencoder.AppendValWKTTsUnixMilli(enc, "f_timestamp_unix_milli", o1_76.FTimestampUnixMilli, false, false)
		case *CodecTypeOneOf1_FTimestampUnixSec:
			jsonencoder.AppendValWKTTsUnixSec(enc, "f_timestamp_unix_sec", o1_76.FTimestampUnixSec, false, false)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_79 := x.OneTimestamp4.(type) {
	case *CodecTypeOneOf1_FTimestampUnixNanoString:
		jsonencoder.AppendValWKTTsUnixNano(enc, "f_timestamp_unix_nano_string", o1_79.FTimestampUnixNanoString, false, true)
	case *CodecTypeOneOf1_FTimestampUnixMicroString:
		jsonencoder.AppendValWKTTsUnixMicro(enc, "f_timestamp_unix_micro_string", o1_79.FTimestampUnixMicroString, false, true)
	}
	enc.AppendObjectKey("one_timestamp5")
	if x.OneTimestamp5 != nil {
		enc.AppendObjectBegin()
		switch o1_82 := x.OneTimestamp5.(type) {
		case *CodecTypeOneOf1_FTimestampUnixMilliString:
			jsonencoder.AppendValWKTTsUnixMilli(enc, "f_timestamp_unix_milli_string", o1_82.FTimestampUnixMilliString, false, true)
		case *CodecTypeOneOf1_FTimestampUnixSecString:
			jsonencoder.AppendValWKTTsUnixSec(enc, "f_timestamp_unix_sec_string", o1_82.FTimestampUnixSecString, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message CodecTypeOneOf1 in file tests/proto/cases/format/codec_type_oneof1.proto
func (x *CodecTypeOneOf1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbformat.(*CodecTypeOneOf1) is nil")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_1  bool
		isLoad_o1_4  bool
		isLoad_o1_7  bool
		isLoad_o1_10 bool
		isLoad_o1_13 bool
		isLoad_o1_16 bool
		isLoad_o1_19 bool
		isLoad_o1_22 bool
		isLoad_o1_25 bool
		isLoad_o1_28 bool
		isLoad_o1_31 bool
		isLoad_o1_34 bool
		isLoad_o1_37 bool
		isLoad_o1_40 bool
		isLoad_o1_43 bool
		isLoad_o1_46 bool
		isLoad_o1_49 bool
		isLoad_o1_52 bool
		isLoad_o1_55 bool
		isLoad_o1_58 bool
		isLoad_o1_61 bool
		isLoad_o1_64 bool
		isLoad_o1_67 bool
		isLoad_o1_70 bool
		isLoad_o1_73 bool
		isLoad_o1_76 bool
		isLoad_o1_79 bool
		isLoad_o1_82 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32_numeric":
			if isLoad_o1_1 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_1 = true
			o1_1, ok := x.OneInt32.(*CodecTypeOneOf1_FInt32Numeric)
			if !ok {
				o1_1 = new(CodecTypeOneOf1_FInt32Numeric)
				x.OneInt32 = o1_1
			}
			if o1_1.FInt32Numeric, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_int32_string":
			if isLoad_o1_1 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_1 = true
			o1_1, ok := x.OneInt32.(*CodecTypeOneOf1_FInt32String)
			if !ok {
				o1_1 = new(CodecTypeOneOf1_FInt32String)
				x.OneInt32 = o1_1
			}
			if o1_1.FInt32String, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_int64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneInt64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_4 string
					if oneOfKey1_4, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_4 { // match the oneof key
					case "f_int64_numeric":
						if isLoad_o1_4 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_4 = true
						o1_4, ok := x.OneInt64.(*CodecTypeOneOf1_FInt64Numeric)
						if !ok {
							o1_4 = new(CodecTypeOneOf1_FInt64Numeric)
							x.OneInt64 = o1_4
						}
						if o1_4.FInt64Numeric, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_int64_string":
						if isLoad_o1_4 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_4 = true
						o1_4, ok := x.OneInt64.(*CodecTypeOneOf1_FInt64String)
						if !ok {
							o1_4 = new(CodecTypeOneOf1_FInt64String)
							x.OneInt64 = o1_4
						}
						if o1_4.FInt64String, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_uint32_numeric":
			if isLoad_o1_7 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_7 = true
			o1_7, ok := x.OneUint32.(*CodecTypeOneOf1_FUint32Numeric)
			if !ok {
				o1_7 = new(CodecTypeOneOf1_FUint32Numeric)
				x.OneUint32 = o1_7
			}
			if o1_7.FUint32Numeric, err = jsondecoder.ReadValU32(dec, false); err != nil {
				return err
			}
		case "f_uint32_string":
			if isLoad_o1_7 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_7 = true
			o1_7, ok := x.OneUint32.(*CodecTypeOneOf1_FUint32String)
			if !ok {
				o1_7 = new(CodecTypeOneOf1_FUint32String)
				x.OneUint32 = o1_7
			}
			if o1_7.FUint32String, err = jsondecoder.ReadValU32(dec, true); err != nil {
				return err
			}
		case "one_uint64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneUint64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_10 string
					if oneOfKey1_10, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_10 { // match the oneof key
					case "f_uint64_numeric":
						if isLoad_o1_10 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_10 = true
						o1_10, ok := x.OneUint64.(*CodecTypeOneOf1_FUint64Numeric)
						if !ok {
							o1_10 = new(CodecTypeOneOf1_FUint64Numeric)
							x.OneUint64 = o1_10
						}
						if o1_10.FUint64Numeric, err = jsondecoder.ReadValU64(dec, false); err != nil {
							return err
						}
					case "f_uint64_string":
						if isLoad_o1_10 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_10 = true
						o1_10, ok := x.OneUint64.(*CodecTypeOneOf1_FUint64String)
						if !ok {
							o1_10 = new(CodecTypeOneOf1_FUint64String)
							x.OneUint64 = o1_10
						}
						if o1_10.FUint64String, err = jsondecoder.ReadValU64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_sint32_numeric":
			if isLoad_o1_13 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_13 = true
			o1_13, ok := x.OneSInt32.(*CodecTypeOneOf1_FSint32Numeric)
			if !ok {
				o1_13 = new(CodecTypeOneOf1_FSint32Numeric)
				x.OneSInt32 = o1_13
			}
			if o1_13.FSint32Numeric, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_sint32_string":
			if isLoad_o1_13 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_13 = true
			o1_13, ok := x.OneSInt32.(*CodecTypeOneOf1_FSint32String)
			if !ok {
				o1_13 = new(CodecTypeOneOf1_FSint32String)
				x.OneSInt32 = o1_13
			}
			if o1_13.FSint32String, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_sint64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneSInt64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_16 string
					if oneOfKey1_16, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_16 { // match the oneof key
					case "f_sint64_numeric":
						if isLoad_o1_16 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_16 = true
						o1_16, ok := x.OneSInt64.(*CodecTypeOneOf1_FSint64Numeric)
						if !ok {
							o1_16 = new(CodecTypeOneOf1_FSint64Numeric)
							x.OneSInt64 = o1_16
						}
						if o1_16.FSint64Numeric, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_sint64_string":
						if isLoad_o1_16 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_16 = true
						o1_16, ok := x.OneSInt64.(*CodecTypeOneOf1_FSint64String)
						if !ok {
							o1_16 = new(CodecTypeOneOf1_FSint64String)
							x.OneSInt64 = o1_16
						}
						if o1_16.FSint64String, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_sfixed32_numeric":
			if isLoad_o1_19 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_19 = true
			o1_19, ok := x.OneSFixed32.(*CodecTypeOneOf1_FSfixed32Numeric)
			if !ok {
				o1_19 = new(CodecTypeOneOf1_FSfixed32Numeric)
				x.OneSFixed32 = o1_19
			}
			if o1_19.FSfixed32Numeric, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_sfixed32_string":
			if isLoad_o1_19 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_19 = true
			o1_19, ok := x.OneSFixed32.(*CodecTypeOneOf1_FSfixed32String)
			if !ok {
				o1_19 = new(CodecTypeOneOf1_FSfixed32String)
				x.OneSFixed32 = o1_19
			}
			if o1_19.FSfixed32String, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_sfixed64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneSFixed64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_22 string
					if oneOfKey1_22, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_22 { // match the oneof key
					case "f_sfixed64_numeric":
						if isLoad_o1_22 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_22 = true
						o1_22, ok := x.OneSFixed64.(*CodecTypeOneOf1_FSfixed64Numeric)
						if !ok {
							o1_22 = new(CodecTypeOneOf1_FSfixed64Numeric)
							x.OneSFixed64 = o1_22
						}
						if o1_22.FSfixed64Numeric, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_sfixed64_string":
						if isLoad_o1_22 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_22 = true
						o1_22, ok := x.OneSFixed64.(*CodecTypeOneOf1_FSfixed64String)
						if !ok {
							o1_22 = new(CodecTypeOneOf1_FSfixed64String)
							x.OneSFixed64 = o1_22
						}
						if o1_22.FSfixed64String, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_fixed32_numeric":
			if isLoad_o1_25 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_25 = true
			o1_25, ok := x.OneFixed32.(*CodecTypeOneOf1_FFixed32Numeric)
			if !ok {
				o1_25 = new(CodecTypeOneOf1_FFixed32Numeric)
				x.OneFixed32 = o1_25
			}
			if o1_25.FFixed32Numeric, err = jsondecoder.ReadValU32(dec, false); err != nil {
				return err
			}
		case "f_fixed32_string":
			if isLoad_o1_25 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_25 = true
			o1_25, ok := x.OneFixed32.(*CodecTypeOneOf1_FFixed32String)
			if !ok {
				o1_25 = new(CodecTypeOneOf1_FFixed32String)
				x.OneFixed32 = o1_25
			}
			if o1_25.FFixed32String, err = jsondecoder.ReadValU32(dec, true); err != nil {
				return err
			}
		case "one_fixed64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneFixed64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_28 string
					if oneOfKey1_28, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_28 { // match the oneof key
					case "f_fixed64_numeric":
						if isLoad_o1_28 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_28 = true
						o1_28, ok := x.OneFixed64.(*CodecTypeOneOf1_FFixed64Numeric)
						if !ok {
							o1_28 = new(CodecTypeOneOf1_FFixed64Numeric)
							x.OneFixed64 = o1_28
						}
						if o1_28.FFixed64Numeric, err = jsondecoder.ReadValU64(dec, false); err != nil {
							return err
						}
					case "f_fixed64_string":
						if isLoad_o1_28 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_28 = true
						o1_28, ok := x.OneFixed64.(*CodecTypeOneOf1_FFixed64String)
						if !ok {
							o1_28 = new(CodecTypeOneOf1_FFixed64String)
							x.OneFixed64 = o1_28
						}
						if o1_28.FFixed64String, err = jsondecoder.ReadValU64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_float_numeric":
			if isLoad_o1_31 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_31 = true
			o1_31, ok := x.OneFloat.(*CodecTypeOneOf1_FFloatNumeric)
			if !ok {
				o1_31 = new(CodecTypeOneOf1_FFloatNumeric)
				x.OneFloat = o1_31
			}
			if o1_31.FFloatNumeric, err = jsondecoder.ReadValF32(dec, false); err != nil {
				return err
			}
		case "f_float_string":
			if isLoad_o1_31 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_31 = true
			o1_31, ok := x.OneFloat.(*CodecTypeOneOf1_FFloatString)
			if !ok {
				o1_31 = new(CodecTypeOneOf1_FFloatString)
				x.OneFloat = o1_31
			}
			if o1_31.FFloatString, err = jsondecoder.ReadValF32(dec, true); err != nil {
				return err
			}
		case "one_double":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDouble = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_34 string
					if oneOfKey1_34, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_34 { // match the oneof key
					case "f_double_numeric":
						if isLoad_o1_34 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_34 = true
						o1_34, ok := x.OneDouble.(*CodecTypeOneOf1_FDoubleNumeric)
						if !ok {
							o1_34 = new(CodecTypeOneOf1_FDoubleNumeric)
							x.OneDouble = o1_34
						}
						if o1_34.FDoubleNumeric, err = jsondecoder.ReadValF64(dec, false); err != nil {
							return err
						}
					case "f_double_string":
						if isLoad_o1_34 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_34 = true
						o1_34, ok := x.OneDouble.(*CodecTypeOneOf1_FDoubleString)
						if !ok {
							o1_34 = new(CodecTypeOneOf1_FDoubleString)
							x.OneDouble = o1_34
						}
						if o1_34.FDoubleString, err = jsondecoder.ReadValF64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_bool_bool":
			if isLoad_o1_37 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_37 = true
			o1_37, ok := x.OneBool.(*CodecTypeOneOf1_FBoolBool)
			if !ok {
				o1_37 = new(CodecTypeOneOf1_FBoolBool)
				x.OneBool = o1_37
			}
			if o1_37.FBoolBool, err = jsondecoder.ReadValBool(dec, false); err != nil {
				return err
			}
		case "f_bool_string":
			if isLoad_o1_37 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_37 = true
			o1_37, ok := x.OneBool.(*CodecTypeOneOf1_FBoolString)
			if !ok {
				o1_37 = new(CodecTypeOneOf1_FBoolString)
				x.OneBool = o1_37
			}
			if o1_37.FBoolString, err = jsondecoder.ReadValBool(dec, true); err != nil {
				return err
			}
		case "one_enum1":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneEnum1 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_40 string
					if oneOfKey1_40, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_40 { // match the oneof key
					case "f_enum_numeric":
						if isLoad_o1_40 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_40 = true
						o1_40, ok := x.OneEnum1.(*CodecTypeOneOf1_FEnumNumeric)
						if !ok {
							o1_40 = new(CodecTypeOneOf1_FEnumNumeric)
							x.OneEnum1 = o1_40
						}
						if o1_40.FEnumNumeric, err = jsondecoder.ReadValEnumNum(dec, o1_40.FEnumNumeric, false); err != nil {
							return err
						}
					case "f_enum_string":
						if isLoad_o1_40 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_40 = true
						o1_40, ok := x.OneEnum1.(*CodecTypeOneOf1_FEnumString)
						if !ok {
							o1_40 = new(CodecTypeOneOf1_FEnumString)
							x.OneEnum1 = o1_40
						}
						if o1_40.FEnumString, err = jsondecoder.ReadValEnumStr(dec, o1_40.FEnumString); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_enum_numeric_string1":
			if isLoad_o1_43 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_43 = true
			o1_43, ok := x.OneEnum2.(*CodecTypeOneOf1_FEnumNumericString1)
			if !ok {
				o1_43 = new(CodecTypeOneOf1_FEnumNumericString1)
				x.OneEnum2 = o1_43
			}
			if o1_43.FEnumNumericString1, err = jsondecoder.ReadValEnumNum(dec, o1_43.FEnumNumericString1, true); err != nil {
				return err
			}
		case "f_enum_numeric_string2":
			if isLoad_o1_43 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_43 = true
			o1_43, ok := x.OneEnum2.(*CodecTypeOneOf1_FEnumNumericString2)
			if !ok {
				o1_43 = new(CodecTypeOneOf1_FEnumNumericString2)
				x.OneEnum2 = o1_43
			}
			if o1_43.FEnumNumericString2, err = jsondecoder.ReadValEnumNum(dec, o1_43.FEnumNumericString2, true); err != nil {
				return err
			}
		case "f_any_native":
			if isLoad_o1_46 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_46 = true
			o1_46, ok := x.OneAny1.(*CodecTypeOneOf1_FAnyNative)
			if !ok {
				o1_46 = new(CodecTypeOneOf1_FAnyNative)
				x.OneAny1 = o1_46
			}
			if o1_46.FAnyNative, err = jsondecoder.ReadValWKTAnyObject(dec, o1_46.FAnyNative); err != nil {
				return err
			}
		case "f_any_proto":
			if isLoad_o1_46 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_46 = true
			o1_46, ok := x.OneAny1.(*CodecTypeOneOf1_FAnyProto)
			if !ok {
				o1_46 = new(CodecTypeOneOf1_FAnyProto)
				x.OneAny1 = o1_46
			}
			if o1_46.FAnyProto, err = jsondecoder.ReadValWKTAnyProto(dec, o1_46.FAnyProto); err != nil {
				return err
			}
		case "one_duration1":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration1 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_49 string
					if oneOfKey1_49, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_49 { // match the oneof key
					case "f_duration_native":
						if isLoad_o1_49 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_49 = true
						o1_49, ok := x.OneDuration1.(*CodecTypeOneOf1_FDurationNative)
						if !ok {
							o1_49 = new(CodecTypeOneOf1_FDurationNative)
							x.OneDuration1 = o1_49
						}
						if o1_49.FDurationNative, err = jsondecoder.ReadValWKTDurObject(dec, o1_49.FDurationNative); err != nil {
							return err
						}
					case "f_duration_string":
						if isLoad_o1_49 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_49 = true
						o1_49, ok := x.OneDuration1.(*CodecTypeOneOf1_FDurationString)
						if !ok {
							o1_49 = new(CodecTypeOneOf1_FDurationString)
							x.OneDuration1 = o1_49
						}
						if o1_49.FDurationString, err = jsondecoder.ReadValWKTDurTimeStr(dec, o1_49.FDurationString); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_duration_nanosecond":
			if isLoad_o1_52 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_52 = true
			o1_52, ok := x.OneDuration2.(*CodecTypeOneOf1_FDurationNanosecond)
			if !ok {
				o1_52 = new(CodecTypeOneOf1_FDurationNanosecond)
				x.OneDuration2 = o1_52
			}
			if o1_52.FDurationNanosecond, err = jsondecoder.ReadValWKTDurNano(dec, o1_52.FDurationNanosecond, false); err != nil {
				return err
			}
		case "f_duration_microsecond":
			if isLoad_o1_52 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_52 = true
			o1_52, ok := x.OneDuration2.(*CodecTypeOneOf1_FDurationMicrosecond)
			if !ok {
				o1_52 = new(CodecTypeOneOf1_FDurationMicrosecond)
				x.OneDuration2 = o1_52
			}
			if o1_52.FDurationMicrosecond, err = jsondecoder.ReadValWKTDurMicro(dec, o1_52.FDurationMicrosecond, false); err != nil {
				return err
			}
		case "one_duration3":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration3 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_55 string
					if oneOfKey1_55, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_55 { // match the oneof key
					case "f_duration_millisecond":
						if isLoad_o1_55 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_55 = true
						o1_55, ok := x.OneDuration3.(*CodecTypeOneOf1_FDurationMillisecond)
						if !ok {
							o1_55 = new(CodecTypeOneOf1_FDurationMillisecond)
							x.OneDuration3 = o1_55
						}
						if o1_55.FDurationMillisecond, err = jsondecoder.ReadValWKTDurMilli(dec, o1_55.FDurationMillisecond, false); err != nil {
							return err
						}
					case "f_duration_second":
						if isLoad_o1_55 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_55 = true
						o1_55, ok := x.OneDuration3.(*CodecTypeOneOf1_FDurationSecond)
						if !ok {
							o1_55 = new(CodecTypeOneOf1_FDurationSecond)
							x.OneDuration3 = o1_55
						}
						if o1_55.FDurationSecond, err = jsondecoder.ReadValWKTDurSecond(dec, o1_55.FDurationSecond, false); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_duration_minute":
			if isLoad_o1_58 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_58 = true
			o1_58, ok := x.OneDuration4.(*CodecTypeOneOf1_FDurationMinute)
			if !ok {
				o1_58 = new(CodecTypeOneOf1_FDurationMinute)
				x.OneDuration4 = o1_58
			}
			if o1_58.FDurationMinute, err = jsondecoder.ReadValWKTDurMinute(dec, o1_58.FDurationMinute, false); err != nil {
				return err
			}
		case "f_duration_hour":
			if isLoad_o1_58 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_58 = true
			o1_58, ok := x.OneDuration4.(*CodecTypeOneOf1_FDurationHour)
			if !ok {
				o1_58 = new(CodecTypeOneOf1_FDurationHour)
				x.OneDuration4 = o1_58
			}
			if o1_58.FDurationHour, err = jsondecoder.ReadValWKTDurHour(dec, o1_58.FDurationHour, false); err != nil {
				return err
			}
		case "one_duration5":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration5 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_61 string
					if oneOfKey1_61, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_61 { // match the oneof key
					case "f_duration_nanosecond_string":
						if isLoad_o1_61 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_61 = true
						o1_61, ok := x.OneDuration5.(*CodecTypeOneOf1_FDurationNanosecondString)
						if !ok {
							o1_61 = new(CodecTypeOneOf1_FDurationNanosecondString)
							x.OneDuration5 = o1_61
						}
						if o1_61.FDurationNanosecondString, err = jsondecoder.ReadValWKTDurNano(dec, o1_61.FDurationNanosecondString, true); err != nil {
							return err
						}
					case "f_duration_microsecond_string":
						if isLoad_o1_61 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_61 = true
						o1_61, ok := x.OneDuration5.(*CodecTypeOneOf1_FDurationMicrosecondString)
						if !ok {
							o1_61 = new(CodecTypeOneOf1_FDurationMicrosecondString)
							x.OneDuration5 = o1_61
						}
						if o1_61.FDurationMicrosecondString, err = jsondecoder.ReadValWKTDurMicro(dec, o1_61.FDurationMicrosecondString, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_duration_millisecond_string":
			if isLoad_o1_64 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_64 = true
			o1_64, ok := x.OneDuration6.(*CodecTypeOneOf1_FDurationMillisecondString)
			if !ok {
				o1_64 = new(CodecTypeOneOf1_FDurationMillisecondString)
				x.OneDuration6 = o1_64
			}
			if o1_64.FDurationMillisecondString, err = jsondecoder.ReadValWKTDurMilli(dec, o1_64.FDurationMillisecondString, true); err != nil {
				return err
			}
		case "f_duration_second_string":
			if isLoad_o1_64 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_64 = true
			o1_64, ok := x.OneDuration6.(*CodecTypeOneOf1_FDurationSecondString)
			if !ok {
				o1_64 = new(CodecTypeOneOf1_FDurationSecondString)
				x.OneDuration6 = o1_64
			}
			if o1_64.FDurationSecondString, err = jsondecoder.ReadValWKTDurSecond(dec, o1_64.FDurationSecondString, true); err != nil {
				return err
			}
		case "one_duration7":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDuration7 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_67 string
					if oneOfKey1_67, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_67 { // match the oneof key
					case "f_duration_minute_string":
						if isLoad_o1_67 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_67 = true
						o1_67, ok := x.OneDuration7.(*CodecTypeOneOf1_FDurationMinuteString)
						if !ok {
							o1_67 = new(CodecTypeOneOf1_FDurationMinuteString)
							x.OneDuration7 = o1_67
						}
						if o1_67.FDurationMinuteString, err = jsondecoder.ReadValWKTDurMinute(dec, o1_67.FDurationMinuteString, true); err != nil {
							return err
						}
					case "f_duration_hour_string":
						if isLoad_o1_67 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_67 = true
						o1_67, ok := x.OneDuration7.(*CodecTypeOneOf1_FDurationHourString)
						if !ok {
							o1_67 = new(CodecTypeOneOf1_FDurationHourString)
							x.OneDuration7 = o1_67
						}
						if o1_67.FDurationHourString, err = jsondecoder.ReadValWKTDurHour(dec, o1_67.FDurationHourString, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "one_timestamp1":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp1 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_70 string
					if oneOfKey1_70, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_70 { // match the oneof key
					case "f_timestamp_native":
						if isLoad_o1_70 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_70 = true
						o1_70, ok := x.OneTimestamp1.(*CodecTypeOneOf1_FTimestampNative)
						if !ok {
							o1_70 = new(CodecTypeOneOf1_FTimestampNative)
							x.OneTimestamp1 = o1_70
						}
						if o1_70.FTimestampNative, err = jsondecoder.ReadValWKTTsObject(dec, o1_70.FTimestampNative); err != nil {
							return err
						}
					case "f_timestamp_time_layout":
						if isLoad_o1_70 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_70 = true
						o1_70, ok := x.OneTimestamp1.(*CodecTypeOneOf1_FTimestampTimeLayout)
						if !ok {
							o1_70 = new(CodecTypeOneOf1_FTimestampTimeLayout)
							x.OneTimestamp1 = o1_70
						}
						if o1_70.FTimestampTimeLayout, err = jsondecoder.ReadValWKTTsLayout(dec, o1_70.FTimestampTimeLayout, "2006-01-02T15:04:05Z07:00"); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_timestamp_unix_nano":
			if isLoad_o1_73 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_73 = true
			o1_73, ok := x.OneTimestamp2.(*CodecTypeOneOf1_FTimestampUnixNano)
			if !ok {
				o1_73 = new(CodecTypeOneOf1_FTimestampUnixNano)
				x.OneTimestamp2 = o1_73
			}
			if o1_73.FTimestampUnixNano, err = jsondecoder.ReadValWKTTsUnixNano(dec, o1_73.FTimestampUnixNano, false); err != nil {
				return err
			}
		case "f_timestamp_unix_micro":
			if isLoad_o1_73 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_73 = true
			o1_73, ok := x.OneTimestamp2.(*CodecTypeOneOf1_FTimestampUnixMicro)
			if !ok {
				o1_73 = new(CodecTypeOneOf1_FTimestampUnixMicro)
				x.OneTimestamp2 = o1_73
			}
			if o1_73.FTimestampUnixMicro, err = jsondecoder.ReadValWKTTsUnixMicro(dec, o1_73.FTimestampUnixMicro, false); err != nil {
				return err
			}
		case "one_timestamp3":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp3 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_76 string
					if oneOfKey1_76, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_76 { // match the oneof key
					case "f_timestamp_unix_milli":
						if isLoad_o1_76 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_76 = true
						o1_76, ok := x.OneTimestamp3.(*CodecTypeOneOf1_FTimestampUnixMilli)
						if !ok {
							o1_76 = new(CodecTypeOneOf1_FTimestampUnixMilli)
							x.OneTimestamp3 = o1_76
						}
						if o1_76.FTimestampUnixMilli, err = jsondecoder.ReadValWKTTsUnixMilli(dec, o1_76.FTimestampUnixMilli, false); err != nil {
							return err
						}
					case "f_timestamp_unix_sec":
						if isLoad_o1_76 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_76 = true
						o1_76, ok := x.OneTimestamp3.(*CodecTypeOneOf1_FTimestampUnixSec)
						if !ok {
							o1_76 = new(CodecTypeOneOf1_FTimestampUnixSec)
							x.OneTimestamp3 = o1_76
						}
						if o1_76.FTimestampUnixSec, err = jsondecoder.ReadValWKTTsUnixSec(dec, o1_76.FTimestampUnixSec, false); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_timestamp_unix_nano_string":
			if isLoad_o1_79 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_79 = true
			o1_79, ok := x.OneTimestamp4.(*CodecTypeOneOf1_FTimestampUnixNanoString)
			if !ok {
				o1_79 = new(CodecTypeOneOf1_FTimestampUnixNanoString)
				x.OneTimestamp4 = o1_79
			}
			if o1_79.FTimestampUnixNanoString, err = jsondecoder.ReadValWKTTsUnixNano(dec, o1_79.FTimestampUnixNanoString, true); err != nil {
				return err
			}
		case "f_timestamp_unix_micro_string":
			if isLoad_o1_79 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_79 = true
			o1_79, ok := x.OneTimestamp4.(*CodecTypeOneOf1_FTimestampUnixMicroString)
			if !ok {
				o1_79 = new(CodecTypeOneOf1_FTimestampUnixMicroString)
				x.OneTimestamp4 = o1_79
			}
			if o1_79.FTimestampUnixMicroString, err = jsondecoder.ReadValWKTTsUnixMicro(dec, o1_79.FTimestampUnixMicroString, true); err != nil {
				return err
			}
		case "one_timestamp5":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneTimestamp5 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_82 string
					if oneOfKey1_82, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_82 { // match the oneof key
					case "f_timestamp_unix_milli_string":
						if isLoad_o1_82 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_82 = true
						o1_82, ok := x.OneTimestamp5.(*CodecTypeOneOf1_FTimestampUnixMilliString)
						if !ok {
							o1_82 = new(CodecTypeOneOf1_FTimestampUnixMilliString)
							x.OneTimestamp5 = o1_82
						}
						if o1_82.FTimestampUnixMilliString, err = jsondecoder.ReadValWKTTsUnixMilli(dec, o1_82.FTimestampUnixMilliString, true); err != nil {
							return err
						}
					case "f_timestamp_unix_sec_string":
						if isLoad_o1_82 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_82 = true
						o1_82, ok := x.OneTimestamp5.(*CodecTypeOneOf1_FTimestampUnixSecString)
						if !ok {
							o1_82 = new(CodecTypeOneOf1_FTimestampUnixSecString)
							x.OneTimestamp5 = o1_82
						}
						if o1_82.FTimestampUnixSecString, err = jsondecoder.ReadValWKTTsUnixSec(dec, o1_82.FTimestampUnixSecString, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
