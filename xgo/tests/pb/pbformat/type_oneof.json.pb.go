// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/format/type_oneof.proto

package pbformat

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message TypeOneOf1 in file tests/proto/cases/format/type_oneof.proto
func (x *TypeOneOf1) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(896)
	enc.AppendObjectBegin() // Add begin JSON identifier

	switch o1_1 := x.OneInt32.(type) {
	case *TypeOneOf1_FInt32A:
		jsonencoder.AppendValI32(enc, "f_int32a", o1_1.FInt32A, false, false)
	case *TypeOneOf1_FInt32B:
		jsonencoder.AppendValI32(enc, "f_int32b", o1_1.FInt32B, false, true)
	}
	enc.AppendObjectKey("one_int64")
	if x.OneInt64 != nil {
		enc.AppendObjectBegin()
		switch o1_4 := x.OneInt64.(type) {
		case *TypeOneOf1_FInt64A:
			jsonencoder.AppendValI64(enc, "f_int64a", o1_4.FInt64A, false, false)
		case *TypeOneOf1_FInt64B:
			jsonencoder.AppendValI64(enc, "f_int64b", o1_4.FInt64B, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_7 := x.OneUint32.(type) {
	case *TypeOneOf1_FUint32A:
		jsonencoder.AppendValU32(enc, "f_uint32a", o1_7.FUint32A, false, false)
	case *TypeOneOf1_FUint32B:
		jsonencoder.AppendValU32(enc, "f_uint32b", o1_7.FUint32B, false, true)
	}
	enc.AppendObjectKey("one_uint64")
	if x.OneUint64 != nil {
		enc.AppendObjectBegin()
		switch o1_10 := x.OneUint64.(type) {
		case *TypeOneOf1_FUint64A:
			jsonencoder.AppendValU64(enc, "f_uint64a", o1_10.FUint64A, false, false)
		case *TypeOneOf1_FUint64B:
			jsonencoder.AppendValU64(enc, "f_uint64b", o1_10.FUint64B, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_13 := x.OneSInt32.(type) {
	case *TypeOneOf1_FSint32A:
		jsonencoder.AppendValI32(enc, "f_sint32a", o1_13.FSint32A, false, false)
	case *TypeOneOf1_FSint32B:
		jsonencoder.AppendValI32(enc, "f_sint32b", o1_13.FSint32B, false, true)
	}
	enc.AppendObjectKey("one_sint64")
	if x.OneSInt64 != nil {
		enc.AppendObjectBegin()
		switch o1_16 := x.OneSInt64.(type) {
		case *TypeOneOf1_FSint64A:
			jsonencoder.AppendValI64(enc, "f_sint64a", o1_16.FSint64A, false, false)
		case *TypeOneOf1_FSint64B:
			jsonencoder.AppendValI64(enc, "f_sint64b", o1_16.FSint64B, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_19 := x.OneSFixed32.(type) {
	case *TypeOneOf1_FSfixed32A:
		jsonencoder.AppendValI32(enc, "f_sfixed32a", o1_19.FSfixed32A, false, false)
	case *TypeOneOf1_FSfixed32B:
		jsonencoder.AppendValI32(enc, "f_sfixed32b", o1_19.FSfixed32B, false, true)
	}
	enc.AppendObjectKey("one_sfixed64")
	if x.OneSFixed64 != nil {
		enc.AppendObjectBegin()
		switch o1_22 := x.OneSFixed64.(type) {
		case *TypeOneOf1_FSfixed64A:
			jsonencoder.AppendValI64(enc, "f_sfixed64a", o1_22.FSfixed64A, false, false)
		case *TypeOneOf1_FSfixed64B:
			jsonencoder.AppendValI64(enc, "f_sfixed64b", o1_22.FSfixed64B, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_25 := x.OneFixed32.(type) {
	case *TypeOneOf1_FFixed32A:
		jsonencoder.AppendValU32(enc, "f_fixed32a", o1_25.FFixed32A, false, false)
	case *TypeOneOf1_FFixed32B:
		jsonencoder.AppendValU32(enc, "f_fixed32b", o1_25.FFixed32B, false, true)
	}
	enc.AppendObjectKey("one_fixed64")
	if x.OneFixed64 != nil {
		enc.AppendObjectBegin()
		switch o1_28 := x.OneFixed64.(type) {
		case *TypeOneOf1_FFixed64A:
			jsonencoder.AppendValU64(enc, "f_fixed64a", o1_28.FFixed64A, false, false)
		case *TypeOneOf1_FFixed64B:
			jsonencoder.AppendValU64(enc, "f_fixed64b", o1_28.FFixed64B, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_31 := x.OneFloat.(type) {
	case *TypeOneOf1_FFloat1:
		jsonencoder.AppendValF32(enc, "f_float1", o1_31.FFloat1, false, false)
	case *TypeOneOf1_FFloat2:
		jsonencoder.AppendValF32(enc, "f_float2", o1_31.FFloat2, false, true)
	}
	enc.AppendObjectKey("one_double")
	if x.OneDouble != nil {
		enc.AppendObjectBegin()
		switch o1_34 := x.OneDouble.(type) {
		case *TypeOneOf1_FDouble1:
			jsonencoder.AppendValF64(enc, "f_double1", o1_34.FDouble1, false, false)
		case *TypeOneOf1_FDouble2:
			jsonencoder.AppendValF64(enc, "f_double2", o1_34.FDouble2, false, true)
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_37 := x.OneBool.(type) {
	case *TypeOneOf1_FBool1:
		jsonencoder.AppendValBool(enc, "f_bool1", o1_37.FBool1, false, false)
	case *TypeOneOf1_FBool2:
		jsonencoder.AppendValBool(enc, "f_bool2", o1_37.FBool2, false, true)
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneOf1 in file tests/proto/cases/format/type_oneof.proto
func (x *TypeOneOf1) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbformat.(*TypeOneOf1) is nil")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_1  bool
		isLoad_o1_4  bool
		isLoad_o1_7  bool
		isLoad_o1_10 bool
		isLoad_o1_13 bool
		isLoad_o1_16 bool
		isLoad_o1_19 bool
		isLoad_o1_22 bool
		isLoad_o1_25 bool
		isLoad_o1_28 bool
		isLoad_o1_31 bool
		isLoad_o1_34 bool
		isLoad_o1_37 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32a":
			if isLoad_o1_1 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_1 = true
			o1_1, ok := x.OneInt32.(*TypeOneOf1_FInt32A)
			if !ok {
				o1_1 = new(TypeOneOf1_FInt32A)
				x.OneInt32 = o1_1
			}
			if o1_1.FInt32A, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_int32b":
			if isLoad_o1_1 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_1 = true
			o1_1, ok := x.OneInt32.(*TypeOneOf1_FInt32B)
			if !ok {
				o1_1 = new(TypeOneOf1_FInt32B)
				x.OneInt32 = o1_1
			}
			if o1_1.FInt32B, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_int64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneInt64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_4 string
					if oneOfKey1_4, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_4 { // match the oneof key
					case "f_int64a":
						if isLoad_o1_4 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_4 = true
						o1_4, ok := x.OneInt64.(*TypeOneOf1_FInt64A)
						if !ok {
							o1_4 = new(TypeOneOf1_FInt64A)
							x.OneInt64 = o1_4
						}
						if o1_4.FInt64A, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_int64b":
						if isLoad_o1_4 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_4 = true
						o1_4, ok := x.OneInt64.(*TypeOneOf1_FInt64B)
						if !ok {
							o1_4 = new(TypeOneOf1_FInt64B)
							x.OneInt64 = o1_4
						}
						if o1_4.FInt64B, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_uint32a":
			if isLoad_o1_7 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_7 = true
			o1_7, ok := x.OneUint32.(*TypeOneOf1_FUint32A)
			if !ok {
				o1_7 = new(TypeOneOf1_FUint32A)
				x.OneUint32 = o1_7
			}
			if o1_7.FUint32A, err = jsondecoder.ReadValU32(dec, false); err != nil {
				return err
			}
		case "f_uint32b":
			if isLoad_o1_7 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_7 = true
			o1_7, ok := x.OneUint32.(*TypeOneOf1_FUint32B)
			if !ok {
				o1_7 = new(TypeOneOf1_FUint32B)
				x.OneUint32 = o1_7
			}
			if o1_7.FUint32B, err = jsondecoder.ReadValU32(dec, true); err != nil {
				return err
			}
		case "one_uint64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneUint64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_10 string
					if oneOfKey1_10, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_10 { // match the oneof key
					case "f_uint64a":
						if isLoad_o1_10 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_10 = true
						o1_10, ok := x.OneUint64.(*TypeOneOf1_FUint64A)
						if !ok {
							o1_10 = new(TypeOneOf1_FUint64A)
							x.OneUint64 = o1_10
						}
						if o1_10.FUint64A, err = jsondecoder.ReadValU64(dec, false); err != nil {
							return err
						}
					case "f_uint64b":
						if isLoad_o1_10 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_10 = true
						o1_10, ok := x.OneUint64.(*TypeOneOf1_FUint64B)
						if !ok {
							o1_10 = new(TypeOneOf1_FUint64B)
							x.OneUint64 = o1_10
						}
						if o1_10.FUint64B, err = jsondecoder.ReadValU64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_sint32a":
			if isLoad_o1_13 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_13 = true
			o1_13, ok := x.OneSInt32.(*TypeOneOf1_FSint32A)
			if !ok {
				o1_13 = new(TypeOneOf1_FSint32A)
				x.OneSInt32 = o1_13
			}
			if o1_13.FSint32A, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_sint32b":
			if isLoad_o1_13 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_13 = true
			o1_13, ok := x.OneSInt32.(*TypeOneOf1_FSint32B)
			if !ok {
				o1_13 = new(TypeOneOf1_FSint32B)
				x.OneSInt32 = o1_13
			}
			if o1_13.FSint32B, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_sint64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneSInt64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_16 string
					if oneOfKey1_16, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_16 { // match the oneof key
					case "f_sint64a":
						if isLoad_o1_16 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_16 = true
						o1_16, ok := x.OneSInt64.(*TypeOneOf1_FSint64A)
						if !ok {
							o1_16 = new(TypeOneOf1_FSint64A)
							x.OneSInt64 = o1_16
						}
						if o1_16.FSint64A, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_sint64b":
						if isLoad_o1_16 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_16 = true
						o1_16, ok := x.OneSInt64.(*TypeOneOf1_FSint64B)
						if !ok {
							o1_16 = new(TypeOneOf1_FSint64B)
							x.OneSInt64 = o1_16
						}
						if o1_16.FSint64B, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_sfixed32a":
			if isLoad_o1_19 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_19 = true
			o1_19, ok := x.OneSFixed32.(*TypeOneOf1_FSfixed32A)
			if !ok {
				o1_19 = new(TypeOneOf1_FSfixed32A)
				x.OneSFixed32 = o1_19
			}
			if o1_19.FSfixed32A, err = jsondecoder.ReadValI32(dec, false); err != nil {
				return err
			}
		case "f_sfixed32b":
			if isLoad_o1_19 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_19 = true
			o1_19, ok := x.OneSFixed32.(*TypeOneOf1_FSfixed32B)
			if !ok {
				o1_19 = new(TypeOneOf1_FSfixed32B)
				x.OneSFixed32 = o1_19
			}
			if o1_19.FSfixed32B, err = jsondecoder.ReadValI32(dec, true); err != nil {
				return err
			}
		case "one_sfixed64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneSFixed64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_22 string
					if oneOfKey1_22, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_22 { // match the oneof key
					case "f_sfixed64a":
						if isLoad_o1_22 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_22 = true
						o1_22, ok := x.OneSFixed64.(*TypeOneOf1_FSfixed64A)
						if !ok {
							o1_22 = new(TypeOneOf1_FSfixed64A)
							x.OneSFixed64 = o1_22
						}
						if o1_22.FSfixed64A, err = jsondecoder.ReadValI64(dec, false); err != nil {
							return err
						}
					case "f_sfixed64b":
						if isLoad_o1_22 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_22 = true
						o1_22, ok := x.OneSFixed64.(*TypeOneOf1_FSfixed64B)
						if !ok {
							o1_22 = new(TypeOneOf1_FSfixed64B)
							x.OneSFixed64 = o1_22
						}
						if o1_22.FSfixed64B, err = jsondecoder.ReadValI64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_fixed32a":
			if isLoad_o1_25 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_25 = true
			o1_25, ok := x.OneFixed32.(*TypeOneOf1_FFixed32A)
			if !ok {
				o1_25 = new(TypeOneOf1_FFixed32A)
				x.OneFixed32 = o1_25
			}
			if o1_25.FFixed32A, err = jsondecoder.ReadValU32(dec, false); err != nil {
				return err
			}
		case "f_fixed32b":
			if isLoad_o1_25 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_25 = true
			o1_25, ok := x.OneFixed32.(*TypeOneOf1_FFixed32B)
			if !ok {
				o1_25 = new(TypeOneOf1_FFixed32B)
				x.OneFixed32 = o1_25
			}
			if o1_25.FFixed32B, err = jsondecoder.ReadValU32(dec, true); err != nil {
				return err
			}
		case "one_fixed64":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneFixed64 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_28 string
					if oneOfKey1_28, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_28 { // match the oneof key
					case "f_fixed64a":
						if isLoad_o1_28 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_28 = true
						o1_28, ok := x.OneFixed64.(*TypeOneOf1_FFixed64A)
						if !ok {
							o1_28 = new(TypeOneOf1_FFixed64A)
							x.OneFixed64 = o1_28
						}
						if o1_28.FFixed64A, err = jsondecoder.ReadValU64(dec, false); err != nil {
							return err
						}
					case "f_fixed64b":
						if isLoad_o1_28 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_28 = true
						o1_28, ok := x.OneFixed64.(*TypeOneOf1_FFixed64B)
						if !ok {
							o1_28 = new(TypeOneOf1_FFixed64B)
							x.OneFixed64 = o1_28
						}
						if o1_28.FFixed64B, err = jsondecoder.ReadValU64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_float1":
			if isLoad_o1_31 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_31 = true
			o1_31, ok := x.OneFloat.(*TypeOneOf1_FFloat1)
			if !ok {
				o1_31 = new(TypeOneOf1_FFloat1)
				x.OneFloat = o1_31
			}
			if o1_31.FFloat1, err = jsondecoder.ReadValF32(dec, false); err != nil {
				return err
			}
		case "f_float2":
			if isLoad_o1_31 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_31 = true
			o1_31, ok := x.OneFloat.(*TypeOneOf1_FFloat2)
			if !ok {
				o1_31 = new(TypeOneOf1_FFloat2)
				x.OneFloat = o1_31
			}
			if o1_31.FFloat2, err = jsondecoder.ReadValF32(dec, true); err != nil {
				return err
			}
		case "one_double":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneDouble = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_34 string
					if oneOfKey1_34, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_34 { // match the oneof key
					case "f_double1":
						if isLoad_o1_34 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_34 = true
						o1_34, ok := x.OneDouble.(*TypeOneOf1_FDouble1)
						if !ok {
							o1_34 = new(TypeOneOf1_FDouble1)
							x.OneDouble = o1_34
						}
						if o1_34.FDouble1, err = jsondecoder.ReadValF64(dec, false); err != nil {
							return err
						}
					case "f_double2":
						if isLoad_o1_34 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_34 = true
						o1_34, ok := x.OneDouble.(*TypeOneOf1_FDouble2)
						if !ok {
							o1_34 = new(TypeOneOf1_FDouble2)
							x.OneDouble = o1_34
						}
						if o1_34.FDouble2, err = jsondecoder.ReadValF64(dec, true); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_bool1":
			if isLoad_o1_37 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_37 = true
			o1_37, ok := x.OneBool.(*TypeOneOf1_FBool1)
			if !ok {
				o1_37 = new(TypeOneOf1_FBool1)
				x.OneBool = o1_37
			}
			if o1_37.FBool1, err = jsondecoder.ReadValBool(dec, false); err != nil {
				return err
			}
		case "f_bool2":
			if isLoad_o1_37 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_37 = true
			o1_37, ok := x.OneBool.(*TypeOneOf1_FBool2)
			if !ok {
				o1_37 = new(TypeOneOf1_FBool2)
				x.OneBool = o1_37
			}
			if o1_37.FBool2, err = jsondecoder.ReadValBool(dec, true); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}

// MarshalJSON implements interface json.Marshaler for proto message TypeOneOf2 in file tests/proto/cases/format/type_oneof.proto
func (x *TypeOneOf2) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(136)
	enc.AppendObjectBegin() // Add begin JSON identifier

	enc.AppendObjectKey("one_type1")
	if x.OneType1 != nil {
		enc.AppendObjectBegin()
		switch o1_1 := x.OneType1.(type) {
		case *TypeOneOf2_FString1:
			jsonencoder.AppendValStr(enc, "f_string1", o1_1.FString1, false)
		case *TypeOneOf2_FBytes1:
			if err := jsonencoder.AppendValBytes(enc, "f_bytes1", o1_1.FBytes1, false); err != nil {
				return nil, err
			}
		}
		enc.AppendObjectEnd()
	} else {
		enc.AppendValNULL()
	}
	switch o1_4 := x.OneType2.(type) {
	case *TypeOneOf2_FString2:
		jsonencoder.AppendValStr(enc, "f_string2", o1_4.FString2, false)
	case *TypeOneOf2_FBytes2:
		if err := jsonencoder.AppendValBytes(enc, "f_bytes2", o1_4.FBytes2, false); err != nil {
			return nil, err
		}
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message TypeOneOf2 in file tests/proto/cases/format/type_oneof.proto
func (x *TypeOneOf2) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pbformat.(*TypeOneOf2) is nil")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
	// declares variables to report whether the oneof field is loaded.
	var (
		isLoad_o1_1 bool
		isLoad_o1_4 bool
	)

LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "one_type1":
			if isNULL, err = dec.BeforeReadObject(); err != nil {
				return err
			}
			if isNULL {
				x.OneType1 = nil
			} else {
				for { // Loop to read oneof fields
					if isEnd, err = dec.BeforeReadNext(); err != nil {
						return err
					}
					if isEnd {
						break
					}
					var oneOfKey1_1 string
					if oneOfKey1_1, err = dec.ReadObjectKey(); err != nil {
						return err
					}
					switch oneOfKey1_1 { // match the oneof key
					case "f_string1":
						if isLoad_o1_1 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_1 = true
						o1_1, ok := x.OneType1.(*TypeOneOf2_FString1)
						if !ok {
							o1_1 = new(TypeOneOf2_FString1)
							x.OneType1 = o1_1
						}
						if o1_1.FString1, err = jsondecoder.ReadValStr(dec); err != nil {
							return err
						}
					case "f_bytes1":
						if isLoad_o1_1 {
							return jsondecoder.ErrOneOfConflict(dec)
						}
						isLoad_o1_1 = true
						o1_1, ok := x.OneType1.(*TypeOneOf2_FBytes1)
						if !ok {
							o1_1 = new(TypeOneOf2_FBytes1)
							x.OneType1 = o1_1
						}
						if o1_1.FBytes1, err = jsondecoder.ReadValBytes(dec); err != nil {
							return err
						}
					default:
						if err = dec.DiscardValue(); err != nil {
							return err
						}
					}
				}
			}
		case "f_string2":
			if isLoad_o1_4 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_4 = true
			o1_4, ok := x.OneType2.(*TypeOneOf2_FString2)
			if !ok {
				o1_4 = new(TypeOneOf2_FString2)
				x.OneType2 = o1_4
			}
			if o1_4.FString2, err = jsondecoder.ReadValStr(dec); err != nil {
				return err
			}
		case "f_bytes2":
			if isLoad_o1_4 {
				return jsondecoder.ErrOneOfConflict(dec)
			}
			isLoad_o1_4 = true
			o1_4, ok := x.OneType2.(*TypeOneOf2_FBytes2)
			if !ok {
				o1_4 = new(TypeOneOf2_FBytes2)
				x.OneType2 = o1_4
			}
			if o1_4.FBytes2, err = jsondecoder.ReadValBytes(dec); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
