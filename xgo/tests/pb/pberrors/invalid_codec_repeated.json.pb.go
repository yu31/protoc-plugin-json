// Code generated by protoc-gen-gojson. DO NOT EDIT.
// versions:
// 		protoc-gen-gojson 0.0.1
// source: tests/proto/cases/errors/invalid_codec_repeated.proto

package pberrors

import (
	errors "errors"
	_ "github.com/yu31/protoc-plugin-json/xgo/pb/pbjson"
	jsondecoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsondecoder"
	jsonencoder "github.com/yu31/protoc-plugin-json/xgo/pkg/jsonencoder"
)

// MarshalJSON implements interface json.Marshaler for proto message InvalidCodecRepeated in file tests/proto/cases/errors/invalid_codec_repeated.proto
func (x *InvalidCodecRepeated) MarshalJSON() ([]byte, error) {
	if x == nil {
		return []byte("null"), nil
	}
	enc := jsonencoder.New(2216)
	enc.AppendObjectBegin() // Add begin JSON identifier

	jsonencoder.AppendListI32(enc, "f_int32_numeric", x.FInt32Numeric, false, false)
	jsonencoder.AppendListI32(enc, "f_int32_string", x.FInt32String, false, true)
	jsonencoder.AppendListI64(enc, "f_int64_numeric", x.FInt64Numeric, false, false)
	jsonencoder.AppendListI64(enc, "f_int64_string", x.FInt64String, false, true)
	jsonencoder.AppendListU32(enc, "f_uint32_numeric", x.FUint32Numeric, false, false)
	jsonencoder.AppendListU32(enc, "f_uint32_string", x.FUint32String, false, true)
	jsonencoder.AppendListU64(enc, "f_uint64_numeric", x.FUint64Numeric, false, false)
	jsonencoder.AppendListU64(enc, "f_uint64_string", x.FUint64String, false, true)
	jsonencoder.AppendListI32(enc, "f_sint32_numeric", x.FSint32Numeric, false, false)
	jsonencoder.AppendListI32(enc, "f_sint32_string", x.FSint32String, false, true)
	jsonencoder.AppendListI64(enc, "f_sint64_numeric", x.FSint64Numeric, false, false)
	jsonencoder.AppendListI64(enc, "f_sint64_string", x.FSint64String, false, true)
	jsonencoder.AppendListI32(enc, "f_sfixed32_numeric", x.FSfixed32Numeric, false, false)
	jsonencoder.AppendListI32(enc, "f_sfixed32_string", x.FSfixed32String, false, true)
	jsonencoder.AppendListI64(enc, "f_sfixed64_numeric", x.FSfixed64Numeric, false, false)
	jsonencoder.AppendListI64(enc, "f_sfixed64_string", x.FSfixed64String, false, true)
	jsonencoder.AppendListU32(enc, "f_fixed32_numeric", x.FFixed32Numeric, false, false)
	jsonencoder.AppendListU32(enc, "f_fixed32_string", x.FFixed32String, false, true)
	jsonencoder.AppendListU64(enc, "f_fixed64_numeric", x.FFixed64Numeric, false, false)
	jsonencoder.AppendListU64(enc, "f_fixed64_string", x.FFixed64String, false, true)
	jsonencoder.AppendListF32(enc, "f_float_numeric", x.FFloatNumeric, false, false)
	jsonencoder.AppendListF32(enc, "f_float_string", x.FFloatString, false, true)
	jsonencoder.AppendListF64(enc, "f_double_numeric", x.FDoubleNumeric, false, false)
	jsonencoder.AppendListF64(enc, "f_double_string", x.FDoubleString, false, true)
	jsonencoder.AppendListBool(enc, "f_bool_bool", x.FBoolBool, false, false)
	jsonencoder.AppendListBool(enc, "f_bool_string", x.FBoolString, false, true)
	jsonencoder.AppendListStr(enc, "f_string_none", x.FStringNone, false)
	if err := jsonencoder.AppendListBytes(enc, "f_bytes_none", x.FBytesNone, false); err != nil {
		return nil, err
	}
	enc.AppendObjectEnd() // Add end JSON identifier
	return enc.Bytes(), nil
}

// UnmarshalJSON implements json.Unmarshaler for proto message InvalidCodecRepeated in file tests/proto/cases/errors/invalid_codec_repeated.proto
func (x *InvalidCodecRepeated) UnmarshalJSON(b []byte) error {
	if x == nil {
		return errors.New("json: Unmarshal: xgo/tests/pb/pberrors.(*InvalidCodecRepeated) is nil")
	}
	var (
		err    error
		isNULL bool
		dec    *jsondecoder.Decoder
	)
	if dec, err = jsondecoder.New(b); err != nil {
		return err
	}
	if isNULL, err = dec.BeforeScanJSON(); err != nil || isNULL {
		return err
	}
LOOP_SCAN:
	for { // Loop to read the JSON objects
		var (
			jsonKey string
			isEnd   bool
		)

		if isEnd, err = dec.BeforeScanNext(); err != nil {
			return err
		}
		if isEnd {
			break LOOP_SCAN
		}

		if jsonKey, err = dec.ReadJSONKey(); err != nil {
			return err
		}
		switch jsonKey { // match the jsonKey
		case "f_int32_numeric":
			if x.FInt32Numeric, err = jsondecoder.ReadListI32(dec, x.FInt32Numeric, false); err != nil {
				return err
			}
		case "f_int32_string":
			if x.FInt32String, err = jsondecoder.ReadListI32(dec, x.FInt32String, true); err != nil {
				return err
			}
		case "f_int64_numeric":
			if x.FInt64Numeric, err = jsondecoder.ReadListI64(dec, x.FInt64Numeric, false); err != nil {
				return err
			}
		case "f_int64_string":
			if x.FInt64String, err = jsondecoder.ReadListI64(dec, x.FInt64String, true); err != nil {
				return err
			}
		case "f_uint32_numeric":
			if x.FUint32Numeric, err = jsondecoder.ReadListU32(dec, x.FUint32Numeric, false); err != nil {
				return err
			}
		case "f_uint32_string":
			if x.FUint32String, err = jsondecoder.ReadListU32(dec, x.FUint32String, true); err != nil {
				return err
			}
		case "f_uint64_numeric":
			if x.FUint64Numeric, err = jsondecoder.ReadListU64(dec, x.FUint64Numeric, false); err != nil {
				return err
			}
		case "f_uint64_string":
			if x.FUint64String, err = jsondecoder.ReadListU64(dec, x.FUint64String, true); err != nil {
				return err
			}
		case "f_sint32_numeric":
			if x.FSint32Numeric, err = jsondecoder.ReadListI32(dec, x.FSint32Numeric, false); err != nil {
				return err
			}
		case "f_sint32_string":
			if x.FSint32String, err = jsondecoder.ReadListI32(dec, x.FSint32String, true); err != nil {
				return err
			}
		case "f_sint64_numeric":
			if x.FSint64Numeric, err = jsondecoder.ReadListI64(dec, x.FSint64Numeric, false); err != nil {
				return err
			}
		case "f_sint64_string":
			if x.FSint64String, err = jsondecoder.ReadListI64(dec, x.FSint64String, true); err != nil {
				return err
			}
		case "f_sfixed32_numeric":
			if x.FSfixed32Numeric, err = jsondecoder.ReadListI32(dec, x.FSfixed32Numeric, false); err != nil {
				return err
			}
		case "f_sfixed32_string":
			if x.FSfixed32String, err = jsondecoder.ReadListI32(dec, x.FSfixed32String, true); err != nil {
				return err
			}
		case "f_sfixed64_numeric":
			if x.FSfixed64Numeric, err = jsondecoder.ReadListI64(dec, x.FSfixed64Numeric, false); err != nil {
				return err
			}
		case "f_sfixed64_string":
			if x.FSfixed64String, err = jsondecoder.ReadListI64(dec, x.FSfixed64String, true); err != nil {
				return err
			}
		case "f_fixed32_numeric":
			if x.FFixed32Numeric, err = jsondecoder.ReadListU32(dec, x.FFixed32Numeric, false); err != nil {
				return err
			}
		case "f_fixed32_string":
			if x.FFixed32String, err = jsondecoder.ReadListU32(dec, x.FFixed32String, true); err != nil {
				return err
			}
		case "f_fixed64_numeric":
			if x.FFixed64Numeric, err = jsondecoder.ReadListU64(dec, x.FFixed64Numeric, false); err != nil {
				return err
			}
		case "f_fixed64_string":
			if x.FFixed64String, err = jsondecoder.ReadListU64(dec, x.FFixed64String, true); err != nil {
				return err
			}
		case "f_float_numeric":
			if x.FFloatNumeric, err = jsondecoder.ReadListF32(dec, x.FFloatNumeric, false); err != nil {
				return err
			}
		case "f_float_string":
			if x.FFloatString, err = jsondecoder.ReadListF32(dec, x.FFloatString, true); err != nil {
				return err
			}
		case "f_double_numeric":
			if x.FDoubleNumeric, err = jsondecoder.ReadListF64(dec, x.FDoubleNumeric, false); err != nil {
				return err
			}
		case "f_double_string":
			if x.FDoubleString, err = jsondecoder.ReadListF64(dec, x.FDoubleString, true); err != nil {
				return err
			}
		case "f_bool_bool":
			if x.FBoolBool, err = jsondecoder.ReadListBool(dec, x.FBoolBool, false); err != nil {
				return err
			}
		case "f_bool_string":
			if x.FBoolString, err = jsondecoder.ReadListBool(dec, x.FBoolString, true); err != nil {
				return err
			}
		case "f_string_none":
			if x.FStringNone, err = jsondecoder.ReadListStr(dec, x.FStringNone); err != nil {
				return err
			}
		case "f_bytes_none":
			if x.FBytesNone, err = jsondecoder.ReadListBytes(dec, x.FBytesNone); err != nil {
				return err
			}
		default:
			if err = dec.DiscardValue(); err != nil {
				return err
			}
		} // end switch
	}
	return nil
}
